
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ZGW'
*/

#ifndef __ECU_ZGW_H_
#define __ECU_ZGW_H_

#include <stdint.h>
    
#define ZGW_A4_CAN_ID 0x01BC
#define ZGW_A5_CAN_ID 0x001F
#define ZGW_A6_CAN_ID 0x001E
#define GW_C_B1_CAN_ID 0x0002
#define GW_C_B2_CAN_ID 0x0003
#define GW_C_B3_CAN_ID 0x0222
#define GW_C_B4_CAN_ID 0x0322
#define GW_C_B5_CAN_ID 0x010A
#define GW_C_B7_CAN_ID 0x0005
#define GW_D_B1_CAN_ID 0x018C

/** Status Service Warning */
enum class ZGW_A4_SV_WARN {
	KEINE_WARN = 0, // no warning
	SV_JETZT = 1, // Service reached
	SV_UEBZGN = 2, // Service overstated
	SNV = 3, // Signal not present
};

/** display mode */
enum class ZGW_A4_SV_ANZ_MOD {
	ANZ_REST = 0, // Service in x days/km/miles
	ANZ_UEBZGN = 1, // Service exceeded by x days/km/miles.
	ANZ_SV = 2, // Perform service
	SNV = 3, // Signal not available
};

/** scope of service */
enum class ZGW_A4_SV_UMFANG {
	KEIN_SV = 0, // no display
	SC_WART = 1, // Service code WR
	SV_A = 2, // Service scope "A"
	SV_B = 3, // Service scope "B"
};

/** Country specific SA coding */
enum class ZGW_A5_LAND {
	RDW = 0, // Rest of the world
	C494 = 1, // USA version (CODE 494)
	C460 = 2, // Canada (CODE 460)
	C498 = 3, // Japan (CODE 498)
	C823 = 4, // Switzerland (CODE 823)
	C625 = 5, // Australia (CODE 625)
	C623 = 6, // Gulf States (CODE 623)
	SNV = 15, // SG not programmed
};

/** Left/Right Hand Drive */
enum class ZGW_A5_LL_RL {
	LL = 1, // Left hand drive
	RL = 2, // Right hand drive
	SNV = 3, // SG not programmed
};

/** vehicle code body */
enum class ZGW_A5_FCOD_KAR {
	W = 0, // W - sedan (or G short BM1/3 for BR 463, G for 461)
	V = 1, // V - long sedan (or VF for BR 210/211, G long BM6 for BR 463)
	C = 2, // C - Coupé (or VV for BR 210/211/220)
	S = 3, // S - T-model (or special protection B4 for BR W240, T for BR 245)
	A = 4, // A - convertible (or X for BR 164)
	R = 5, // R - Roadster (or special protection B4 for BR 210/211/220/V240)
	SS = 6, // SS - special protection B6/7 (or CL for BR 203)
	SNV = 7, // Code not available
};

/** vehicle code series */
enum class ZGW_A5_FCOD_BR {
	BR221 = 0, // BR 221 or BR 140
	BR129 = 1, // Class 129
	BR210 = 2, // BR 210 or BR 212
	BR202 = 3, // BR 202 or BR 204
	BR220 = 4, // Class 220
	BR170 = 5, // Class 170
	BR203 = 6, // Class 203
	BR168 = 7, // Class 168
	BR163 = 8, // Class 163
	BR208 = 9, // Class 208
	BR463 = 10, // Class 463
	BR215 = 11, // Class 215
	BR230 = 12, // Class 230
	BR211 = 13, // Class 211
	BR209 = 14, // Class 209
	BR461 = 15, // Class 461
	BR240 = 16, // Class 240
	BR251 = 17, // Class 251
	BR171 = 18, // Class 171
	BR164 = 19, // Class 164
	BR169 = 20, // BR 169 or BR 245
	BR199 = 21, // BR 199
	BR216 = 22, // Class 216
	BR219 = 23, // Class 219
	BR454 = 24, // BR 454 (z-car)
	NCV2 = 25, // NCV2
	VITO = 26, // V class/Vito
	SPRINTER = 27, // sprinters
	NCV3 = 28, // NCV3
	NCV1 = 29, // NCV1
	REST = 30, // all other BR
	SNV = 31, // Code not available
};

/** Vehicle code engine */
enum class ZGW_A5_FCOD_MOT {
	M272E35_DE35 = 0, // M272 E35 or M272 DE35
	M271E18ML105 = 1, // M271 E18 ML red. (105kW)
	M271E18ML120 = 2, // M271 E18ML (120kW)
	M112E37 = 3, // M112 E37
	M272E25_DE25 = 4, // M272 E25 or M272 DE25
	M272E30_DE30 = 5, // M272 E30 or M272 DE30
	M112E28 = 7, // M112 E28
	M112E32 = 8, // M112 E32
	M273E46_DE46 = 10, // M273 E46 or M273 DE46
	M273E55_DE55 = 11, // M273 E55 or M273 DE55
	M112E26 = 12, // M112 E26
	M113E43 = 13, // M113 E43
	M113E50 = 14, // M113 E50
	M271E18ML140 = 18, // M271 E18 ML/1 (140 kW)
	M271DE18ML105 = 19, // M271 DE18 ML red. (105kW)
	M271DE18ML125 = 20, // M271 DE18ML (125kW)
	M111E_E23ML = 22, // M111E E23 ML
	M111E_E20 = 23, // M111E E20
	M111E_E20ML = 24, // M111E E20ML
	M112E32_140 = 25, // M112 E32 red. (140kW)
	M266E20ATL = 26, // M266 E20 ATL
	M266E15 = 27, // M266 E15
	M266E17 = 28, // M266 E17
	M266E20 = 29, // M266 E20
	M275E55 = 30, // M275 E55 or M285 E55
	M137E58 = 31, // M137 E58
	OM640DE20LA60 = 32, // OM 640 DE20 LA (60 kW)
	OM640DE20LA80 = 34, // OM 640 DE20 LA (80 kW)
	OM642DE30LA160 = 35, // OM642 DE30 LA (155/160 kW)
	OM640DE20LA100 = 36, // OM 640 DE20 LA (100 kW)
	OM613DE32LA = 37, // OM613 DE32 LA or OM648 DE32 LA
	OM639DE15LA = 38, // OM 639 DE15 LA (70/50 kW)
	OM628DE40LA = 39, // OM628 DE40 LA
	OM642DE30LA140 = 40, // OM642 DE30 LA (140kW)
	OM612DE27LA = 43, // OM612 DE27 LA or OM647 DE27 LA (120/130 kW)
	OM611DE22LA100 = 44, // OM611 DE22 LA (105/100 kW) or OM646 DE22 LA (100/105/110 kW)
	OM611DE22LA85 = 45, // OM611 DE22 LA (85 kW) or OM646 DE22 LA (90 kW)
	OM611DE22LA75 = 46, // OM611 DE22 LA (75 kW) or OM646 DE22 LA (75 kW)
	AMGM112E32ML = 48, // AMG M112 E32 ML
	AMGM113E55ML = 49, // AMG M113 E55 ML
	AMGM155E55ML = 50, // AMG M155 E55 ML
	AMGM275E60 = 51, // AMG M275 E60
	AMGOM612DE30LA = 52, // AMG OM612 DE30 LA
	AMGM137E63 = 56, // AMG M137 E63
	AMGM113E55 = 57, // AMG M113 E55
	AMGM156E60ML = 60, // AMG M156 E60 ML
	AMGM156E55ML = 61, // AMG M156 E63
	VR6 = 62, // VR6 from VW
	SNV = 63, // Code not available
};

/** year */
enum class ZGW_A6_VER_JAHR {
	Y_2000 = 0, // Unknown
	Y_2001 = 1, // Unknown
	Y_2002 = 2, // Unknown
	Y_2003 = 3, // Unknown
	Y_2004 = 4, // Unknown
	Y_2005 = 5, // Unknown
	Y_2006 = 6, // Unknown
	Y_2007 = 7, // Unknown
	Y_2008 = 8, // Unknown
	Y_2009 = 9, // Unknown
	Y_2010 = 10, // Unknown
	Y_2011 = 11, // Unknown
	Y_2012 = 12, // Unknown
	Y_2013 = 13, // Unknown
	Y_2014 = 14, // Unknown
	Y_2015 = 15, // Unknown
	Y_2016 = 16, // Unknown
	Y_2017 = 17, // Unknown
	Y_2018 = 18, // Unknown
	Y_2019 = 19, // Unknown
	Y_2020 = 20, // Unknown
	Y_2021 = 21, // Unknown
	Y_2022 = 22, // Unknown
	Y_2023 = 23, // Unknown
	Y_2024 = 24, // Unknown
	Y_2025 = 25, // Unknown
	Y_2026 = 26, // Unknown
	Y_2027 = 27, // Unknown
	Y_2028 = 28, // Unknown
	Y_2029 = 29, // Unknown
	N_DEF = 30, // undefined
	SB = 31, // Start of series production
};

/** Year of change */
enum class ZGW_A6_VER_AE {
	C1 = 0, // Unknown
	CX = 1, // Unknown
	C2 = 2, // Unknown
	SB = 3, // Start of series production
};

/** Brake light switch status */
enum class GW_C_B2_BLS_ST {
	BREMSE_NBET = 0, // Brake not applied
	BREMSE_BET = 1, // Brake applied
	UNKNOWN = 2, // Unknown
	SNV = 3, // Signal not available
};

/** loading */
enum class GW_C_B2_BELADUNG {
	LEER = 0, // Unloaded
	HALB = 1, // Half loaded
	VOLL = 2, // Fully loaded
	SNV = 3, // Load not recognized
};

/** Gear selector lever position (NAG only) */
enum class GW_C_B2_WHC {
	D = 5, // selector lever in position "D"
	N = 6, // Selector lever in "N" position
	R = 7, // selector lever in position "R"
	P = 8, // selector lever in position "P"
	PLUS = 9, // Selector lever in "+" position
	MINUS = 10, // Selector lever in "-" position
	N_ZW_D = 11, // selector lever in intermediate position "N-D"
	N_ZW_R = 12, // selector lever in intermediate position "N-R"
	P_ZW_R = 13, // selector lever in intermediate position "P-R"
	SNV = 15, // Selector lever position implausible
};

/** Direction of rotation of wheel, front left */
enum class GW_C_B2_DRTGVL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
};

/** Gear selector lever position (NAG, KSG, CVT) */
enum class GW_C_B2_WHST {
	P = 0, // Gear selector lever in position "P"
	R = 1, // Gear selector lever in position "R"
	N = 2, // Gear selector lever in position "N"
	D = 4, // Gear selector lever in position "D"
	SNV = 7, // Signal not available
};

/** EHB vehicle electrical system status */
enum class GW_C_B3_EHB_BN {
	U_GRUEN = 0, // U_EHB > 10.5 V for t > 500 ms
	U_GELB = 1, // 9.5 V < U_EHB <= 10.5 V for t > 500 ms
	U_ROT = 2, // 8.5 V < U_EHB <= 9.5 V for t > 500 ms
	U_MIN = 3, // U_EHB <= 8.5 V (Bosch only: or signal not available)
};

/** Heat output status */
enum class GW_C_B3_HZL_ST {
	ZU = 0, // Heater shut-off valve is closed
	AUF = 1, // Heater shut-off valve is open
	TAKT = 2, // Heating shut-off valve is clocked
	SNV = 3, // Signal not available
};

/** Presafe adjustment seat front right */
enum class GW_C_B4_PRESF_R_SVR {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Presafe adjustment of the front left seat */
enum class GW_C_B4_PRESF_L_SVL {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Presafe adjustment window front right */
enum class GW_C_B4_PRESF_R_FH {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Presafe adjustment window front left */
enum class GW_C_B4_PRESF_L_FH {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Presafe sliding/tilting sunroof adjustment */
enum class GW_C_B4_PRESF_R_SHD {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Presafe sliding/tilting sunroof adjustment */
enum class GW_C_B4_PRESF_L_SHD {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	ND = 3, // Unknown
};

/** Direction of rotation of rear wheel to the right */
enum class GW_C_B5_DRTGHR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
};

/** Direction of rotation of rear left wheel */
enum class GW_C_B5_DRTGHL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
};

/** Direction of rotation of wheel, front right */
enum class GW_C_B7_DRTGVR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ZGW_A4 */
	uint32_t get_canid(){ return ZGW_A4_CAN_ID; }
    /** Sets remaining distance in km [0], miles [1] */
    void set_RLS_KM_M(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets remaining distance in km [0], miles [1] */
    bool get_RLS_KM_M() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Priority: remaining distance [0], remaining time [1] */
    void set_RLSZ_PRIO(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Priority: remaining distance [0], remaining time [1] */
    bool get_RLSZ_PRIO() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Status Service Warning */
    void set_SV_WARN(ZGW_A4_SV_WARN value){ raw = (raw & 0xcfffffffffffffff) | ((uint64_t)value & 0x3) << 60; }

    /** Gets Status Service Warning */
    ZGW_A4_SV_WARN get_SV_WARN() const { return (ZGW_A4_SV_WARN)(raw >> 60 & 0x3); }
        
    /** Sets display mode */
    void set_SV_ANZ_MOD(ZGW_A4_SV_ANZ_MOD value){ raw = (raw & 0xf3ffffffffffffff) | ((uint64_t)value & 0x3) << 58; }

    /** Gets display mode */
    ZGW_A4_SV_ANZ_MOD get_SV_ANZ_MOD() const { return (ZGW_A4_SV_ANZ_MOD)(raw >> 58 & 0x3); }
        
    /** Sets scope of service */
    void set_SV_UMFANG(ZGW_A4_SV_UMFANG value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets scope of service */
    ZGW_A4_SV_UMFANG get_SV_UMFANG() const { return (ZGW_A4_SV_UMFANG)(raw >> 56 & 0x3); }
        
    /** Sets Service value. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: ASCII) */
    void set_SV_WERT(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Service value. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: ASCII) */
    uint8_t get_SV_WERT() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Remaining term. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Tage) */
    void set_REST_ZEIT(uint16_t value){ raw = (raw & 0xffff0000ffffffff) | ((uint64_t)value & 0xffff) << 32; }

    /** Gets Remaining term. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Tage) */
    uint16_t get_REST_ZEIT() const { return (uint16_t)(raw >> 32 & 0xffff); }
        
    /** Sets no. special service [0] no disp., [1] display */
    void set_SV_ANZ_SS(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets no. special service [0] no disp., [1] display */
    bool get_SV_ANZ_SS() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets WR data valid [0] invalid, [1] valid */
    void set_WARTUNG_OK(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets WR data valid [0] invalid, [1] valid */
    bool get_WARTUNG_OK() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets remaining distance. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: km(miles)) */
    void set_REST_WEG(uint32_t value){ raw = (raw & 0xffffffffff000000) | ((uint64_t)value & 0xffffff) << 0; }

    /** Gets remaining distance. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: km(miles)) */
    uint32_t get_REST_WEG() const { return (uint32_t)(raw >> 0 & 0xffffff); }
        
} ZGW_A4;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ZGW_A5 */
	uint32_t get_canid(){ return ZGW_A5_CAN_ID; }
    /** Sets Country specific SA coding */
    void set_LAND(ZGW_A5_LAND value){ raw = (raw & 0x0fffffffffffffff) | ((uint64_t)value & 0xf) << 60; }

    /** Gets Country specific SA coding */
    ZGW_A5_LAND get_LAND() const { return (ZGW_A5_LAND)(raw >> 60 & 0xf); }
        
    /** Sets Left/Right Hand Drive */
    void set_LL_RL(ZGW_A5_LL_RL value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets Left/Right Hand Drive */
    ZGW_A5_LL_RL get_LL_RL() const { return (ZGW_A5_LL_RL)(raw >> 56 & 0x3); }
        
    /** Sets Special Protection Guard B4 */
    void set_GUARD_B4(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Special Protection Guard B4 */
    bool get_GUARD_B4() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Modification for the disabled (via testers only) */
    void set_BEHI_FZG(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Modification for the disabled (via testers only) */
    bool get_BEHI_FZG() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Radio override taxi */
    void set_TAXI_FUNKAUF(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Radio override taxi */
    bool get_TAXI_FUNKAUF() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets special vehicle */
    void set_SO_FZG(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets special vehicle */
    bool get_SO_FZG() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Taxi call for help */
    void set_TAXI_HIRU(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Taxi call for help */
    bool get_TAXI_HIRU() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Connection for roof sign */
    void set_TAXI_DZ(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets Connection for roof sign */
    bool get_TAXI_DZ() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets Taxi emergency alarm system */
    void set_TAXI_NOTALM(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets Taxi emergency alarm system */
    bool get_TAXI_NOTALM() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets Taxi power supply */
    void set_TAXI_INT(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets Taxi power supply */
    bool get_TAXI_INT() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets Disable air recirculation comfort controls */
    void set_KB_SPERR_KLA(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Disable air recirculation comfort controls */
    bool get_KB_SPERR_KLA() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Recirculation comfort run mode automatic [0], manual [1] */
    void set_KB_MAN_KLA(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Recirculation comfort run mode automatic [0], manual [1] */
    bool get_KB_MAN_KLA() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Comfort run mode manual [0], automatic [1] */
    void set_KB_AUTO(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Comfort run mode manual [0], automatic [1] */
    bool get_KB_AUTO() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Emergency opening inactive (only via tester) */
    void set_ZV_NOT_PAS(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets Emergency opening inactive (only via tester) */
    bool get_ZV_NOT_PAS() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Special Protection Guard B6/7 */
    void set_GUARD_B6(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets Special Protection Guard B6/7 */
    bool get_GUARD_B6() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets vehicle code body */
    void set_FCOD_KAR(ZGW_A5_FCOD_KAR value){ raw = (raw & 0xffffff1fffffffff) | ((uint64_t)value & 0x7) << 37; }

    /** Gets vehicle code body */
    ZGW_A5_FCOD_KAR get_FCOD_KAR() const { return (ZGW_A5_FCOD_KAR)(raw >> 37 & 0x7); }
        
    /** Sets vehicle code series */
    void set_FCOD_BR(ZGW_A5_FCOD_BR value){ raw = (raw & 0xffffffe0ffffffff) | ((uint64_t)value & 0x1f) << 32; }

    /** Gets vehicle code series */
    ZGW_A5_FCOD_BR get_FCOD_BR() const { return (ZGW_A5_FCOD_BR)(raw >> 32 & 0x1f); }
        
    /** Sets Flat roll warning available */
    void set_PRW_VH(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Flat roll warning available */
    bool get_PRW_VH() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Vehicle code engine */
    void set_FCOD_MOT(ZGW_A5_FCOD_MOT value){ raw = (raw & 0xffffffffc0ffffff) | ((uint64_t)value & 0x3f) << 24; }

    /** Gets Vehicle code engine */
    ZGW_A5_FCOD_MOT get_FCOD_MOT() const { return (ZGW_A5_FCOD_MOT)(raw >> 24 & 0x3f); }
        
    /** Sets Xenon light present */
    void set_XEN_VH(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Xenon light present */
    bool get_XEN_VH() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets headlight cleaning system available */
    void set_SRA_VH(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets headlight cleaning system available */
    bool get_SRA_VH() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets air conditioning available */
    void set_KLA_VH(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets air conditioning available */
    bool get_KLA_VH() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Automatic transmission available */
    void set_NAG_VH(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Automatic transmission available */
    bool get_NAG_VH() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Comfort manual transmission available */
    void set_KSG_VH(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Comfort manual transmission available */
    bool get_KSG_VH() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Driver's seat memory available */
    void set_MEMORY_VH(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Driver's seat memory available */
    bool get_MEMORY_VH() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Communication platform available */
    void set_KP_VH(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Communication platform available */
    bool get_KP_VH() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets SA ART available */
    void set_ART_VH(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets SA ART available */
    bool get_ART_VH() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets SA parking heater available */
    void set_STH_VH(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets SA parking heater available */
    bool get_STH_VH() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets SA trunk lid remote closure */
    void set_HFS_VH(bool value){ raw = (raw & 0xffffffffffffefff) | ((uint64_t)value & 0x1) << 12; }

    /** Gets SA trunk lid remote closure */
    bool get_HFS_VH() const { return (bool)(raw >> 12 & 0x1); }
        
    /** Sets SA automatic loading floor available */
    void set_ALB_VH(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets SA automatic loading floor available */
    bool get_ALB_VH() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets SA CD changer available */
    void set_CDC_VH(bool value){ raw = (raw & 0xfffffffffffffbff) | ((uint64_t)value & 0x1) << 10; }

    /** Gets SA CD changer available */
    bool get_CDC_VH() const { return (bool)(raw >> 10 & 0x1); }
        
    /** Sets Parktronic system available */
    void set_PTS_VH(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets Parktronic system available */
    bool get_PTS_VH() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets Trailer hitch present */
    void set_AHK_VH(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets Trailer hitch present */
    bool get_AHK_VH() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets Rear blind available */
    void set_HR_VH(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets Rear blind available */
    bool get_HR_VH() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets SA anti-theft alarm system available */
    void set_EDW_VH(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets SA anti-theft alarm system available */
    bool get_EDW_VH() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets SA interior protection available */
    void set_IRS_VH(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets SA interior protection available */
    bool get_IRS_VH() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets SA Keyless Go available */
    void set_KG_VH(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets SA Keyless Go available */
    bool get_KG_VH() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets Complete replacement light allowed */
    void set_ERS_LICHT(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets Complete replacement light allowed */
    bool get_ERS_LICHT() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets washer fluid hose heating RL or C490 [0], LL or C875 [1] */
    void set_WWSH_VH(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets washer fluid hose heating RL or C490 [0], LL or C875 [1] */
    bool get_WWSH_VH() const { return (bool)(raw >> 0 & 0x1); }
        
} ZGW_A5;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ZGW_A6 */
	uint32_t get_canid(){ return ZGW_A6_CAN_ID; }
    /** Sets year */
    void set_VER_JAHR(ZGW_A6_VER_JAHR value){ raw = (raw & 0x83ffffffffffffff) | ((uint64_t)value & 0x1f) << 58; }

    /** Gets year */
    ZGW_A6_VER_JAHR get_VER_JAHR() const { return (ZGW_A6_VER_JAHR)(raw >> 58 & 0x1f); }
        
    /** Sets Year of change */
    void set_VER_AE(ZGW_A6_VER_AE value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets Year of change */
    ZGW_A6_VER_AE get_VER_AE() const { return (ZGW_A6_VER_AE)(raw >> 56 & 0x3); }
        
} ZGW_A6;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B1 */
	uint32_t get_canid(){ return GW_C_B1_CAN_ID; }
    /** Sets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse) */
    void set_RIZ_VL(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse) */
    uint8_t get_RIZ_VL() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse) */
    void set_RIZ_VR(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse) */
    uint8_t get_RIZ_VR() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets engine speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: 1/min) */
    void set_N_MOT(uint16_t value){ raw = (raw & 0xffff0000ffffffff) | ((uint64_t)value & 0xffff) << 32; }

    /** Gets engine speed. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: 1/min) */
    uint16_t get_N_MOT() const { return (uint16_t)(raw >> 32 & 0xffff); }
        
    /** Sets Engine coolant temperature. Conversion formula (To raw from real): y=(x+40.0)/1.00 (Unit: °C) */
    void set_T_MOT(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets Engine coolant temperature. Conversion formula (To real from raw): y=(1.00x)-40.0 (Unit: °C) */
    uint8_t get_T_MOT() const { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets Steering angle parity bit (even parity) */
    void set_LW_PA_GW(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets Steering angle parity bit (even parity) */
    bool get_LW_PA_GW() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Steering Angle Sensor: Overflow */
    void set_LW_OV_GW(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Steering Angle Sensor: Overflow */
    bool get_LW_OV_GW() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Steering angle sensor: code error */
    void set_LW_CF_GW(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Steering angle sensor: code error */
    bool get_LW_CF_GW() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Steering angle sensor: not initialized */
    void set_LW_INI_GW(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Steering angle sensor: not initialized */
    bool get_LW_INI_GW() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Steering angle sign (right [0], left [1]) */
    void set_LW_VZ_GW(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Steering angle sign (right [0], left [1]) */
    bool get_LW_VZ_GW() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets steering angle. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: °) */
    void set_LW_GW(uint16_t value){ raw = (raw & 0xfffffffffff800ff) | ((uint64_t)value & 0x7ff) << 8; }

    /** Gets steering angle. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: °) */
    uint16_t get_LW_GW() const { return (uint16_t)(raw >> 8 & 0x7ff); }
        
    /** Sets oil temperature. Conversion formula (To raw from real): y=(x+40.0)/1.00 (Unit: °C) */
    void set_T_OEL(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets oil temperature. Conversion formula (To real from raw): y=(1.00x)-40.0 (Unit: °C) */
    uint8_t get_T_OEL() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} GW_C_B1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B2 */
	uint32_t get_canid(){ return GW_C_B2_CAN_ID; }
    /** Sets ART distance warning is on */
    void set_ART_ABW_AKT(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets ART distance warning is on */
    bool get_ART_ABW_AKT() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Switch off air conditioning compressor: Acceleration */
    void set_KOMP_BAUS(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Switch off air conditioning compressor: Acceleration */
    bool get_KOMP_BAUS() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets A/C compressor emergency shutdown */
    void set_KOMP_NOTAUS(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets A/C compressor emergency shutdown */
    bool get_KOMP_NOTAUS() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Motor fan faulty indicator lamp */
    void set_LUEFT_MOT_KL(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Motor fan faulty indicator lamp */
    bool get_LUEFT_MOT_KL() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets ESP brake intervention active */
    void set_BRE_AKT_ESP(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets ESP brake intervention active */
    bool get_BRE_AKT_ESP() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets brake light suppression */
    void set_BLS_UNT(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets brake light suppression */
    bool get_BLS_UNT() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Brake light switch status */
    void set_BLS_ST(GW_C_B2_BLS_ST value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets Brake light switch status */
    GW_C_B2_BLS_ST get_BLS_ST() const { return (GW_C_B2_BLS_ST)(raw >> 56 & 0x3); }
        
    /** Sets reverse gear engaged (all transmissions) */
    void set_RG(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets reverse gear engaged (all transmissions) */
    bool get_RG() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Park position engaged */
    void set_P(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Park position engaged */
    bool get_P() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets loading */
    void set_BELADUNG(GW_C_B2_BELADUNG value){ raw = (raw & 0xffcfffffffffffff) | ((uint64_t)value & 0x3) << 52; }

    /** Gets loading */
    GW_C_B2_BELADUNG get_BELADUNG() const { return (GW_C_B2_BELADUNG)(raw >> 52 & 0x3); }
        
    /** Sets Gear selector lever position (NAG only) */
    void set_WHC(GW_C_B2_WHC value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets Gear selector lever position (NAG only) */
    GW_C_B2_WHC get_WHC() const { return (GW_C_B2_WHC)(raw >> 48 & 0xf); }
        
    /** Sets Direction of rotation of wheel, front left */
    void set_DRTGVL(GW_C_B2_DRTGVL value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets Direction of rotation of wheel, front left */
    GW_C_B2_DRTGVL get_DRTGVL() const { return (GW_C_B2_DRTGVL)(raw >> 46 & 0x3); }
        
    /** Sets Front left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min) */
    void set_DVL(uint16_t value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets Front left wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min) */
    uint16_t get_DVL() const { return (uint16_t)(raw >> 32 & 0x3fff); }
        
    /** Sets LED 2-stage switch steady light */
    void set_ST2_LED_DL(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets LED 2-stage switch steady light */
    bool get_ST2_LED_DL() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Right LED 3-position switch flashing light */
    void set_ST3_LEDR_BL(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Right LED 3-position switch flashing light */
    bool get_ST3_LEDR_BL() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Right LED 3-position switch steady light */
    void set_ST3_LEDR_DL(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Right LED 3-position switch steady light */
    bool get_ST3_LEDR_DL() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Left LED 3-position switch flashing light */
    void set_ST3_LEDL_BL(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Left LED 3-position switch flashing light */
    bool get_ST3_LEDL_BL() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Left LED 3-position switch steady light */
    void set_ST3_LEDL_DL(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Left LED 3-position switch steady light */
    bool get_ST3_LEDL_DL() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets FSG: EHB-ASG in fallback level */
    void set_INF_RFE_FSG(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets FSG: EHB-ASG in fallback level */
    bool get_INF_RFE_FSG() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Clutch engaged */
    void set_KPL(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets Clutch engaged */
    bool get_KPL() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Line monitoring possible */
    void set_LTG_CHK_POS(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Line monitoring possible */
    bool get_LTG_CHK_POS() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Gear selector lever position (NAG, KSG, CVT) */
    void set_WHST(GW_C_B2_WHST value){ raw = (raw & 0xffffffffff1fffff) | ((uint64_t)value & 0x7) << 21; }

    /** Gets Gear selector lever position (NAG, KSG, CVT) */
    GW_C_B2_WHST get_WHST() const { return (GW_C_B2_WHST)(raw >> 21 & 0x7); }
        
    /** Sets Set braking torque. Conversion formula (To raw from real): y=(x-0.0)/3.00 (Unit: Nm) */
    void set_MBRE_ESP(uint16_t value){ raw = (raw & 0xfffffffffff000ff) | ((uint64_t)value & 0xfff) << 8; }

    /** Gets Set braking torque. Conversion formula (To real from raw): y=(3.00x)+0.0 (Unit: Nm) */
    uint16_t get_MBRE_ESP() const { return (uint16_t)(raw >> 8 & 0xfff); }
        
    /** Sets Switch on auxiliary water pump */
    void set_ZWP_EIN_MS(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets Switch on auxiliary water pump */
    bool get_ZWP_EIN_MS() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets PTC auxiliary heater request off */
    void set_ZH_AUS_MS(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets PTC auxiliary heater request off */
    bool get_ZH_AUS_MS() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets SBC-S/H active, ASG must not switch to "N". */
    void set_N_VRBT_SBCSH_AKT(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets SBC-S/H active, ASG must not switch to "N". */
    bool get_N_VRBT_SBCSH_AKT() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets emergency braking (brake light flashing) */
    void set_NOTBRE(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets emergency braking (brake light flashing) */
    bool get_NOTBRE() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets Switch on additional consumers */
    void set_ZVB_EIN_MS(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets Switch on additional consumers */
    bool get_ZVB_EIN_MS() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets Substitution of left low beam */
    void set_SUB_ABL_L(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets Substitution of left low beam */
    bool get_SUB_ABL_L() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets Substitution of the low beam on the right */
    void set_SUB_ABL_R(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets Substitution of the low beam on the right */
    bool get_SUB_ABL_R() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets Idle is stable */
    void set_LL_STBL(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets Idle is stable */
    bool get_LL_STBL() const { return (bool)(raw >> 0 & 0x1); }
        
} GW_C_B2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B3 */
	uint32_t get_canid(){ return GW_C_B3_CAN_ID; }
    /** Sets Transmission oil temperature. Conversion formula (To raw from real): y=(x+50.0)/1.00 (Unit: °C) */
    void set_T_GET(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Transmission oil temperature. Conversion formula (To real from raw): y=(1.00x)-50.0 (Unit: °C) */
    uint8_t get_T_GET() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To raw from real): y=(x+10.239999771118164)/0.08 (Unit: m/s²) */
    void set_AY_S(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To real from raw): y=(0.08x)-10.239999771118164 (Unit: m/s²) */
    uint8_t get_AY_S() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Acceleration type code (>100: more dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_BMI(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Acceleration type code (>100: more dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_BMI() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets code for lateral acceleration type (>100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_FTK_LMI(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets code for lateral acceleration type (>100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_FTK_LMI() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To raw from real): y=(x+327.67999267578125)/0.01 (Unit: °/s) */
    void set_GIER_ROH(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To real from raw): y=(0.01x)-327.67999267578125 (Unit: °/s) */
    uint16_t get_GIER_ROH() const { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets EHB vehicle electrical system status */
    void set_EHB_BN(GW_C_B3_EHB_BN value){ raw = (raw & 0xffffffffffffff3f) | ((uint64_t)value & 0x3) << 6; }

    /** Gets EHB vehicle electrical system status */
    GW_C_B3_EHB_BN get_EHB_BN() const { return (GW_C_B3_EHB_BN)(raw >> 6 & 0x3); }
        
    /** Sets Heat output status */
    void set_HZL_ST(GW_C_B3_HZL_ST value){ raw = (raw & 0xffffffffffffffcf) | ((uint64_t)value & 0x3) << 4; }

    /** Gets Heat output status */
    GW_C_B3_HZL_ST get_HZL_ST() const { return (GW_C_B3_HZL_ST)(raw >> 4 & 0x3); }
        
} GW_C_B3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B4 */
	uint32_t get_canid(){ return GW_C_B4_CAN_ID; }
    /** Sets Presafe toggle bit */
    void set_PRESF_TGL(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Presafe toggle bit */
    bool get_PRESF_TGL() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Presafe adjustment seat front right */
    void set_PRESF_R_SVR(GW_C_B4_PRESF_R_SVR value){ raw = (raw & 0xf3ffffffffffffff) | ((uint64_t)value & 0x3) << 58; }

    /** Gets Presafe adjustment seat front right */
    GW_C_B4_PRESF_R_SVR get_PRESF_R_SVR() const { return (GW_C_B4_PRESF_R_SVR)(raw >> 58 & 0x3); }
        
    /** Sets Presafe adjustment of the front left seat */
    void set_PRESF_L_SVL(GW_C_B4_PRESF_L_SVL value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets Presafe adjustment of the front left seat */
    GW_C_B4_PRESF_L_SVL get_PRESF_L_SVL() const { return (GW_C_B4_PRESF_L_SVL)(raw >> 56 & 0x3); }
        
    /** Sets Presafe adjustment window front right */
    void set_PRESF_R_FH(GW_C_B4_PRESF_R_FH value){ raw = (raw & 0xff3fffffffffffff) | ((uint64_t)value & 0x3) << 54; }

    /** Gets Presafe adjustment window front right */
    GW_C_B4_PRESF_R_FH get_PRESF_R_FH() const { return (GW_C_B4_PRESF_R_FH)(raw >> 54 & 0x3); }
        
    /** Sets Presafe adjustment window front left */
    void set_PRESF_L_FH(GW_C_B4_PRESF_L_FH value){ raw = (raw & 0xffcfffffffffffff) | ((uint64_t)value & 0x3) << 52; }

    /** Gets Presafe adjustment window front left */
    GW_C_B4_PRESF_L_FH get_PRESF_L_FH() const { return (GW_C_B4_PRESF_L_FH)(raw >> 52 & 0x3); }
        
    /** Sets Presafe sliding/tilting sunroof adjustment */
    void set_PRESF_R_SHD(GW_C_B4_PRESF_R_SHD value){ raw = (raw & 0xfff3ffffffffffff) | ((uint64_t)value & 0x3) << 50; }

    /** Gets Presafe sliding/tilting sunroof adjustment */
    GW_C_B4_PRESF_R_SHD get_PRESF_R_SHD() const { return (GW_C_B4_PRESF_R_SHD)(raw >> 50 & 0x3); }
        
    /** Sets Presafe sliding/tilting sunroof adjustment */
    void set_PRESF_L_SHD(GW_C_B4_PRESF_L_SHD value){ raw = (raw & 0xfffcffffffffffff) | ((uint64_t)value & 0x3) << 48; }

    /** Gets Presafe sliding/tilting sunroof adjustment */
    GW_C_B4_PRESF_L_SHD get_PRESF_L_SHD() const { return (GW_C_B4_PRESF_L_SHD)(raw >> 48 & 0x3); }
        
} GW_C_B4;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B5 */
	uint32_t get_canid(){ return GW_C_B5_CAN_ID; }
    /** Sets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse) */
    void set_RIZ_HL(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse) */
    uint8_t get_RIZ_HL() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse) */
    void set_RIZ_HR(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse) */
    uint8_t get_RIZ_HR() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Direction of rotation of rear wheel to the right */
    void set_DRTGHR(GW_C_B5_DRTGHR value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets Direction of rotation of rear wheel to the right */
    GW_C_B5_DRTGHR get_DRTGHR() const { return (GW_C_B5_DRTGHR)(raw >> 46 & 0x3); }
        
    /** Sets Rear right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min) */
    void set_DHR(uint16_t value){ raw = (raw & 0xffffc000ffffffff) | ((uint64_t)value & 0x3fff) << 32; }

    /** Gets Rear right wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min) */
    uint16_t get_DHR() const { return (uint16_t)(raw >> 32 & 0x3fff); }
        
    /** Sets Direction of rotation of rear left wheel */
    void set_DRTGHL(GW_C_B5_DRTGHL value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets Direction of rotation of rear left wheel */
    GW_C_B5_DRTGHL get_DRTGHL() const { return (GW_C_B5_DRTGHL)(raw >> 30 & 0x3); }
        
    /** Sets Rear left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min) */
    void set_DHL(uint16_t value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets Rear left wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min) */
    uint16_t get_DHL() const { return (uint16_t)(raw >> 16 & 0x3fff); }
        
    /** Sets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To raw from real): y=(x-0.0)/0.01 */
    void set_FMMOTMAX(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To real from raw): y=(0.01x)+0.0 */
    uint8_t get_FMMOTMAX() const { return (uint8_t)(raw >> 8 & 0xff); }
        
} GW_C_B5;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_C_B7 */
	uint32_t get_canid(){ return GW_C_B7_CAN_ID; }
    /** Sets Direction of rotation of wheel, front right */
    void set_DRTGVR(GW_C_B7_DRTGVR value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets Direction of rotation of wheel, front right */
    GW_C_B7_DRTGVR get_DRTGVR() const { return (GW_C_B7_DRTGVR)(raw >> 30 & 0x3); }
        
    /** Sets front right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min) */
    void set_DVR(uint16_t value){ raw = (raw & 0xffffffffc000ffff) | ((uint64_t)value & 0x3fff) << 16; }

    /** Gets front right wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min) */
    uint16_t get_DVR() const { return (uint16_t)(raw >> 16 & 0x3fff); }
        
} GW_C_B7;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GW_D_B1 */
	uint32_t get_canid(){ return GW_D_B1_CAN_ID; }
    /** Sets Authorization status: [0] not authorized, [1] authorized */
    void set_AUT_STAT(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Authorization status: [0] not authorized, [1] authorized */
    bool get_AUT_STAT() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Alive message CP */
    void set_LIVE_CP(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Alive message CP */
    bool get_LIVE_CP() const { return (bool)(raw >> 59 & 0x1); }
        
} GW_D_B1;



class ECU_ZGW {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case ZGW_A4_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case ZGW_A5_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case ZGW_A6_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case GW_C_B1_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case GW_C_B2_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case GW_C_B3_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case GW_C_B4_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case GW_C_B5_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                case GW_C_B7_CAN_ID:
                    LAST_FRAME_TIMES[8] = timestamp_now;
                    FRAME_DATA[8] = value;
                    return true;
                case GW_D_B1_CAN_ID:
                    LAST_FRAME_TIMES[9] = timestamp_now;
                    FRAME_DATA[9] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to ZGW_A4
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ZGW_A4(uint64_t now, uint64_t max_expire_time, ZGW_A4* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to ZGW_A5
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ZGW_A5(uint64_t now, uint64_t max_expire_time, ZGW_A5* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to ZGW_A6
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ZGW_A6(uint64_t now, uint64_t max_expire_time, ZGW_A6* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B1(uint64_t now, uint64_t max_expire_time, GW_C_B1* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B2(uint64_t now, uint64_t max_expire_time, GW_C_B2* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B3(uint64_t now, uint64_t max_expire_time, GW_C_B3* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B4
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B4(uint64_t now, uint64_t max_expire_time, GW_C_B4* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[6] && now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B5
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B5(uint64_t now, uint64_t max_expire_time, GW_C_B5* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[7] && now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_C_B7
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_C_B7(uint64_t now, uint64_t max_expire_time, GW_C_B7* dest) const {
            if (LAST_FRAME_TIMES[8] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[8] && now - LAST_FRAME_TIMES[8] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[8];
                return true;
            }
        }
            
        /** Sets data in pointer to GW_D_B1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GW_D_B1(uint64_t now, uint64_t max_expire_time, GW_D_B1* dest) const {
            if (LAST_FRAME_TIMES[9] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[9] && now - LAST_FRAME_TIMES[9] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[9];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[10];
		uint64_t LAST_FRAME_TIMES[10];
};
#endif // __ECU_ZGW_H_