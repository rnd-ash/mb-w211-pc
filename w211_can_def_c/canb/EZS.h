
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'EZS'
*/

#ifndef __ECU_EZS_H_
#define __ECU_EZS_H_

#include <stdint.h>
    
#define EZS_A1_CAN_ID 0x0000
#define EZS_A12_CAN_ID 0x0180
#define EZS_A4_CAN_ID 0x0058
#define EZS_A9_CAN_ID 0x00B2
#define KG_A1_CAN_ID 0x01B2
#define KG_A2_CAN_ID 0x0050
#define EZS_ANZ_CAN_ID 0x0332
#define SD_RS_EZS_CAN_ID 0x07C0

/** Current memory block number */
enum class EZS_A1_SPEI_NR {
	SPEICHER1 = 0, // memory block 1
	SPEICHER2 = 1, // memory block 2
	SPEICHER3 = 2, // memory block 3
	nicht_definiert3 = 3, // Unknown
	nicht_definiert4 = 4, // Unknown
	nicht_definiert5 = 5, // Unknown
	nicht_definiert6 = 6, // Unknown
	SNV = 7, // Unknown
};

/** Mobility account status */
enum class EZS_A12_MOB_STAT {
	BEDGET_VAL = 0, // budget valid
	BEDGET_REQ = 1, // budget request
	FAHRER_INFO = 2, // status "Inform driver"
	FAHRER_WARN = 3, // status "warn driver"
	BUDGET_CON = 4, // budget consumed
	STAT_TEST = 5, // status test
	N_DEF = 6, // undefined
	SNV = 7, // SNV
};

/** VIN signal part */
enum class EZS_A9_VIN_MSG {
	N_DEF = 0, // undefined
	LO = 1, // VIN characters 1 - 7
	MID = 2, // VIN characters 8 - 14
	HI = 3, // VIN characters 15 - 17
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_A1 */
	uint32_t get_canid(){ return EZS_A1_CAN_ID; }
    /** Sets Keyless Go terminal control active */
    void set_KG_KL_AKT(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Keyless Go terminal control active */
    bool get_KG_KL_AKT() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Terminal 50 is switched on */
    void set_KL_50_EIN(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Terminal 50 is switched on */
    bool get_KL_50_EIN() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Terminal 15X is on */
    void set_KL_15X_EIN(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Terminal 15X is on */
    bool get_KL_15X_EIN() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Terminal 15 is switched on */
    void set_KL_15_EIN(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Terminal 15 is switched on */
    bool get_KL_15_EIN() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Terminal 15R is on */
    void set_KL_15R_EIN(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Terminal 15R is on */
    bool get_KL_15R_EIN() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Terminal 15C is on */
    void set_KL_15C_EIN(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Terminal 15C is on */
    bool get_KL_15C_EIN() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Message: "Vehicle calculates, please wait" */
    void set_FZG_RECH(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Message: "Vehicle calculates, please wait" */
    bool get_FZG_RECH() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets Diagnostic toggle bit */
    void set_DIAG_TGL(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Diagnostic toggle bit */
    bool get_DIAG_TGL() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Do not send application IDs, only NM IDs */
    void set_APPL_AUS(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Do not send application IDs, only NM IDs */
    bool get_APPL_AUS() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Panic alarm by key off */
    void set_PNK_ALM_AUS(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Panic alarm by key off */
    bool get_PNK_ALM_AUS() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Panic alarm by key on */
    void set_PNK_ALM_EIN(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Panic alarm by key on */
    bool get_PNK_ALM_EIN() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Remote trigger MSS alarm */
    void set_FERN_ALARM(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets Remote trigger MSS alarm */
    bool get_FERN_ALARM() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets Message: Renew key */
    void set_SCHLUE_NEU(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Message: Renew key */
    bool get_SCHLUE_NEU() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets Passive closure */
    void set_ZV_PASSIV(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets Passive closure */
    bool get_ZV_PASSIV() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Stop boot lid */
    void set_HD_STOPP(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Stop boot lid */
    bool get_HD_STOPP() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets Do not lock ZV while SBC added value is active */
    void set_ZV_N_VER_MW_AKT(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets Do not lock ZV while SBC added value is active */
    bool get_ZV_N_VER_MW_AKT() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets Current memory block number */
    void set_SPEI_NR(EZS_A1_SPEI_NR value){ raw = (raw & 0xfffff8ffffffffff) | ((uint64_t)value & 0x7) << 40; }

    /** Gets Current memory block number */
    EZS_A1_SPEI_NR get_SPEI_NR() const { return (EZS_A1_SPEI_NR)(raw >> 40 & 0x7); }
        
    /** Sets external security */
    void set_AUSS_SICH(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets external security */
    bool get_AUSS_SICH() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets external arming */
    void set_AUSS_ENTSI(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets external arming */
    bool get_AUSS_ENTSI() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Secure ZV blinker feedback */
    void set_BLI_SICH(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Secure ZV blinker feedback */
    bool get_BLI_SICH() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Unlock ZV indicator feedback */
    void set_BLI_ENTSI(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Unlock ZV indicator feedback */
    bool get_BLI_ENTSI() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Trunk lid remote release */
    void set_HFE_EZS(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Trunk lid remote release */
    bool get_HFE_EZS() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Secure boot lid */
    void set_HD_SICH(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Secure boot lid */
    bool get_HD_SICH() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Unlock trunk lid */
    void set_HD_ENTSI(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Unlock trunk lid */
    bool get_HD_ENTSI() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Lock fuel cap */
    void set_TD_VERRI(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Lock fuel cap */
    bool get_TD_VERRI() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Unlock the tank cap */
    void set_TD_ENTRI(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Unlock the tank cap */
    bool get_TD_ENTRI() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Open tailgate remotely */
    void set_RWTFE_EZS(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Open tailgate remotely */
    bool get_RWTFE_EZS() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets ZV post-locking */
    void set_ZV_NV(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets ZV post-locking */
    bool get_ZV_NV() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets Mechanical / FB key active */
    void set_SCHL_BEF(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets Mechanical / FB key active */
    bool get_SCHL_BEF() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets Lock rear right door */
    void set_THR_VERRI(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets Lock rear right door */
    bool get_THR_VERRI() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Unlock rear right door */
    void set_THR_ENTRI(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Unlock rear right door */
    bool get_THR_ENTRI() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Lock rear left door */
    void set_THL_VERRI(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Lock rear left door */
    bool get_THL_VERRI() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Unlock rear left door */
    void set_THL_ENTRI(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Unlock rear left door */
    bool get_THL_ENTRI() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Lock front right door */
    void set_TVR_VERRI(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Lock front right door */
    bool get_TVR_VERRI() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Unlock front right door */
    void set_TVR_ENTRI(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Unlock front right door */
    bool get_TVR_ENTRI() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Lock front left door */
    void set_TVL_VERRI(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Lock front left door */
    bool get_TVL_VERRI() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Unlock front left door */
    void set_TVL_ENTRI(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Unlock front left door */
    bool get_TVL_ENTRI() const { return (bool)(raw >> 16 & 0x1); }
        
} EZS_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_A12 */
	uint32_t get_canid(){ return EZS_A12_CAN_ID; }
    /** Sets Mobility account status */
    void set_MOB_STAT(EZS_A12_MOB_STAT value){ raw = (raw & 0x1fffffffffffffff) | ((uint64_t)value & 0x7) << 61; }

    /** Gets Mobility account status */
    EZS_A12_MOB_STAT get_MOB_STAT() const { return (EZS_A12_MOB_STAT)(raw >> 61 & 0x7); }
        
    /** Sets Mobility account activated */
    void set_MOB_AKT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Mobility account activated */
    bool get_MOB_AKT() const { return (bool)(raw >> 55 & 0x1); }
        
} EZS_A12;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_A4 */
	uint32_t get_canid(){ return EZS_A4_CAN_ID; }
    /** Sets KeyID from EZS. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SCHLUE_ID(uint32_t value){ raw = (raw & 0x00000000ffffffff) | ((uint64_t)value & 0xffffffff) << 32; }

    /** Gets KeyID from EZS. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint32_t get_SCHLUE_ID() const { return (uint32_t)(raw >> 32 & 0xffffffff); }
        
    /** Sets kilometer reading sent by the EZS. Conversion formula (To raw from real): y=(x-0.0)/0.10 (Unit: km) */
    void set_KM_EZS(uint32_t value){ raw = (raw & 0xffffffff000000ff) | ((uint64_t)value & 0xffffff) << 8; }

    /** Gets kilometer reading sent by the EZS. Conversion formula (To real from raw): y=(0.10x)+0.0 (Unit: km) */
    uint32_t get_KM_EZS() const { return (uint32_t)(raw >> 8 & 0xffffff); }
        
} EZS_A4;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_A9 */
	uint32_t get_canid(){ return EZS_A9_CAN_ID; }
    /** Sets VIN signal part */
    void set_VIN_MSG(EZS_A9_VIN_MSG value){ raw = (raw & 0xfcffffffffffffff) | ((uint64_t)value & 0x3) << 56; }

    /** Gets VIN signal part */
    EZS_A9_VIN_MSG get_VIN_MSG() const { return (EZS_A9_VIN_MSG)(raw >> 56 & 0x3); }
} EZS_A9;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KG_A1 */
	uint32_t get_canid(){ return KG_A1_CAN_ID; }
    /** Sets Message 5: "Please selector lever in P or N position" */
    void set_M5(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Message 5: "Please selector lever in P or N position" */
    bool get_M5() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Message 4: "Check chip card/key battery" (white) */
    void set_M4(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Message 4: "Check chip card/key battery" (white) */
    bool get_M4() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Message 3: "Selector lever to P" (red, continuous tone) */
    void set_M3(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Message 3: "Selector lever to P" (red, continuous tone) */
    bool get_M3() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Message 2: "Chip card/key detected in vehicle" (white) */
    void set_M2(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Message 2: "Chip card/key detected in vehicle" (white) */
    bool get_M2() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Message 1: "Chip card/key not recognized" (white) */
    void set_M1(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Message 1: "Chip card/key not recognized" (white) */
    bool get_M1() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Message 0: "Chip card/key not recognized" (red) */
    void set_M0(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Message 0: "Chip card/key not recognized" (red) */
    bool get_M0() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Turn on warning sound */
    void set_WARNTON_KG(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Turn on warning sound */
    bool get_WARNTON_KG() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Message 12: "Take your chip card/key with you!" */
    void set_M12(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets Message 12: "Take your chip card/key with you!" */
    bool get_M12() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets Message 11: "Reserved" */
    void set_M11(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Message 11: "Reserved" */
    bool get_M11() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Message 10: "Reserved" */
    void set_M10(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets Message 10: "Reserved" */
    bool get_M10() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Message 9: "Keyless Go into Diagnosis" */
    void set_M9(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Message 9: "Keyless Go into Diagnosis" */
    bool get_M9() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Message 8: "door open" */
    void set_M8(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets Message 8: "door open" */
    bool get_M8() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets Message 7: Reserved */
    void set_M7(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets Message 7: Reserved */
    bool get_M7() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets Message 6: "Reserved" */
    void set_M6(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets Message 6: "Reserved" */
    bool get_M6() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets Keyless Go route indication. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: km) */
    void set_KM_REST_KG(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Keyless Go route indication. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: km) */
    uint8_t get_KM_REST_KG() const { return (uint8_t)(raw >> 40 & 0xff); }
        
} KG_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KG_A2 */
	uint32_t get_canid(){ return KG_A2_CAN_ID; }
    /** Sets Open/close rear right window */
    void set_FHR_KG(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Open/close rear right window */
    bool get_FHR_KG() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Open/close rear left window */
    void set_FHL_KG(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Open/close rear left window */
    bool get_FHL_KG() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Open/close front right window */
    void set_FVR_KG(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Open/close front right window */
    bool get_FVR_KG() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Open/close front left window */
    void set_FVL_KG(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Open/close front left window */
    bool get_FVL_KG() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Open/close SHD */
    void set_SHD_KG(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Open/close SHD */
    bool get_SHD_KG() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets direction comfort operation: open [0], close [1] */
    void set_KB_RI_KG(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets direction comfort operation: open [0], close [1] */
    bool get_KB_RI_KG() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Comfort control Automatic operation [1] Manual [0] */
    void set_KB_MOD_KG(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Comfort control Automatic operation [1] Manual [0] */
    bool get_KB_MOD_KG() const { return (bool)(raw >> 57 & 0x1); }
        
} KG_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of EZS_ANZ */
	uint32_t get_canid(){ return EZS_ANZ_CAN_ID; }
    /** Sets Message 7: "MK " */
    void set_EZS_M7(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Message 7: "MK " */
    bool get_EZS_M7() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Message 6: "MK manual reloading failed" */
    void set_EZS_M6(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Message 6: "MK manual reloading failed" */
    bool get_EZS_M6() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Message 5: "MK manual reloading successful" */
    void set_EZS_M5(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Message 5: "MK manual reloading successful" */
    bool get_EZS_M5() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Message 4: "MK manual reloading carried out" */
    void set_EZS_M4(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Message 4: "MK manual reloading carried out" */
    bool get_EZS_M4() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Message 3: "MK authorization error" */
    void set_EZS_M3(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Message 3: "MK authorization error" */
    bool get_EZS_M3() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Message 2: "MK expired, vehicle blocked" */
    void set_EZS_M2(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Message 2: "MK expired, vehicle blocked" */
    bool get_EZS_M2() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Message 1: "Reload MK immediately" */
    void set_EZS_M1(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Message 1: "Reload MK immediately" */
    bool get_EZS_M1() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Message 0: "MK status reduced" */
    void set_EZS_M0(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Message 0: "MK status reduced" */
    bool get_EZS_M0() const { return (bool)(raw >> 56 & 0x1); }
        
} EZS_ANZ;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SD_RS_EZS */
	uint32_t get_canid(){ return SD_RS_EZS_CAN_ID; }
    /** Sets Identification for > 8 bytes */
    void set_EZS_KENN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Identification for > 8 bytes */
    bool get_EZS_KENN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets error vector 07h */
    void set_EZS_FV07(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets error vector 07h */
    bool get_EZS_FV07() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets error vector 06h */
    void set_EZS_FV06(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets error vector 06h */
    bool get_EZS_FV06() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets error vector 05h */
    void set_EZS_FV05(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets error vector 05h */
    bool get_EZS_FV05() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets error vector 04h */
    void set_EZS_FV04(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets error vector 04h */
    bool get_EZS_FV04() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets error vector 03h */
    void set_EZS_FV03(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets error vector 03h */
    bool get_EZS_FV03() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets error vector 02h */
    void set_EZS_FV02(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets error vector 02h */
    bool get_EZS_FV02() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets error vector 01h */
    void set_EZS_FV01(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets error vector 01h */
    bool get_EZS_FV01() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets error vector 0Fh */
    void set_EZS_FV0F(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets error vector 0Fh */
    bool get_EZS_FV0F() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets error vector 0Eh */
    void set_EZS_FV0E(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets error vector 0Eh */
    bool get_EZS_FV0E() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets error vector 0Dh */
    void set_EZS_FV0D(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets error vector 0Dh */
    bool get_EZS_FV0D() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets error vector 0Ch */
    void set_EZS_FV0C(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets error vector 0Ch */
    bool get_EZS_FV0C() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets error vector 0Bh */
    void set_EZS_FV0B(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets error vector 0Bh */
    bool get_EZS_FV0B() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets error vector 0Ah */
    void set_EZS_FV0A(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets error vector 0Ah */
    bool get_EZS_FV0A() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets error vector 09h */
    void set_EZS_FV09(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets error vector 09h */
    bool get_EZS_FV09() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets error vector 08h */
    void set_EZS_FV08(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets error vector 08h */
    bool get_EZS_FV08() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets error vector 17h */
    void set_EZS_FV17(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets error vector 17h */
    bool get_EZS_FV17() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets error vector 16h */
    void set_EZS_FV16(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets error vector 16h */
    bool get_EZS_FV16() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets error vector 15h */
    void set_EZS_FV15(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets error vector 15h */
    bool get_EZS_FV15() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets error vector 14h */
    void set_EZS_FV14(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets error vector 14h */
    bool get_EZS_FV14() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets error vector 13h */
    void set_EZS_FV13(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets error vector 13h */
    bool get_EZS_FV13() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets error vector 12h */
    void set_EZS_FV12(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets error vector 12h */
    bool get_EZS_FV12() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets error vector 11h */
    void set_EZS_FV11(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets error vector 11h */
    bool get_EZS_FV11() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets error vector 10h */
    void set_EZS_FV10(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets error vector 10h */
    bool get_EZS_FV10() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets error vector 1Fh */
    void set_EZS_FV1F(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets error vector 1Fh */
    bool get_EZS_FV1F() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets error vector 1Eh */
    void set_EZS_FV1E(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets error vector 1Eh */
    bool get_EZS_FV1E() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets error vector 1Dh */
    void set_EZS_FV1D(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets error vector 1Dh */
    bool get_EZS_FV1D() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Error vector 1Ch */
    void set_EZS_FV1C(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Error vector 1Ch */
    bool get_EZS_FV1C() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets error vector 1Bh */
    void set_EZS_FV1B(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets error vector 1Bh */
    bool get_EZS_FV1B() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets Error vector 1Ah */
    void set_EZS_FV1A(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets Error vector 1Ah */
    bool get_EZS_FV1A() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets error vector 19h */
    void set_EZS_FV19(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets error vector 19h */
    bool get_EZS_FV19() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets error vector 18h */
    void set_EZS_FV18(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets error vector 18h */
    bool get_EZS_FV18() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets error vector 27h */
    void set_EZS_FV27(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets error vector 27h */
    bool get_EZS_FV27() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets error vector 26h */
    void set_EZS_FV26(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets error vector 26h */
    bool get_EZS_FV26() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets error vector 25h */
    void set_EZS_FV25(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets error vector 25h */
    bool get_EZS_FV25() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets error vector 24h */
    void set_EZS_FV24(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets error vector 24h */
    bool get_EZS_FV24() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets error vector 23h */
    void set_EZS_FV23(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets error vector 23h */
    bool get_EZS_FV23() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets error vector 22h */
    void set_EZS_FV22(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets error vector 22h */
    bool get_EZS_FV22() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets error vector 21h */
    void set_EZS_FV21(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets error vector 21h */
    bool get_EZS_FV21() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets error vector 20h */
    void set_EZS_FV20(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets error vector 20h */
    bool get_EZS_FV20() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets error vector 2Fh */
    void set_EZS_FV2F(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets error vector 2Fh */
    bool get_EZS_FV2F() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets error vector 2Eh */
    void set_EZS_FV2E(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets error vector 2Eh */
    bool get_EZS_FV2E() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets error vector 2Dh */
    void set_EZS_FV2D(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets error vector 2Dh */
    bool get_EZS_FV2D() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets error vector 2Ch */
    void set_EZS_FV2C(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets error vector 2Ch */
    bool get_EZS_FV2C() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets error vector 2Bh */
    void set_EZS_FV2B(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets error vector 2Bh */
    bool get_EZS_FV2B() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Error vector 2Ah */
    void set_EZS_FV2A(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Error vector 2Ah */
    bool get_EZS_FV2A() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets error vector 29h */
    void set_EZS_FV29(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets error vector 29h */
    bool get_EZS_FV29() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets error vector 28h */
    void set_EZS_FV28(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets error vector 28h */
    bool get_EZS_FV28() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets state variable 04h */
    void set_EZS_PGV04(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets state variable 04h */
    bool get_EZS_PGV04() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets state variable 03h */
    void set_EZS_PGV03(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets state variable 03h */
    bool get_EZS_PGV03() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets state variable 02h */
    void set_EZS_PGV02(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets state variable 02h */
    bool get_EZS_PGV02() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets state variable 01h */
    void set_EZS_PGV01(bool value){ raw = (raw & 0xffffffffffffefff) | ((uint64_t)value & 0x1) << 12; }

    /** Gets state variable 01h */
    bool get_EZS_PGV01() const { return (bool)(raw >> 12 & 0x1); }
        
    /** Sets error vector 33h */
    void set_EZS_FV33(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets error vector 33h */
    bool get_EZS_FV33() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets error vector 32h */
    void set_EZS_FV32(bool value){ raw = (raw & 0xfffffffffffffbff) | ((uint64_t)value & 0x1) << 10; }

    /** Gets error vector 32h */
    bool get_EZS_FV32() const { return (bool)(raw >> 10 & 0x1); }
        
    /** Sets error vector 31h */
    void set_EZS_FV31(bool value){ raw = (raw & 0xfffffffffffffdff) | ((uint64_t)value & 0x1) << 9; }

    /** Gets error vector 31h */
    bool get_EZS_FV31() const { return (bool)(raw >> 9 & 0x1); }
        
    /** Sets error vector 30h */
    void set_EZS_FV30(bool value){ raw = (raw & 0xfffffffffffffeff) | ((uint64_t)value & 0x1) << 8; }

    /** Gets error vector 30h */
    bool get_EZS_FV30() const { return (bool)(raw >> 8 & 0x1); }
        
} SD_RS_EZS;



class ECU_EZS {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case EZS_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case EZS_A12_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case EZS_A4_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case EZS_A9_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case KG_A1_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case KG_A2_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case EZS_ANZ_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                case SD_RS_EZS_CAN_ID:
                    LAST_FRAME_TIMES[7] = timestamp_now;
                    FRAME_DATA[7] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to EZS_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_A1(uint64_t now, uint64_t max_expire_time, EZS_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to EZS_A12
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_A12(uint64_t now, uint64_t max_expire_time, EZS_A12* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to EZS_A4
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_A4(uint64_t now, uint64_t max_expire_time, EZS_A4* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to EZS_A9
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_A9(uint64_t now, uint64_t max_expire_time, EZS_A9* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to KG_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KG_A1(uint64_t now, uint64_t max_expire_time, KG_A1* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to KG_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KG_A2(uint64_t now, uint64_t max_expire_time, KG_A2* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to EZS_ANZ
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_EZS_ANZ(uint64_t now, uint64_t max_expire_time, EZS_ANZ* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[6] && now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
        /** Sets data in pointer to SD_RS_EZS
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SD_RS_EZS(uint64_t now, uint64_t max_expire_time, SD_RS_EZS* dest) const {
            if (LAST_FRAME_TIMES[7] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[7] && now - LAST_FRAME_TIMES[7] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[7];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[8];
		uint64_t LAST_FRAME_TIMES[8];
};
#endif // __ECU_EZS_H_