
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'SAM_H'
*/

#ifndef __ECU_SAM_H_H_
#define __ECU_SAM_H_H_

#include <stdint.h>
    
#define SAM_H_A1_CAN_ID 0x0004
#define SAM_H_A2_CAN_ID 0x0090
#define SAM_H_A3_CAN_ID 0x000E
#define SAM_H_A5_CAN_ID 0x0230
#define SAM_H_A7_CAN_ID 0x016C
#define SD_RS_SAM_H_CAN_ID 0x07C3



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SAM_H_A1 */
	uint32_t get_canid(){ return SAM_H_A1_CAN_ID; }
    /** Sets Panic alarm is active */
    void set_PNK_AKT(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Panic alarm is active */
    bool get_PNK_AKT() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Terminal 54 hardware active */
    void set_KL54_RM(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Terminal 54 hardware active */
    bool get_KL54_RM() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Trunk lid contact pressed */
    void set_HDK_BET(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Trunk lid contact pressed */
    bool get_HDK_BET() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Boot lid is open */
    void set_HD_AUF(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Boot lid is open */
    bool get_HD_AUF() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Rear right door is open */
    void set_THR_AUF(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Rear right door is open */
    bool get_THR_AUF() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Rear left door is open */
    void set_THL_AUF(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Rear left door is open */
    bool get_THL_AUF() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Front right door is open */
    void set_TVR_AUF(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Front right door is open */
    bool get_TVR_AUF() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Front left door is open */
    void set_TVL_AUF(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Front left door is open */
    bool get_TVL_AUF() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Bonnet is up */
    void set_MOT_AUF(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Bonnet is up */
    bool get_MOT_AUF() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets heat. Rear window is switched off due to undervoltage. */
    void set_HHS_ST_USPG(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets heat. Rear window is switched off due to undervoltage. */
    bool get_HHS_ST_USPG() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets Heated rear window is switched on */
    void set_HHS_ST_EIN(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets Heated rear window is switched on */
    bool get_HHS_ST_EIN() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets Rear lock in 90° position */
    void set_HSCHL_ZU(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets Rear lock in 90° position */
    bool get_HSCHL_ZU() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets SAM/H passive */
    void set_SAM_H_PAS(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets SAM/H passive */
    bool get_SAM_H_PAS() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets Switch on EDW interior light */
    void set_EDW_IL_EIN(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets Switch on EDW interior light */
    bool get_EDW_IL_EIN() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets EDW sharpened */
    void set_EDW_AKT(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets EDW sharpened */
    bool get_EDW_AKT() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets Activate EDW interior protection */
    void set_EDW_IRS_AKT(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets Activate EDW interior protection */
    bool get_EDW_IRS_AKT() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets Activate EDW trailer monitoring */
    void set_EDW_AAG_AKT(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets Activate EDW trailer monitoring */
    bool get_EDW_AAG_AKT() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets EDW alarm triggered */
    void set_EDW_ALARM(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets EDW alarm triggered */
    bool get_EDW_ALARM() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets ATA activated when driver's door is open */
    void set_EDW_FT_ENT(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets ATA activated when driver's door is open */
    bool get_EDW_FT_ENT() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets EDW self-sharpening "Belgium" active */
    void set_EDW_AUTO_AKTIV(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets EDW self-sharpening "Belgium" active */
    bool get_EDW_AUTO_AKTIV() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets Left license plate light defective */
    void set_KZL_DEF_L(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets Left license plate light defective */
    bool get_KZL_DEF_L() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets Left reverse light defective */
    void set_RFL_DEF_L(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets Left reverse light defective */
    bool get_RFL_DEF_L() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets Left brake light defective */
    void set_BL_DEF_L(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets Left brake light defective */
    bool get_BL_DEF_L() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Left tail light defective */
    void set_SL_DEF_L(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Left tail light defective */
    bool get_SL_DEF_L() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets Turn signal rear left defective */
    void set_BLI_DEF_HL(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets Turn signal rear left defective */
    bool get_BLI_DEF_HL() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets Left rear fog light defective */
    void set_NSL_DEF_L(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets Left rear fog light defective */
    bool get_NSL_DEF_L() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets 3rd brake light defective */
    void set_BL3_DEF(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets 3rd brake light defective */
    bool get_BL3_DEF() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets Terminal 54 error */
    void set_KL_54_DEF(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets Terminal 54 error */
    bool get_KL_54_DEF() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets Right license plate light defective */
    void set_KZL_DEF_R(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets Right license plate light defective */
    bool get_KZL_DEF_R() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets Right reversing light defective */
    void set_RFL_DEF_R(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Right reversing light defective */
    bool get_RFL_DEF_R() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Right brake light defective */
    void set_BL_DEF_R(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Right brake light defective */
    bool get_BL_DEF_R() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Right tail light defective */
    void set_SL_DEF_R(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Right tail light defective */
    bool get_SL_DEF_R() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Turn signal rear right defective */
    void set_BLI_DEF_HR(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Turn signal rear right defective */
    bool get_BLI_DEF_HR() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Right rear fog light defective */
    void set_NSL_DEF_R(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets Right rear fog light defective */
    bool get_NSL_DEF_R() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets Replacement brake light, rear right */
    void set_BL_ERS_HR(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Replacement brake light, rear right */
    bool get_BL_ERS_HR() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Replacement tail light rear right active */
    void set_SL_ERS_HR(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Replacement tail light rear right active */
    bool get_SL_ERS_HR() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Replacement indicator light, rear right active */
    void set_BLI_ERS_HR(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Replacement indicator light, rear right active */
    bool get_BLI_ERS_HR() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Replacement brake light, rear left */
    void set_BL_ERS_HL(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Replacement brake light, rear left */
    bool get_BL_ERS_HL() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Replacement tail light rear left active */
    void set_SL_ERS_HL(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Replacement tail light rear left active */
    bool get_SL_ERS_HL() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Spare light indicator rear left active */
    void set_BLI_ERS_HL(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Spare light indicator rear left active */
    bool get_BLI_ERS_HL() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets Turn on HFS locator lights */
    void set_HFS_SB_EIN(bool value){ raw = (raw & 0xffffffffffffefff) | ((uint64_t)value & 0x1) << 12; }

    /** Gets Turn on HFS locator lights */
    bool get_HFS_SB_EIN() const { return (bool)(raw >> 12 & 0x1); }
        
    /** Sets Right rear seat locked */
    void set_FS_VER_R(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets Right rear seat locked */
    bool get_FS_VER_R() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets Left rear seat locked */
    void set_FS_VER_L(bool value){ raw = (raw & 0xfffffffffffffbff) | ((uint64_t)value & 0x1) << 10; }

    /** Gets Left rear seat locked */
    bool get_FS_VER_L() const { return (bool)(raw >> 10 & 0x1); }
        
    /** Sets Right rear seat unlocked */
    void set_FS_ENT_R(bool value){ raw = (raw & 0xfffffffffffffdff) | ((uint64_t)value & 0x1) << 9; }

    /** Gets Right rear seat unlocked */
    bool get_FS_ENT_R() const { return (bool)(raw >> 9 & 0x1); }
        
    /** Sets Left rear seat unlocked */
    void set_FS_ENT_L(bool value){ raw = (raw & 0xfffffffffffffeff) | ((uint64_t)value & 0x1) << 8; }

    /** Gets Left rear seat unlocked */
    bool get_FS_ENT_L() const { return (bool)(raw >> 8 & 0x1); }
        
    /** Sets Turn on the dimmed right rear fog light */
    void set_NSL_R_D_EIN(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets Turn on the dimmed right rear fog light */
    bool get_NSL_R_D_EIN() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets Switch on left fog lamp dimmed */
    void set_NSL_L_D_EIN(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets Switch on left fog lamp dimmed */
    bool get_NSL_L_D_EIN() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets Turn on the right rear fog light */
    void set_NSL_R_EIN(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets Turn on the right rear fog light */
    bool get_NSL_R_EIN() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets Turn on the left rear fog light */
    void set_NSL_L_EIN(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets Turn on the left rear fog light */
    bool get_NSL_L_EIN() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets Turn on the right reversing light */
    void set_RFL_R_EIN(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets Turn on the right reversing light */
    bool get_RFL_R_EIN() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets Turn on the left reversing light */
    void set_RFL_L_EIN(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets Turn on the left reversing light */
    bool get_RFL_L_EIN() const { return (bool)(raw >> 0 & 0x1); }
        
} SAM_H_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SAM_H_A2 */
	uint32_t get_canid(){ return SAM_H_A2_CAN_ID; }
    /** Sets tank level. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: %) */
    void set_TANK_FS_B(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets tank level. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: %) */
    uint8_t get_TANK_FS_B() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Right tank sender value. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: %) */
    void set_TANK_GE_RE(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Right tank sender value. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: %) */
    uint8_t get_TANK_GE_RE() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Tank sensor value on the left. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: %) */
    void set_TANK_GE_LI(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Tank sensor value on the left. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: %) */
    uint8_t get_TANK_GE_LI() const { return (uint8_t)(raw >> 40 & 0xff); }
        
} SAM_H_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SAM_H_A3 */
	uint32_t get_canid(){ return SAM_H_A3_CAN_ID; }
    /** Sets Turn on the right turn signal */
    void set_BLI_RE_EIN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn on the right turn signal */
    bool get_BLI_RE_EIN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Turn on the left turn signal */
    void set_BLI_LI_EIN(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Turn on the left turn signal */
    bool get_BLI_LI_EIN() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Hazard warning lights active */
    void set_WARN_AKT(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Hazard warning lights active */
    bool get_WARN_AKT() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets flashing light phase. Conversion formula (To raw from real): y=(x-0.0)/10.00 (Unit: ms) */
    void set_HELL_BLINK(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets flashing light phase. Conversion formula (To real from raw): y=(10.00x)+0.0 (Unit: ms) */
    uint8_t get_HELL_BLINK() const { return (uint8_t)(raw >> 48 & 0xff); }
        
} SAM_H_A3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SAM_H_A5 */
	uint32_t get_canid(){ return SAM_H_A5_CAN_ID; }
    /** Sets Turn on fog lights */
    void set_NSW_EIN_EDW(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Turn on fog lights */
    bool get_NSW_EIN_EDW() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Turn on low beam */
    void set_ABL_EIN_EDW(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Turn on low beam */
    bool get_ABL_EIN_EDW() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Turn on tail light */
    void set_SL_EIN_EDW(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Turn on tail light */
    bool get_SL_EIN_EDW() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Duration of light phase. Conversion formula (To raw from real): y=(x-0.0)/10.00 (Unit: ms) */
    void set_HELL_EDW(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Duration of light phase. Conversion formula (To real from raw): y=(10.00x)+0.0 (Unit: ms) */
    uint8_t get_HELL_EDW() const { return (uint8_t)(raw >> 48 & 0xff); }
        
} SAM_H_A5;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SAM_H_A7 */
	uint32_t get_canid(){ return SAM_H_A7_CAN_ID; }
    /** Sets Close the tailgate button */
    void set_TST_HFS_SCHL(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Close the tailgate button */
    bool get_TST_HFS_SCHL() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Open tailgate button */
    void set_TST_HFS_OEFF(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Open tailgate button */
    bool get_TST_HFS_OEFF() const { return (bool)(raw >> 56 & 0x1); }
        
} SAM_H_A7;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SD_RS_SAM_H */
	uint32_t get_canid(){ return SD_RS_SAM_H_CAN_ID; }
    /** Sets Identification for > 8 bytes */
    void set_SAM_H_KENN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Identification for > 8 bytes */
    bool get_SAM_H_KENN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets state variable 07h */
    void set_SAM_H_PGV07(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets state variable 07h */
    bool get_SAM_H_PGV07() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets state variable 06h */
    void set_SAM_H_PGV06(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets state variable 06h */
    bool get_SAM_H_PGV06() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets state variable 05h */
    void set_SAM_H_PGV05(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets state variable 05h */
    bool get_SAM_H_PGV05() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets state variable 04h */
    void set_SAM_H_PGV04(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets state variable 04h */
    bool get_SAM_H_PGV04() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets state variable 03h */
    void set_SAM_H_PGV03(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets state variable 03h */
    bool get_SAM_H_PGV03() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets state variable 02h */
    void set_SAM_H_PGV02(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets state variable 02h */
    bool get_SAM_H_PGV02() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets state variable 01h */
    void set_SAM_H_PGV01(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets state variable 01h */
    bool get_SAM_H_PGV01() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Error message 01h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SAM_H_FM01(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets Error message 01h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_SAM_H_FM01() const { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Error message 02h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SAM_H_FM02(uint16_t value){ raw = (raw & 0xffffff0000ffffff) | ((uint64_t)value & 0xffff) << 24; }

    /** Gets Error message 02h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_SAM_H_FM02() const { return (uint16_t)(raw >> 24 & 0xffff); }
        
    /** Sets Error message 03h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_SAM_H_FM03(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets Error message 03h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_SAM_H_FM03() const { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets state variable 0Fh */
    void set_SAM_H_PGV0F(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets state variable 0Fh */
    bool get_SAM_H_PGV0F() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets state variable 0Eh */
    void set_SAM_H_PGV0E(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets state variable 0Eh */
    bool get_SAM_H_PGV0E() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets State variable 0Dh */
    void set_SAM_H_PGV0D(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets State variable 0Dh */
    bool get_SAM_H_PGV0D() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets state variable 0Ch */
    void set_SAM_H_PGV0C(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets state variable 0Ch */
    bool get_SAM_H_PGV0C() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets state variable 0Bh */
    void set_SAM_H_PGV0B(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets state variable 0Bh */
    bool get_SAM_H_PGV0B() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets State variable 0Ah */
    void set_SAM_H_PGV0A(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets State variable 0Ah */
    bool get_SAM_H_PGV0A() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets state variable 09h */
    void set_SAM_H_PGV09(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets state variable 09h */
    bool get_SAM_H_PGV09() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets state variable 08h */
    void set_SAM_H_PGV08(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets state variable 08h */
    bool get_SAM_H_PGV08() const { return (bool)(raw >> 0 & 0x1); }
        
} SD_RS_SAM_H;



class ECU_SAM_H {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case SAM_H_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case SAM_H_A2_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SAM_H_A3_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case SAM_H_A5_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case SAM_H_A7_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case SD_RS_SAM_H_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to SAM_H_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SAM_H_A1(uint64_t now, uint64_t max_expire_time, SAM_H_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to SAM_H_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SAM_H_A2(uint64_t now, uint64_t max_expire_time, SAM_H_A2* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SAM_H_A3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SAM_H_A3(uint64_t now, uint64_t max_expire_time, SAM_H_A3* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to SAM_H_A5
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SAM_H_A5(uint64_t now, uint64_t max_expire_time, SAM_H_A5* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to SAM_H_A7
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SAM_H_A7(uint64_t now, uint64_t max_expire_time, SAM_H_A7* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to SD_RS_SAM_H
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SD_RS_SAM_H(uint64_t now, uint64_t max_expire_time, SD_RS_SAM_H* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[6];
		uint64_t LAST_FRAME_TIMES[6];
};
#endif // __ECU_SAM_H_H_