
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'AGW'
*/

#ifndef __ECU_AGW_H_
#define __ECU_AGW_H_

#include <stdint.h>
    
#define AGW_A1_CAN_ID 0x0034
#define AGW_A3_CAN_ID 0x0138
#define GPS_A1_CAN_ID 0x0338
#define GPS_A2_CAN_ID 0x0339
#define GPS_A3_CAN_ID 0x033A
#define IPS_A1_CAN_ID 0x01BA
#define SD_RS_AGW_CAN_ID 0x07D6

/** Head unit numeric keypad */
enum class AGW_A3_ZIFFER_HU {
	N_BET = 0, // no key pressed
	T1 = 1, // key 1
	T2 = 2, // button 2
	T3 = 3, // button 3
	T4 = 4, // button 4
	T5 = 5, // key 5
	T6 = 6, // button 6
	T7 = 7, // key 7
	T8 = 8, // key 8
	T9 = 9, // key 9
	T10 = 10, // key 0
};

/** function keys */
enum class AGW_A3_FUNKTIONSTASTEN {
	N_BET = 0, // no key pressed
	F1 = 1, // function key 1
	F2 = 2, // function key 2
	F3 = 3, // function key 3
	F4 = 4, // function key 4
	F5 = 5, // function key 5
	F6 = 6, // function key 6
	F7 = 7, // function key 7
};

/** Active application */
enum class AGW_A3_AKT_SYS {
	IDLE = 0, // no active application
	DATENFUNK = 1, // Data radio active
};

/** GPS fixed */
enum class GPS_A3_GPS_FIX {
	RES = 0, // Reserved
	NAV = 1, // not available
	NO_FIX = 2, // No fix
	FIX_2D = 3, // 2D fixed
	FIX_3D = 4, // 3D fixed
};

/** IPS error */
enum class IPS_A1_IPS_ERROR {
	NO_FEHLER = 0, // no error
	FEHLER_1 = 1, // Error 1
	FEHLER_2 = 2, // Error 2
	FEHLER_3 = 3, // Error 3
	FEHLER_4 = 4, // Error 4
	FEHLER_5 = 5, // Error 5
	FEHLER_6 = 6, // Error 6
	SNV = 7, // Signal not available
};

/** IPS display time */
enum class IPS_A1_IPS_TIME {
	IPSTIME1 = 0, // IPS display time = 2.0s
	IPSTIME2 = 1, // IPS display time = 2.5s
	IPSTIME3 = 2, // IPS display time = 3.0s
	IPSTIME4 = 3, // IPS display time = 3.5s
	IPSTIME5 = 4, // IPS display time = 4.0s
	IPSTIME6 = 5, // IPS display time = 4.5s
	IPSTIME7 = 6, // IPS display time = 5.0s
	IPSTIME8 = 7, // IPS display time = 5.5s
	IPSTIME9 = 8, // IPS display time = 6.0s
	IPSTIME10 = 9, // IPS display time = 6.5s
	IPSTIME11 = 10, // IPS display time = 7.0s
	IPSTIME12 = 11, // IPS display time = 7.5s
	IPSTIME13 = 12, // IPS display time = 8.0s
	IPSTIME14 = 13, // IPS display time = 8.5s
	IPSTIME15 = 14, // Unlimited viewing time
	SNV = 15, // Signal not available
};

/** IPS icon display */
enum class IPS_A1_IPS_INDICATION {
	IPS_AKTIV = 0, // no icon requirement, IPS active
	ICON_1 = 1, // IPS icon 1
	ICON_2 = 2, // IPS icon 2
	ICON_3 = 3, // IPS icon 3
	ICON_4 = 4, // IPS icon 4
	ICON_5 = 5, // IPS icon 5
	ICON_6 = 6, // IPS icon 6
	ICON_7 = 7, // IPS icon 7
	ICON_8 = 8, // IPS icon 8
	ICON_9 = 9, // IPS Icon 9
	ICON_10 = 10, // IPS icon 10
	IPS_NOK = 11, // IPS not available
	IPS_OK = 12, // IPS available again
	IPS_AK = 13, // IPS Acknowledgment
	IPS_DEL = 14, // Delete IPS icon
	SNV = 15, // Signal not available
};

/** IPS icon attributes */
enum class IPS_A1_IPS_ATTRIBUTE {
	DRING_0 = 0, // IPS Requirement: Normal
	DRING_1 = 1, // IPS requirement: priority 1
	DRING_2 = 2, // IPS Requirement: Urgency 2
	DRING_3 = 3, // IPS Requirement: Urgency 3
	SNV = 15, // Signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of AGW_A1 */
	uint32_t get_canid(){ return AGW_A1_CAN_ID; }
    /** Sets HU cannot issue a release for opening */
    void set_WARN_SL_HU(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets HU cannot issue a release for opening */
    bool get_WARN_SL_HU() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets CDC cannot authorize close */
    void set_WARN_SL_CDC(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets CDC cannot authorize close */
    bool get_WARN_SL_CDC() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Open allowed */
    void set_AUF_OK_HU(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Open allowed */
    bool get_AUF_OK_HU() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Close allowed */
    void set_ZU_OK_CDC(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Close allowed */
    bool get_ZU_OK_CDC() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Switch panel locked for CDC */
    void set_EJECT_CDC(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Switch panel locked for CDC */
    bool get_EJECT_CDC() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Switch bar locked for HU */
    void set_EJECT_HU(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Switch bar locked for HU */
    bool get_EJECT_HU() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Voice control system active */
    void set_SBS_AKT(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Voice control system active */
    bool get_SBS_AKT() const { return (bool)(raw >> 55 & 0x1); }
        
} AGW_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of AGW_A3 */
	uint32_t get_canid(){ return AGW_A3_CAN_ID; }
    /** Sets Refusal to enter digits HU */
    void set_CANCEL_HU(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Refusal to enter digits HU */
    bool get_CANCEL_HU() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Star key pressed */
    void set_STERN_HU(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Star key pressed */
    bool get_STERN_HU() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Hash key pressed */
    void set_RAUTE_HU(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Hash key pressed */
    bool get_RAUTE_HU() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Head unit numeric keypad */
    void set_ZIFFER_HU(AGW_A3_ZIFFER_HU value){ raw = (raw & 0xf0ffffffffffffff) | ((uint64_t)value & 0xf) << 56; }

    /** Gets Head unit numeric keypad */
    AGW_A3_ZIFFER_HU get_ZIFFER_HU() const { return (AGW_A3_ZIFFER_HU)(raw >> 56 & 0xf); }
        
    /** Sets function keys */
    void set_FUNKTIONSTASTEN(AGW_A3_FUNKTIONSTASTEN value){ raw = (raw & 0xffc7ffffffffffff) | ((uint64_t)value & 0x7) << 51; }

    /** Gets function keys */
    AGW_A3_FUNKTIONSTASTEN get_FUNKTIONSTASTEN() const { return (AGW_A3_FUNKTIONSTASTEN)(raw >> 51 & 0x7); }
        
    /** Sets Active application */
    void set_AKT_SYS(AGW_A3_AKT_SYS value){ raw = (raw & 0xfff8ffffffffffff) | ((uint64_t)value & 0x7) << 48; }

    /** Gets Active application */
    AGW_A3_AKT_SYS get_AKT_SYS() const { return (AGW_A3_AKT_SYS)(raw >> 48 & 0x7); }
        
} AGW_A3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GPS_A1 */
	uint32_t get_canid(){ return GPS_A1_CAN_ID; }
    /** Sets GPS Latitude (+=North). Conversion formula (To raw from real): y=(x+648000000.0)/0.30 (Unit: ms) */
    void set_LATITUDE(uint32_t value){ raw = (raw & 0x00000000ffffffff) | ((uint64_t)value & 0xffffffff) << 32; }

    /** Gets GPS Latitude (+=North). Conversion formula (To real from raw): y=(0.30x)-648000000.0 (Unit: ms) */
    uint32_t get_LATITUDE() const { return (uint32_t)(raw >> 32 & 0xffffffff); }
        
    /** Sets GPS Longitude (+= East). Conversion formula (To raw from real): y=(x+648000000.0)/0.30 (Unit: ms) */
    void set_LONGITUDE(uint32_t value){ raw = (raw & 0xffffffff00000000) | ((uint64_t)value & 0xffffffff) << 0; }

    /** Gets GPS Longitude (+= East). Conversion formula (To real from raw): y=(0.30x)-648000000.0 (Unit: ms) */
    uint32_t get_LONGITUDE() const { return (uint32_t)(raw >> 0 & 0xffffffff); }
        
} GPS_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GPS_A2 */
	uint32_t get_canid(){ return GPS_A2_CAN_ID; }
    /** Sets UTC years. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: years) */
    void set_UTC_YEARS(uint16_t value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets UTC years. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: years) */
    uint16_t get_UTC_YEARS() const { return (uint16_t)(raw >> 48 & 0xffff); }
        
    /** Sets UTC months. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: months) */
    void set_UTC_MONTHS(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets UTC months. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: months) */
    uint8_t get_UTC_MONTHS() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets UTC days. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: days) */
    void set_UTC_DAYS(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets UTC days. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: days) */
    uint8_t get_UTC_DAYS() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets UTC hours. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: h) */
    void set_UTC_HOURS(uint8_t value){ raw = (raw & 0xffffffff00ffffff) | ((uint64_t)value & 0xff) << 24; }

    /** Gets UTC hours. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: h) */
    uint8_t get_UTC_HOURS() const { return (uint8_t)(raw >> 24 & 0xff); }
        
    /** Sets UTC minutes. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: min) */
    void set_UTC_MINUTES(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets UTC minutes. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: min) */
    uint8_t get_UTC_MINUTES() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets UTC seconds. Conversion formula (To raw from real): y=(x-0.0)/0.01 (Unit: s) */
    void set_UTC_SECONDS(uint16_t value){ raw = (raw & 0xffffffffffff0000) | ((uint64_t)value & 0xffff) << 0; }

    /** Gets UTC seconds. Conversion formula (To real from raw): y=(0.01x)+0.0 (Unit: s) */
    uint16_t get_UTC_SECONDS() const { return (uint16_t)(raw >> 0 & 0xffff); }
        
} GPS_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of GPS_A3 */
	uint32_t get_canid(){ return GPS_A3_CAN_ID; }
    /** Sets GPS speed. Conversion formula (To raw from real): y=(x+32768.0)/1.00 (Unit: cm/s) */
    void set_GPS_SPEED(uint16_t value){ raw = (raw & 0x0000ffffffffffff) | ((uint64_t)value & 0xffff) << 48; }

    /** Gets GPS speed. Conversion formula (To real from raw): y=(1.00x)-32768.0 (Unit: cm/s) */
    uint16_t get_GPS_SPEED() const { return (uint16_t)(raw >> 48 & 0xffff); }
        
    /** Sets GPS Heading (0째 = North). Conversion formula (To raw from real): y=(x-0.0)/1.41 (Unit: 째) */
    void set_GPS_HEADING(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets GPS Heading (0째 = North). Conversion formula (To real from raw): y=(1.41x)+0.0 (Unit: 째) */
    uint8_t get_GPS_HEADING() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets GPS altitude. Conversion formula (To raw from real): y=(x+6400.0)/50.00 (Unit: m) */
    void set_GPS_HEIGHT(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets GPS altitude. Conversion formula (To real from raw): y=(50.00x)-6400.0 (Unit: m) */
    uint8_t get_GPS_HEIGHT() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets GPS fixed */
    void set_GPS_FIX(GPS_A3_GPS_FIX value){ raw = (raw & 0xfffffffff8ffffff) | ((uint64_t)value & 0x7) << 24; }

    /** Gets GPS fixed */
    GPS_A3_GPS_FIX get_GPS_FIX() const { return (GPS_A3_GPS_FIX)(raw >> 24 & 0x7); }
        
    /** Sets GPS position available */
    void set_POS_AVLB(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets GPS position available */
    bool get_POS_AVLB() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets Differential GPS position data available */
    void set_DIFF_POS_AVLB(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets Differential GPS position data available */
    bool get_DIFF_POS_AVLB() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets Dead reckoning available */
    void set_DEAD_RCK(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets Dead reckoning available */
    bool get_DEAD_RCK() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets Inside digitized area (on map) */
    void set_IDG(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets Inside digitized area (on map) */
    bool get_IDG() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets Fully digitized area */
    void set_FDG(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Fully digitized area */
    bool get_FDG() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Matched to digital map */
    void set_MDM(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Matched to digital map */
    bool get_MDM() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Calibrated */
    void set_CALI(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Calibrated */
    bool get_CALI() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Vertical dilution of position. Conversion formula (To raw from real): y=(x-0.0)/0.10 */
    void set_V_DOP(uint8_t value){ raw = (raw & 0xffffffffffff00ff) | ((uint64_t)value & 0xff) << 8; }

    /** Gets Vertical dilution of position. Conversion formula (To real from raw): y=(0.10x)+0.0 */
    uint8_t get_V_DOP() const { return (uint8_t)(raw >> 8 & 0xff); }
        
    /** Sets Horizontal dilution of position. Conversion formula (To raw from real): y=(x-0.0)/0.10 */
    void set_H_DOP(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets Horizontal dilution of position. Conversion formula (To real from raw): y=(0.10x)+0.0 */
    uint8_t get_H_DOP() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} GPS_A3;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of IPS_A1 */
	uint32_t get_canid(){ return IPS_A1_CAN_ID; }
    /** Sets IPS Update Acknowledgment */
    void set_IPS_UPD_ACK(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets IPS Update Acknowledgment */
    bool get_IPS_UPD_ACK() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets IPS error */
    void set_IPS_ERROR(IPS_A1_IPS_ERROR value){ raw = (raw & 0x8fffffffffffffff) | ((uint64_t)value & 0x7) << 60; }

    /** Gets IPS error */
    IPS_A1_IPS_ERROR get_IPS_ERROR() const { return (IPS_A1_IPS_ERROR)(raw >> 60 & 0x7); }
        
    /** Sets IPS Watchdog. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_IPS_WATCH(uint8_t value){ raw = (raw & 0xf0ffffffffffffff) | ((uint64_t)value & 0xf) << 56; }

    /** Gets IPS Watchdog. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint8_t get_IPS_WATCH() const { return (uint8_t)(raw >> 56 & 0xf); }
        
    /** Sets IPS display time */
    void set_IPS_TIME(IPS_A1_IPS_TIME value){ raw = (raw & 0xff0fffffffffffff) | ((uint64_t)value & 0xf) << 52; }

    /** Gets IPS display time */
    IPS_A1_IPS_TIME get_IPS_TIME() const { return (IPS_A1_IPS_TIME)(raw >> 52 & 0xf); }
        
    /** Sets IPS icon display */
    void set_IPS_INDICATION(IPS_A1_IPS_INDICATION value){ raw = (raw & 0xfff0ffffffffffff) | ((uint64_t)value & 0xf) << 48; }

    /** Gets IPS icon display */
    IPS_A1_IPS_INDICATION get_IPS_INDICATION() const { return (IPS_A1_IPS_INDICATION)(raw >> 48 & 0xf); }
        
    /** Sets IPS icon attributes */
    void set_IPS_ATTRIBUTE(IPS_A1_IPS_ATTRIBUTE value){ raw = (raw & 0xfffff0ffffffffff) | ((uint64_t)value & 0xf) << 40; }

    /** Gets IPS icon attributes */
    IPS_A1_IPS_ATTRIBUTE get_IPS_ATTRIBUTE() const { return (IPS_A1_IPS_ATTRIBUTE)(raw >> 40 & 0xf); }
        
} IPS_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SD_RS_AGW */
	uint32_t get_canid(){ return SD_RS_AGW_CAN_ID; }
    /** Sets Identification for > 8 bytes */
    void set_AGW_KENN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Identification for > 8 bytes */
    bool get_AGW_KENN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets error vector 07h */
    void set_AGW_FV07(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets error vector 07h */
    bool get_AGW_FV07() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets error vector 06h */
    void set_AGW_FV06(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets error vector 06h */
    bool get_AGW_FV06() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets error vector 05h */
    void set_AGW_FV05(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets error vector 05h */
    bool get_AGW_FV05() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets error vector 04h */
    void set_AGW_FV04(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets error vector 04h */
    bool get_AGW_FV04() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets error vector 03h */
    void set_AGW_FV03(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets error vector 03h */
    bool get_AGW_FV03() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets error vector 02h */
    void set_AGW_FV02(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets error vector 02h */
    bool get_AGW_FV02() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets error vector 01h */
    void set_AGW_FV01(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets error vector 01h */
    bool get_AGW_FV01() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets error vector 0Fh */
    void set_AGW_FV0F(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets error vector 0Fh */
    bool get_AGW_FV0F() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets error vector 0Eh */
    void set_AGW_FV0E(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets error vector 0Eh */
    bool get_AGW_FV0E() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets error vector 0Dh */
    void set_AGW_FV0D(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets error vector 0Dh */
    bool get_AGW_FV0D() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets error vector 0Ch */
    void set_AGW_FV0C(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets error vector 0Ch */
    bool get_AGW_FV0C() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets error vector 0Bh */
    void set_AGW_FV0B(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets error vector 0Bh */
    bool get_AGW_FV0B() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets error vector 0Ah */
    void set_AGW_FV0A(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets error vector 0Ah */
    bool get_AGW_FV0A() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets error vector 09h */
    void set_AGW_FV09(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets error vector 09h */
    bool get_AGW_FV09() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets error vector 08h */
    void set_AGW_FV08(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets error vector 08h */
    bool get_AGW_FV08() const { return (bool)(raw >> 48 & 0x1); }
        
    /** Sets error vector 17h */
    void set_AGW_FV17(bool value){ raw = (raw & 0xffff7fffffffffff) | ((uint64_t)value & 0x1) << 47; }

    /** Gets error vector 17h */
    bool get_AGW_FV17() const { return (bool)(raw >> 47 & 0x1); }
        
    /** Sets error vector 16h */
    void set_AGW_FV16(bool value){ raw = (raw & 0xffffbfffffffffff) | ((uint64_t)value & 0x1) << 46; }

    /** Gets error vector 16h */
    bool get_AGW_FV16() const { return (bool)(raw >> 46 & 0x1); }
        
    /** Sets error vector 15h */
    void set_AGW_FV15(bool value){ raw = (raw & 0xffffdfffffffffff) | ((uint64_t)value & 0x1) << 45; }

    /** Gets error vector 15h */
    bool get_AGW_FV15() const { return (bool)(raw >> 45 & 0x1); }
        
    /** Sets error vector 14h */
    void set_AGW_FV14(bool value){ raw = (raw & 0xffffefffffffffff) | ((uint64_t)value & 0x1) << 44; }

    /** Gets error vector 14h */
    bool get_AGW_FV14() const { return (bool)(raw >> 44 & 0x1); }
        
    /** Sets error vector 13h */
    void set_AGW_FV13(bool value){ raw = (raw & 0xfffff7ffffffffff) | ((uint64_t)value & 0x1) << 43; }

    /** Gets error vector 13h */
    bool get_AGW_FV13() const { return (bool)(raw >> 43 & 0x1); }
        
    /** Sets error vector 12h */
    void set_AGW_FV12(bool value){ raw = (raw & 0xfffffbffffffffff) | ((uint64_t)value & 0x1) << 42; }

    /** Gets error vector 12h */
    bool get_AGW_FV12() const { return (bool)(raw >> 42 & 0x1); }
        
    /** Sets error vector 11h */
    void set_AGW_FV11(bool value){ raw = (raw & 0xfffffdffffffffff) | ((uint64_t)value & 0x1) << 41; }

    /** Gets error vector 11h */
    bool get_AGW_FV11() const { return (bool)(raw >> 41 & 0x1); }
        
    /** Sets error vector 10h */
    void set_AGW_FV10(bool value){ raw = (raw & 0xfffffeffffffffff) | ((uint64_t)value & 0x1) << 40; }

    /** Gets error vector 10h */
    bool get_AGW_FV10() const { return (bool)(raw >> 40 & 0x1); }
        
    /** Sets error vector 1Fh */
    void set_AGW_FV1F(bool value){ raw = (raw & 0xffffff7fffffffff) | ((uint64_t)value & 0x1) << 39; }

    /** Gets error vector 1Fh */
    bool get_AGW_FV1F() const { return (bool)(raw >> 39 & 0x1); }
        
    /** Sets error vector 1Eh */
    void set_AGW_FV1E(bool value){ raw = (raw & 0xffffffbfffffffff) | ((uint64_t)value & 0x1) << 38; }

    /** Gets error vector 1Eh */
    bool get_AGW_FV1E() const { return (bool)(raw >> 38 & 0x1); }
        
    /** Sets error vector 1Dh */
    void set_AGW_FV1D(bool value){ raw = (raw & 0xffffffdfffffffff) | ((uint64_t)value & 0x1) << 37; }

    /** Gets error vector 1Dh */
    bool get_AGW_FV1D() const { return (bool)(raw >> 37 & 0x1); }
        
    /** Sets Error vector 1Ch */
    void set_AGW_FV1C(bool value){ raw = (raw & 0xffffffefffffffff) | ((uint64_t)value & 0x1) << 36; }

    /** Gets Error vector 1Ch */
    bool get_AGW_FV1C() const { return (bool)(raw >> 36 & 0x1); }
        
    /** Sets error vector 1Bh */
    void set_AGW_FV1B(bool value){ raw = (raw & 0xfffffff7ffffffff) | ((uint64_t)value & 0x1) << 35; }

    /** Gets error vector 1Bh */
    bool get_AGW_FV1B() const { return (bool)(raw >> 35 & 0x1); }
        
    /** Sets Error vector 1Ah */
    void set_AGW_FV1A(bool value){ raw = (raw & 0xfffffffbffffffff) | ((uint64_t)value & 0x1) << 34; }

    /** Gets Error vector 1Ah */
    bool get_AGW_FV1A() const { return (bool)(raw >> 34 & 0x1); }
        
    /** Sets error vector 19h */
    void set_AGW_FV19(bool value){ raw = (raw & 0xfffffffdffffffff) | ((uint64_t)value & 0x1) << 33; }

    /** Gets error vector 19h */
    bool get_AGW_FV19() const { return (bool)(raw >> 33 & 0x1); }
        
    /** Sets error vector 18h */
    void set_AGW_FV18(bool value){ raw = (raw & 0xfffffffeffffffff) | ((uint64_t)value & 0x1) << 32; }

    /** Gets error vector 18h */
    bool get_AGW_FV18() const { return (bool)(raw >> 32 & 0x1); }
        
    /** Sets error vector 27h */
    void set_AGW_FV27(bool value){ raw = (raw & 0xffffffff7fffffff) | ((uint64_t)value & 0x1) << 31; }

    /** Gets error vector 27h */
    bool get_AGW_FV27() const { return (bool)(raw >> 31 & 0x1); }
        
    /** Sets error vector 26h */
    void set_AGW_FV26(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets error vector 26h */
    bool get_AGW_FV26() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets error vector 25h */
    void set_AGW_FV25(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets error vector 25h */
    bool get_AGW_FV25() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets error vector 24h */
    void set_AGW_FV24(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets error vector 24h */
    bool get_AGW_FV24() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets error vector 23h */
    void set_AGW_FV23(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets error vector 23h */
    bool get_AGW_FV23() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets error vector 22h */
    void set_AGW_FV22(bool value){ raw = (raw & 0xfffffffffbffffff) | ((uint64_t)value & 0x1) << 26; }

    /** Gets error vector 22h */
    bool get_AGW_FV22() const { return (bool)(raw >> 26 & 0x1); }
        
    /** Sets error vector 21h */
    void set_AGW_FV21(bool value){ raw = (raw & 0xfffffffffdffffff) | ((uint64_t)value & 0x1) << 25; }

    /** Gets error vector 21h */
    bool get_AGW_FV21() const { return (bool)(raw >> 25 & 0x1); }
        
    /** Sets error vector 20h */
    void set_AGW_FV20(bool value){ raw = (raw & 0xfffffffffeffffff) | ((uint64_t)value & 0x1) << 24; }

    /** Gets error vector 20h */
    bool get_AGW_FV20() const { return (bool)(raw >> 24 & 0x1); }
        
    /** Sets error vector 2Fh */
    void set_AGW_FV2F(bool value){ raw = (raw & 0xffffffffff7fffff) | ((uint64_t)value & 0x1) << 23; }

    /** Gets error vector 2Fh */
    bool get_AGW_FV2F() const { return (bool)(raw >> 23 & 0x1); }
        
    /** Sets error vector 2Eh */
    void set_AGW_FV2E(bool value){ raw = (raw & 0xffffffffffbfffff) | ((uint64_t)value & 0x1) << 22; }

    /** Gets error vector 2Eh */
    bool get_AGW_FV2E() const { return (bool)(raw >> 22 & 0x1); }
        
    /** Sets error vector 2Dh */
    void set_AGW_FV2D(bool value){ raw = (raw & 0xffffffffffdfffff) | ((uint64_t)value & 0x1) << 21; }

    /** Gets error vector 2Dh */
    bool get_AGW_FV2D() const { return (bool)(raw >> 21 & 0x1); }
        
    /** Sets error vector 2Ch */
    void set_AGW_FV2C(bool value){ raw = (raw & 0xffffffffffefffff) | ((uint64_t)value & 0x1) << 20; }

    /** Gets error vector 2Ch */
    bool get_AGW_FV2C() const { return (bool)(raw >> 20 & 0x1); }
        
    /** Sets error vector 2Bh */
    void set_AGW_FV2B(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets error vector 2Bh */
    bool get_AGW_FV2B() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Error vector 2Ah */
    void set_AGW_FV2A(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Error vector 2Ah */
    bool get_AGW_FV2A() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets error vector 29h */
    void set_AGW_FV29(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets error vector 29h */
    bool get_AGW_FV29() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets error vector 28h */
    void set_AGW_FV28(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets error vector 28h */
    bool get_AGW_FV28() const { return (bool)(raw >> 16 & 0x1); }
        
    /** Sets error vector 37h */
    void set_AGW_FV37(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets error vector 37h */
    bool get_AGW_FV37() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets error vector 36h */
    void set_AGW_FV36(bool value){ raw = (raw & 0xffffffffffffbfff) | ((uint64_t)value & 0x1) << 14; }

    /** Gets error vector 36h */
    bool get_AGW_FV36() const { return (bool)(raw >> 14 & 0x1); }
        
    /** Sets error vector 35h */
    void set_AGW_FV35(bool value){ raw = (raw & 0xffffffffffffdfff) | ((uint64_t)value & 0x1) << 13; }

    /** Gets error vector 35h */
    bool get_AGW_FV35() const { return (bool)(raw >> 13 & 0x1); }
        
    /** Sets error vector 34h */
    void set_AGW_FV34(bool value){ raw = (raw & 0xffffffffffffefff) | ((uint64_t)value & 0x1) << 12; }

    /** Gets error vector 34h */
    bool get_AGW_FV34() const { return (bool)(raw >> 12 & 0x1); }
        
    /** Sets error vector 33h */
    void set_AGW_FV33(bool value){ raw = (raw & 0xfffffffffffff7ff) | ((uint64_t)value & 0x1) << 11; }

    /** Gets error vector 33h */
    bool get_AGW_FV33() const { return (bool)(raw >> 11 & 0x1); }
        
    /** Sets error vector 32h */
    void set_AGW_FV32(bool value){ raw = (raw & 0xfffffffffffffbff) | ((uint64_t)value & 0x1) << 10; }

    /** Gets error vector 32h */
    bool get_AGW_FV32() const { return (bool)(raw >> 10 & 0x1); }
        
    /** Sets error vector 31h */
    void set_AGW_FV31(bool value){ raw = (raw & 0xfffffffffffffdff) | ((uint64_t)value & 0x1) << 9; }

    /** Gets error vector 31h */
    bool get_AGW_FV31() const { return (bool)(raw >> 9 & 0x1); }
        
    /** Sets error vector 30h */
    void set_AGW_FV30(bool value){ raw = (raw & 0xfffffffffffffeff) | ((uint64_t)value & 0x1) << 8; }

    /** Gets error vector 30h */
    bool get_AGW_FV30() const { return (bool)(raw >> 8 & 0x1); }
        
    /** Sets state variable 01h */
    void set_AGW_PGV01(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets state variable 01h */
    bool get_AGW_PGV01() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets error vector 3Eh */
    void set_AGW_FV3E(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets error vector 3Eh */
    bool get_AGW_FV3E() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets error vector 3Dh */
    void set_AGW_FV3D(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets error vector 3Dh */
    bool get_AGW_FV3D() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets error vector 3Ch */
    void set_AGW_FV3C(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets error vector 3Ch */
    bool get_AGW_FV3C() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets error vector 3Bh */
    void set_AGW_FV3B(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets error vector 3Bh */
    bool get_AGW_FV3B() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets Error vector 3Ah */
    void set_AGW_FV3A(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets Error vector 3Ah */
    bool get_AGW_FV3A() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets error vector 39h */
    void set_AGW_FV39(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets error vector 39h */
    bool get_AGW_FV39() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets error vector 38h */
    void set_AGW_FV38(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets error vector 38h */
    bool get_AGW_FV38() const { return (bool)(raw >> 0 & 0x1); }
        
} SD_RS_AGW;



class ECU_AGW {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case AGW_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case AGW_A3_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case GPS_A1_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case GPS_A2_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                case GPS_A3_CAN_ID:
                    LAST_FRAME_TIMES[4] = timestamp_now;
                    FRAME_DATA[4] = value;
                    return true;
                case IPS_A1_CAN_ID:
                    LAST_FRAME_TIMES[5] = timestamp_now;
                    FRAME_DATA[5] = value;
                    return true;
                case SD_RS_AGW_CAN_ID:
                    LAST_FRAME_TIMES[6] = timestamp_now;
                    FRAME_DATA[6] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to AGW_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_AGW_A1(uint64_t now, uint64_t max_expire_time, AGW_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to AGW_A3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_AGW_A3(uint64_t now, uint64_t max_expire_time, AGW_A3* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to GPS_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GPS_A1(uint64_t now, uint64_t max_expire_time, GPS_A1* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to GPS_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GPS_A2(uint64_t now, uint64_t max_expire_time, GPS_A2* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
        /** Sets data in pointer to GPS_A3
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_GPS_A3(uint64_t now, uint64_t max_expire_time, GPS_A3* dest) const {
            if (LAST_FRAME_TIMES[4] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[4] && now - LAST_FRAME_TIMES[4] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[4];
                return true;
            }
        }
            
        /** Sets data in pointer to IPS_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_IPS_A1(uint64_t now, uint64_t max_expire_time, IPS_A1* dest) const {
            if (LAST_FRAME_TIMES[5] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[5] && now - LAST_FRAME_TIMES[5] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[5];
                return true;
            }
        }
            
        /** Sets data in pointer to SD_RS_AGW
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SD_RS_AGW(uint64_t now, uint64_t max_expire_time, SD_RS_AGW* dest) const {
            if (LAST_FRAME_TIMES[6] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[6] && now - LAST_FRAME_TIMES[6] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[6];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[7];
		uint64_t LAST_FRAME_TIMES[7];
};
#endif // __ECU_AGW_H_