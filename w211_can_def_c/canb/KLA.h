
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'KLA'
*/

#ifndef __ECU_KLA_H_
#define __ECU_KLA_H_

#include <stdint.h>
    
#define KLA_A1_CAN_ID 0x0030
#define KLA_A2_CAN_ID 0x0250
#define KLA_A5_CAN_ID 0x00F1
#define SD_RS_KLA_CAN_ID 0x07D1

/** Ventilation flap position up */
enum class KLA_A1_LKO_VORN {
	MITTE = 0, // middle position
	AUF = 1, // position up
	ZU = 2, // Opinion on
	SNV = 3, // Signal invalid
};

/** Center ventilation flap position */
enum class KLA_A1_LKM_VORN {
	MITTE = 0, // middle position
	AUF = 1, // position up
	ZU = 2, // Opinion on
	SNV = 3, // Signal invalid
};

/** Lower ventilation flap position */
enum class KLA_A1_LKU_VORN {
	MITTE = 0, // middle position
	AUF = 1, // position up
	ZU = 2, // Opinion on
	SNV = 3, // Signal invalid
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KLA_A1 */
	uint32_t get_canid(){ return KLA_A1_CAN_ID; }
    /** Sets Switch on the heated rear window */
    void set_HHS_EIN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Switch on the heated rear window */
    bool get_HHS_EIN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets EC mode active */
    void set_EC_AKT(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets EC mode active */
    bool get_EC_AKT() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Turn on indoor sensor fan */
    void set_IFG_EIN(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Turn on indoor sensor fan */
    bool get_IFG_EIN() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Switch on auxiliary water pump */
    void set_ZWP_EIN(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Switch on auxiliary water pump */
    bool get_ZWP_EIN() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Activation of auxiliary heater permitted */
    void set_ZH_EIN_OK(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Activation of auxiliary heater permitted */
    bool get_ZH_EIN_OK() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets No-load speed increase to increase cooling capacity */
    void set_LL_DZA(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets No-load speed increase to increase cooling capacity */
    bool get_LL_DZA() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Heat auxiliary heater */
    void set_HEIZEN(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Heat auxiliary heater */
    bool get_HEIZEN() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Ventilate the auxiliary heating */
    void set_LUEFTEN(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Ventilate the auxiliary heating */
    bool get_LUEFTEN() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Motor fan set speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: %) */
    void set_NLFTS(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Motor fan set speed. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: %) */
    uint8_t get_NLFTS() const { return (uint8_t)(raw >> 48 & 0xff); }
        
    /** Sets Torque absorption refrigeration compressor. Conversion formula (To raw from real): y=(x-0.0)/3.00 (Unit: Nm) */
    void set_M_KOMP(uint8_t value){ raw = (raw & 0xffff00ffffffffff) | ((uint64_t)value & 0xff) << 40; }

    /** Gets Torque absorption refrigeration compressor. Conversion formula (To real from raw): y=(3.00x)+0.0 (Unit: Nm) */
    uint8_t get_M_KOMP() const { return (uint8_t)(raw >> 40 & 0xff); }
        
    /** Sets Refrigeration compressor control signal. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: %) */
    void set_KOMP_STELL(uint8_t value){ raw = (raw & 0xffffff00ffffffff) | ((uint64_t)value & 0xff) << 32; }

    /** Gets Refrigeration compressor control signal. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: %) */
    uint8_t get_KOMP_STELL() const { return (uint8_t)(raw >> 32 & 0xff); }
        
    /** Sets Defrost mode active */
    void set_DEFROST_AKT(bool value){ raw = (raw & 0xffffffffbfffffff) | ((uint64_t)value & 0x1) << 30; }

    /** Gets Defrost mode active */
    bool get_DEFROST_AKT() const { return (bool)(raw >> 30 & 0x1); }
        
    /** Sets Residual heat mode active */
    void set_REST_AKT(bool value){ raw = (raw & 0xffffffffdfffffff) | ((uint64_t)value & 0x1) << 29; }

    /** Gets Residual heat mode active */
    bool get_REST_AKT() const { return (bool)(raw >> 29 & 0x1); }
        
    /** Sets Close the radiator shutter */
    void set_KJAL_ZU(bool value){ raw = (raw & 0xffffffffefffffff) | ((uint64_t)value & 0x1) << 28; }

    /** Gets Close the radiator shutter */
    bool get_KJAL_ZU() const { return (bool)(raw >> 28 & 0x1); }
        
    /** Sets Close the heat exchanger shut-off valve */
    void set_ABVENT_W_ZU(bool value){ raw = (raw & 0xfffffffff7ffffff) | ((uint64_t)value & 0x1) << 27; }

    /** Gets Close the heat exchanger shut-off valve */
    bool get_ABVENT_W_ZU() const { return (bool)(raw >> 27 & 0x1); }
        
    /** Sets Demand for additional heat output. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Stufen) */
    void set_ZH_ANF(uint8_t value){ raw = (raw & 0xfffffffff8ffffff) | ((uint64_t)value & 0x7) << 24; }

    /** Gets Demand for additional heat output. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Stufen) */
    uint8_t get_ZH_ANF() const { return (uint8_t)(raw >> 24 & 0x7); }
        
    /** Sets fan power. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: %) */
    void set_GEB_LSTG(uint8_t value){ raw = (raw & 0xffffffffff00ffff) | ((uint64_t)value & 0xff) << 16; }

    /** Gets fan power. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: %) */
    uint8_t get_GEB_LSTG() const { return (uint8_t)(raw >> 16 & 0xff); }
        
    /** Sets Recirculation active */
    void set_UL_AKT_KLA(bool value){ raw = (raw & 0xffffffffffff7fff) | ((uint64_t)value & 0x1) << 15; }

    /** Gets Recirculation active */
    bool get_UL_AKT_KLA() const { return (bool)(raw >> 15 & 0x1); }
        
    /** Sets Ventilation flap position up */
    void set_LKO_VORN(KLA_A1_LKO_VORN value){ raw = (raw & 0xffffffffffffcfff) | ((uint64_t)value & 0x3) << 12; }

    /** Gets Ventilation flap position up */
    KLA_A1_LKO_VORN get_LKO_VORN() const { return (KLA_A1_LKO_VORN)(raw >> 12 & 0x3); }
        
    /** Sets Center ventilation flap position */
    void set_LKM_VORN(KLA_A1_LKM_VORN value){ raw = (raw & 0xfffffffffffff3ff) | ((uint64_t)value & 0x3) << 10; }

    /** Gets Center ventilation flap position */
    KLA_A1_LKM_VORN get_LKM_VORN() const { return (KLA_A1_LKM_VORN)(raw >> 10 & 0x3); }
        
    /** Sets Lower ventilation flap position */
    void set_LKU_VORN(KLA_A1_LKU_VORN value){ raw = (raw & 0xfffffffffffffcff) | ((uint64_t)value & 0x3) << 8; }

    /** Gets Lower ventilation flap position */
    KLA_A1_LKU_VORN get_LKU_VORN() const { return (KLA_A1_LKU_VORN)(raw >> 8 & 0x3); }
        
    /** Sets internal temperature. Conversion formula (To raw from real): y=(x-0.0)/0.25 (Unit: °C) */
    void set_T_INNEN_KLA(uint8_t value){ raw = (raw & 0xffffffffffffff00) | ((uint64_t)value & 0xff) << 0; }

    /** Gets internal temperature. Conversion formula (To real from raw): y=(0.25x)+0.0 (Unit: °C) */
    uint8_t get_T_INNEN_KLA() const { return (uint8_t)(raw >> 0 & 0xff); }
        
} KLA_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KLA_A2 */
	uint32_t get_canid(){ return KLA_A2_CAN_ID; }
    /** Sets Open/close rear right window */
    void set_FHR_KLA(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Open/close rear right window */
    bool get_FHR_KLA() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets Open/close rear left window */
    void set_FHL_KLA(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets Open/close rear left window */
    bool get_FHL_KLA() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Open/close front right window */
    void set_FVR_KLA(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Open/close front right window */
    bool get_FVR_KLA() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Open/close front left window */
    void set_FVL_KLA(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets Open/close front left window */
    bool get_FVL_KLA() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets Open/close SHD/top */
    void set_SHD_KLA(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Open/close SHD/top */
    bool get_SHD_KLA() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets direction comfort operation: open [0], close [1] */
    void set_KB_RI_KLA(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets direction comfort operation: open [0], close [1] */
    bool get_KB_RI_KLA() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets Comfort control Automatic operation [1] Manual [0] */
    void set_KB_MOD_KLA(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets Comfort control Automatic operation [1] Manual [0] */
    bool get_KB_MOD_KLA() const { return (bool)(raw >> 57 & 0x1); }
        
} KLA_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of KLA_A5 */
	uint32_t get_canid(){ return KLA_A5_CAN_ID; }
    /** Sets Heating power requirement. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: %) */
    void set_HZL_ANF(uint8_t value){ raw = (raw & 0x00ffffffffffffff) | ((uint64_t)value & 0xff) << 56; }

    /** Gets Heating power requirement. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: %) */
    uint8_t get_HZL_ANF() const { return (uint8_t)(raw >> 56 & 0xff); }
        
    /** Sets Outside air temperature for thermal management. Conversion formula (To raw from real): y=(x+40.0)/0.50 (Unit: °C) */
    void set_T_AUSSEN_WM(uint8_t value){ raw = (raw & 0xff00ffffffffffff) | ((uint64_t)value & 0xff) << 48; }

    /** Gets Outside air temperature for thermal management. Conversion formula (To real from raw): y=(0.50x)-40.0 (Unit: °C) */
    uint8_t get_T_AUSSEN_WM() const { return (uint8_t)(raw >> 48 & 0xff); }
        
} KLA_A5;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SD_RS_KLA */
	uint32_t get_canid(){ return SD_RS_KLA_CAN_ID; }
    /** Sets Identification for > 8 bytes */
    void set_KLA_KENN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Identification for > 8 bytes */
    bool get_KLA_KENN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets state variable 07h */
    void set_KLA_PGV07(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets state variable 07h */
    bool get_KLA_PGV07() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets state variable 06h */
    void set_KLA_PGV06(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets state variable 06h */
    bool get_KLA_PGV06() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets state variable 05h */
    void set_KLA_PGV05(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets state variable 05h */
    bool get_KLA_PGV05() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets state variable 04h */
    void set_KLA_PGV04(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets state variable 04h */
    bool get_KLA_PGV04() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets state variable 03h */
    void set_KLA_PGV03(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets state variable 03h */
    bool get_KLA_PGV03() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets state variable 02h */
    void set_KLA_PGV02(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets state variable 02h */
    bool get_KLA_PGV02() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets state variable 01h */
    void set_KLA_PGV01(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets state variable 01h */
    bool get_KLA_PGV01() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Error message 01h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_KLA_FM01(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets Error message 01h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_KLA_FM01() const { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Error message 02h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_KLA_FM02(uint16_t value){ raw = (raw & 0xffffff0000ffffff) | ((uint64_t)value & 0xffff) << 24; }

    /** Gets Error message 02h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_KLA_FM02() const { return (uint16_t)(raw >> 24 & 0xffff); }
        
    /** Sets Error message 03h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_KLA_FM03(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets Error message 03h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_KLA_FM03() const { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets state variable 0Fh */
    void set_KLA_PGV0F(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets state variable 0Fh */
    bool get_KLA_PGV0F() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets state variable 0Eh */
    void set_KLA_PGV0E(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets state variable 0Eh */
    bool get_KLA_PGV0E() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets State variable 0Dh */
    void set_KLA_PGV0D(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets State variable 0Dh */
    bool get_KLA_PGV0D() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets state variable 0Ch */
    void set_KLA_PGV0C(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets state variable 0Ch */
    bool get_KLA_PGV0C() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets state variable 0Bh */
    void set_KLA_PGV0B(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets state variable 0Bh */
    bool get_KLA_PGV0B() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets State variable 0Ah */
    void set_KLA_PGV0A(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets State variable 0Ah */
    bool get_KLA_PGV0A() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets state variable 09h */
    void set_KLA_PGV09(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets state variable 09h */
    bool get_KLA_PGV09() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets state variable 08h */
    void set_KLA_PGV08(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets state variable 08h */
    bool get_KLA_PGV08() const { return (bool)(raw >> 0 & 0x1); }
        
} SD_RS_KLA;



class ECU_KLA {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case KLA_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case KLA_A2_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case KLA_A5_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                case SD_RS_KLA_CAN_ID:
                    LAST_FRAME_TIMES[3] = timestamp_now;
                    FRAME_DATA[3] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to KLA_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_A1(uint64_t now, uint64_t max_expire_time, KLA_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to KLA_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_A2(uint64_t now, uint64_t max_expire_time, KLA_A2* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to KLA_A5
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_KLA_A5(uint64_t now, uint64_t max_expire_time, KLA_A5* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
        /** Sets data in pointer to SD_RS_KLA
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SD_RS_KLA(uint64_t now, uint64_t max_expire_time, SD_RS_KLA* dest) const {
            if (LAST_FRAME_TIMES[3] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[3] && now - LAST_FRAME_TIMES[3] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[3];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[4];
		uint64_t LAST_FRAME_TIMES[4];
};
#endif // __ECU_KLA_H_