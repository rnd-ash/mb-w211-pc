
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ARMADA'
*/

#ifndef __ECU_ARMADA_H_
#define __ECU_ARMADA_H_

#include <stdint.h>
    
#define ARMADA_A1_CAN_ID 0x0012
#define ARMADA_A2_CAN_ID 0x0040
#define SD_RS_ARMADA_CAN_ID 0x07DC

/** Child seat status */
enum class ARMADA_A1_KISI_ST {
	KEIN_KISI = 0, // No child seat detected
	KISI_V_ERK = 1, // Child seat detected (installed forward)
	KISI_R_ERK = 2, // Child seat detected (rear mounted)
	KISI_FPOS = 4, // Child seat wrong position
	KISI_FEHLER = 6, // Child seat detection error
	SNV = 7, // Signal not available
};

/** Passenger seat belt buckle */
enum class ARMADA_A1_GS_BF {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
};

/** Passenger detection fast */
enum class ARMADA_A1_PSG_DETEC_FAST {
	SNA = 0, // Signal not available
	PSG_PRESENT = 1, // Passenger present
	FAULT = 2, // Fault
	PSG_ABSENT = 3, // Passenger absent
};

/** Occupant classification passenger */
enum class ARMADA_A1_OC_BF {
	OC_0 = 0, // Occupant Classification 0-10kg
	OC_1 = 1, // Occupant classification 11-30kg
	OC_2 = 2, // Occupant Classification 31-60kg
	OC_3 = 3, // Occupant classification 61-90kg
	OC_4 = 4, // Occupant classification >90kg
	OC_FEHLER = 6, // Error OC
	SNV = 7, // Signal not available
};

/** Seat belt buckle driver */
enum class ARMADA_A1_GS_F {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
};

/** Occupant classification driver */
enum class ARMADA_A1_OC_F {
	OC_0 = 0, // Occupant Classification 0-10kg
	OC_1 = 1, // Occupant classification 11-30kg
	OC_2 = 2, // Occupant Classification 31-60kg
	OC_3 = 3, // Occupant classification 61-90kg
	OC_4 = 4, // Occupant classification >90kg
	OC_FEHLER = 6, // Error OC
	SNV = 7, // Signal not available
};

/** Belt buckle SHM (reserved) */
enum class ARMADA_A1_GS_SHM {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
};

/** Passenger Isofix switch (only Roadster) */
enum class ARMADA_A1_ISOFIX_BF {
	KEIN_KISI = 0, // No KISI
	KISI_ERK = 1, // KISI detected
	KISI_FEHLER = 2, // KISI error
	SNV = 3, // Signal not available
};

/** Seat belt buckle SHR (reserved) */
enum class ARMADA_A1_GS_SHR {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
};

/** Seat belt buckle SHL (reserved) */
enum class ARMADA_A1_GS_SHL {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
};



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ARMADA_A1 */
	uint32_t get_canid(){ return ARMADA_A1_CAN_ID; }
    /** Sets Switch on AKSE lamp */
    void set_AKSE_EIN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Switch on AKSE lamp */
    bool get_AKSE_EIN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets AKSE light flashing */
    void set_AKSE_BLINK(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets AKSE light flashing */
    bool get_AKSE_BLINK() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Check passenger seat contact */
    void set_KONTAKT_BF(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Check passenger seat contact */
    bool get_KONTAKT_BF() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets Turn on SRS indicator lamp, on [1], off [0] */
    void set_SRS_KL(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets Turn on SRS indicator lamp, on [1], off [0] */
    bool get_SRS_KL() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets SRS indicator lamp flashing on [1], off [0] */
    void set_SRS_BLINK(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets SRS indicator lamp flashing on [1], off [0] */
    bool get_SRS_BLINK() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets SRS message 3 "workshop", on [1], off [0] */
    void set_SRS_WERK_FT3(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets SRS message 3 "workshop", on [1], off [0] */
    bool get_SRS_WERK_FT3() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets SRS message "workshop", on [1], off [0] */
    void set_SRS_WERK_FT1(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets SRS message "workshop", on [1], off [0] */
    bool get_SRS_WERK_FT1() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Check seat latches front passenger */
    void set_RAST_SITZ_BF(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets Check seat latches front passenger */
    bool get_RAST_SITZ_BF() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets Child seat status */
    void set_KISI_ST(ARMADA_A1_KISI_ST value){ raw = (raw & 0xfff8ffffffffffff) | ((uint64_t)value & 0x7) << 48; }

    /** Gets Child seat status */
    ARMADA_A1_KISI_ST get_KISI_ST() const { return (ARMADA_A1_KISI_ST)(raw >> 48 & 0x7); }
        
    /** Sets Passenger seat belt buckle */
    void set_GS_BF(ARMADA_A1_GS_BF value){ raw = (raw & 0xffff3fffffffffff) | ((uint64_t)value & 0x3) << 46; }

    /** Gets Passenger seat belt buckle */
    ARMADA_A1_GS_BF get_GS_BF() const { return (ARMADA_A1_GS_BF)(raw >> 46 & 0x3); }
        
    /** Sets Passenger detection fast */
    void set_PSG_DETEC_FAST(ARMADA_A1_PSG_DETEC_FAST value){ raw = (raw & 0xffffe7ffffffffff) | ((uint64_t)value & 0x3) << 43; }

    /** Gets Passenger detection fast */
    ARMADA_A1_PSG_DETEC_FAST get_PSG_DETEC_FAST() const { return (ARMADA_A1_PSG_DETEC_FAST)(raw >> 43 & 0x3); }
        
    /** Sets Occupant classification passenger */
    void set_OC_BF(ARMADA_A1_OC_BF value){ raw = (raw & 0xfffff8ffffffffff) | ((uint64_t)value & 0x7) << 40; }

    /** Gets Occupant classification passenger */
    ARMADA_A1_OC_BF get_OC_BF() const { return (ARMADA_A1_OC_BF)(raw >> 40 & 0x7); }
        
    /** Sets Seat belt buckle driver */
    void set_GS_F(ARMADA_A1_GS_F value){ raw = (raw & 0xffffff3fffffffff) | ((uint64_t)value & 0x3) << 38; }

    /** Gets Seat belt buckle driver */
    ARMADA_A1_GS_F get_GS_F() const { return (ARMADA_A1_GS_F)(raw >> 38 & 0x3); }
        
    /** Sets Occupant classification driver */
    void set_OC_F(ARMADA_A1_OC_F value){ raw = (raw & 0xfffffff8ffffffff) | ((uint64_t)value & 0x7) << 32; }

    /** Gets Occupant classification driver */
    ARMADA_A1_OC_F get_OC_F() const { return (ARMADA_A1_OC_F)(raw >> 32 & 0x7); }
        
    /** Sets Belt buckle SHM (reserved) */
    void set_GS_SHM(ARMADA_A1_GS_SHM value){ raw = (raw & 0xffffffff3fffffff) | ((uint64_t)value & 0x3) << 30; }

    /** Gets Belt buckle SHM (reserved) */
    ARMADA_A1_GS_SHM get_GS_SHM() const { return (ARMADA_A1_GS_SHM)(raw >> 30 & 0x3); }
        
    /** Sets Passenger Isofix switch (only Roadster) */
    void set_ISOFIX_BF(ARMADA_A1_ISOFIX_BF value){ raw = (raw & 0xffffffffcfffffff) | ((uint64_t)value & 0x3) << 28; }

    /** Gets Passenger Isofix switch (only Roadster) */
    ARMADA_A1_ISOFIX_BF get_ISOFIX_BF() const { return (ARMADA_A1_ISOFIX_BF)(raw >> 28 & 0x3); }
        
    /** Sets Seat belt buckle SHR (reserved) */
    void set_GS_SHR(ARMADA_A1_GS_SHR value){ raw = (raw & 0xfffffffff3ffffff) | ((uint64_t)value & 0x3) << 26; }

    /** Gets Seat belt buckle SHR (reserved) */
    ARMADA_A1_GS_SHR get_GS_SHR() const { return (ARMADA_A1_GS_SHR)(raw >> 26 & 0x3); }
        
    /** Sets Seat belt buckle SHL (reserved) */
    void set_GS_SHL(ARMADA_A1_GS_SHL value){ raw = (raw & 0xfffffffffcffffff) | ((uint64_t)value & 0x3) << 24; }

    /** Gets Seat belt buckle SHL (reserved) */
    ARMADA_A1_GS_SHL get_GS_SHL() const { return (ARMADA_A1_GS_SHL)(raw >> 24 & 0x3); }
        
    /** Sets Check rear seat catch */
    void set_RAST_SHR(bool value){ raw = (raw & 0xfffffffffff7ffff) | ((uint64_t)value & 0x1) << 19; }

    /** Gets Check rear seat catch */
    bool get_RAST_SHR() const { return (bool)(raw >> 19 & 0x1); }
        
    /** Sets Check seat catch HL */
    void set_RAST_SHL(bool value){ raw = (raw & 0xfffffffffffbffff) | ((uint64_t)value & 0x1) << 18; }

    /** Gets Check seat catch HL */
    bool get_RAST_SHL() const { return (bool)(raw >> 18 & 0x1); }
        
    /** Sets Check seat HI RE contact */
    void set_KONT_HI_RE(bool value){ raw = (raw & 0xfffffffffffdffff) | ((uint64_t)value & 0x1) << 17; }

    /** Gets Check seat HI RE contact */
    bool get_KONT_HI_RE() const { return (bool)(raw >> 17 & 0x1); }
        
    /** Sets Check seat HI LI contact */
    void set_KONT_HI_LI(bool value){ raw = (raw & 0xfffffffffffeffff) | ((uint64_t)value & 0x1) << 16; }

    /** Gets Check seat HI LI contact */
    bool get_KONT_HI_LI() const { return (bool)(raw >> 16 & 0x1); }
        
} ARMADA_A1;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of ARMADA_A2 */
	uint32_t get_canid(){ return ARMADA_A2_CAN_ID; }
    /** Sets Confirm bit for all crash events, toggles */
    void set_CONF_CRASH(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Confirm bit for all crash events, toggles */
    bool get_CONF_CRASH() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets rollover event 1 */
    void set_CRASH_G(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets rollover event 1 */
    bool get_CRASH_G() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets Frontal event 2 */
    void set_CRASH_F(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets Frontal event 2 */
    bool get_CRASH_F() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets tail event 2 */
    void set_CRASH_E(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets tail event 2 */
    bool get_CRASH_E() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets side event 1 */
    void set_CRASH_D(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets side event 1 */
    bool get_CRASH_D() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets Frontal event 5 */
    void set_CRASH_C(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets Frontal event 5 */
    bool get_CRASH_C() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets tail event 1 */
    void set_CRASH_B(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets tail event 1 */
    bool get_CRASH_B() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets Frontal event 1 */
    void set_CRASH_A(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets Frontal event 1 */
    bool get_CRASH_A() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Any crash event present */
    void set_X_CRASH(bool value){ raw = (raw & 0xff7fffffffffffff) | ((uint64_t)value & 0x1) << 55; }

    /** Gets Any crash event present */
    bool get_X_CRASH() const { return (bool)(raw >> 55 & 0x1); }
        
    /** Sets event tbd */
    void set_CRASH_O(bool value){ raw = (raw & 0xffbfffffffffffff) | ((uint64_t)value & 0x1) << 54; }

    /** Gets event tbd */
    bool get_CRASH_O() const { return (bool)(raw >> 54 & 0x1); }
        
    /** Sets event tbd */
    void set_CRASH_N(bool value){ raw = (raw & 0xffdfffffffffffff) | ((uint64_t)value & 0x1) << 53; }

    /** Gets event tbd */
    bool get_CRASH_N() const { return (bool)(raw >> 53 & 0x1); }
        
    /** Sets event tbd */
    void set_CRASH_M(bool value){ raw = (raw & 0xffefffffffffffff) | ((uint64_t)value & 0x1) << 52; }

    /** Gets event tbd */
    bool get_CRASH_M() const { return (bool)(raw >> 52 & 0x1); }
        
    /** Sets side event 2 */
    void set_CRASH_L(bool value){ raw = (raw & 0xfff7ffffffffffff) | ((uint64_t)value & 0x1) << 51; }

    /** Gets side event 2 */
    bool get_CRASH_L() const { return (bool)(raw >> 51 & 0x1); }
        
    /** Sets tail event 3 */
    void set_CRASH_K(bool value){ raw = (raw & 0xfffbffffffffffff) | ((uint64_t)value & 0x1) << 50; }

    /** Gets tail event 3 */
    bool get_CRASH_K() const { return (bool)(raw >> 50 & 0x1); }
        
    /** Sets rollover event 3 */
    void set_CRASH_I(bool value){ raw = (raw & 0xfffdffffffffffff) | ((uint64_t)value & 0x1) << 49; }

    /** Gets rollover event 3 */
    bool get_CRASH_I() const { return (bool)(raw >> 49 & 0x1); }
        
    /** Sets rollover event 2 */
    void set_CRASH_H(bool value){ raw = (raw & 0xfffeffffffffffff) | ((uint64_t)value & 0x1) << 48; }

    /** Gets rollover event 2 */
    bool get_CRASH_H() const { return (bool)(raw >> 48 & 0x1); }
        
} ARMADA_A2;



typedef union {
	uint64_t raw;
	uint8_t bytes[8];

	/** Gets CAN ID of SD_RS_ARMADA */
	uint32_t get_canid(){ return SD_RS_ARMADA_CAN_ID; }
    /** Sets Identification for > 8 bytes */
    void set_ARMADA_KENN(bool value){ raw = (raw & 0x7fffffffffffffff) | ((uint64_t)value & 0x1) << 63; }

    /** Gets Identification for > 8 bytes */
    bool get_ARMADA_KENN() const { return (bool)(raw >> 63 & 0x1); }
        
    /** Sets state variable 07h */
    void set_ARMADA_PGV07(bool value){ raw = (raw & 0xbfffffffffffffff) | ((uint64_t)value & 0x1) << 62; }

    /** Gets state variable 07h */
    bool get_ARMADA_PGV07() const { return (bool)(raw >> 62 & 0x1); }
        
    /** Sets state variable 06h */
    void set_ARMADA_PGV06(bool value){ raw = (raw & 0xdfffffffffffffff) | ((uint64_t)value & 0x1) << 61; }

    /** Gets state variable 06h */
    bool get_ARMADA_PGV06() const { return (bool)(raw >> 61 & 0x1); }
        
    /** Sets state variable 05h */
    void set_ARMADA_PGV05(bool value){ raw = (raw & 0xefffffffffffffff) | ((uint64_t)value & 0x1) << 60; }

    /** Gets state variable 05h */
    bool get_ARMADA_PGV05() const { return (bool)(raw >> 60 & 0x1); }
        
    /** Sets state variable 04h */
    void set_ARMADA_PGV04(bool value){ raw = (raw & 0xf7ffffffffffffff) | ((uint64_t)value & 0x1) << 59; }

    /** Gets state variable 04h */
    bool get_ARMADA_PGV04() const { return (bool)(raw >> 59 & 0x1); }
        
    /** Sets state variable 03h */
    void set_ARMADA_PGV03(bool value){ raw = (raw & 0xfbffffffffffffff) | ((uint64_t)value & 0x1) << 58; }

    /** Gets state variable 03h */
    bool get_ARMADA_PGV03() const { return (bool)(raw >> 58 & 0x1); }
        
    /** Sets state variable 02h */
    void set_ARMADA_PGV02(bool value){ raw = (raw & 0xfdffffffffffffff) | ((uint64_t)value & 0x1) << 57; }

    /** Gets state variable 02h */
    bool get_ARMADA_PGV02() const { return (bool)(raw >> 57 & 0x1); }
        
    /** Sets state variable 01h */
    void set_ARMADA_PGV01(bool value){ raw = (raw & 0xfeffffffffffffff) | ((uint64_t)value & 0x1) << 56; }

    /** Gets state variable 01h */
    bool get_ARMADA_PGV01() const { return (bool)(raw >> 56 & 0x1); }
        
    /** Sets Error message 01h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_ARMADA_FM01(uint16_t value){ raw = (raw & 0xff0000ffffffffff) | ((uint64_t)value & 0xffff) << 40; }

    /** Gets Error message 01h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_ARMADA_FM01() const { return (uint16_t)(raw >> 40 & 0xffff); }
        
    /** Sets Error message 02h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_ARMADA_FM02(uint16_t value){ raw = (raw & 0xffffff0000ffffff) | ((uint64_t)value & 0xffff) << 24; }

    /** Gets Error message 02h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_ARMADA_FM02() const { return (uint16_t)(raw >> 24 & 0xffff); }
        
    /** Sets Error message 03h. Conversion formula (To raw from real): y=(x-0.0)/1.00 */
    void set_ARMADA_FM03(uint16_t value){ raw = (raw & 0xffffffffff0000ff) | ((uint64_t)value & 0xffff) << 8; }

    /** Gets Error message 03h. Conversion formula (To real from raw): y=(1.00x)+0.0 */
    uint16_t get_ARMADA_FM03() const { return (uint16_t)(raw >> 8 & 0xffff); }
        
    /** Sets state variable 0Fh */
    void set_ARMADA_PGV0F(bool value){ raw = (raw & 0xffffffffffffff7f) | ((uint64_t)value & 0x1) << 7; }

    /** Gets state variable 0Fh */
    bool get_ARMADA_PGV0F() const { return (bool)(raw >> 7 & 0x1); }
        
    /** Sets state variable 0Eh */
    void set_ARMADA_PGV0E(bool value){ raw = (raw & 0xffffffffffffffbf) | ((uint64_t)value & 0x1) << 6; }

    /** Gets state variable 0Eh */
    bool get_ARMADA_PGV0E() const { return (bool)(raw >> 6 & 0x1); }
        
    /** Sets State variable 0Dh */
    void set_ARMADA_PGV0D(bool value){ raw = (raw & 0xffffffffffffffdf) | ((uint64_t)value & 0x1) << 5; }

    /** Gets State variable 0Dh */
    bool get_ARMADA_PGV0D() const { return (bool)(raw >> 5 & 0x1); }
        
    /** Sets state variable 0Ch */
    void set_ARMADA_PGV0C(bool value){ raw = (raw & 0xffffffffffffffef) | ((uint64_t)value & 0x1) << 4; }

    /** Gets state variable 0Ch */
    bool get_ARMADA_PGV0C() const { return (bool)(raw >> 4 & 0x1); }
        
    /** Sets state variable 0Bh */
    void set_ARMADA_PGV0B(bool value){ raw = (raw & 0xfffffffffffffff7) | ((uint64_t)value & 0x1) << 3; }

    /** Gets state variable 0Bh */
    bool get_ARMADA_PGV0B() const { return (bool)(raw >> 3 & 0x1); }
        
    /** Sets State variable 0Ah */
    void set_ARMADA_PGV0A(bool value){ raw = (raw & 0xfffffffffffffffb) | ((uint64_t)value & 0x1) << 2; }

    /** Gets State variable 0Ah */
    bool get_ARMADA_PGV0A() const { return (bool)(raw >> 2 & 0x1); }
        
    /** Sets state variable 09h */
    void set_ARMADA_PGV09(bool value){ raw = (raw & 0xfffffffffffffffd) | ((uint64_t)value & 0x1) << 1; }

    /** Gets state variable 09h */
    bool get_ARMADA_PGV09() const { return (bool)(raw >> 1 & 0x1); }
        
    /** Sets state variable 08h */
    void set_ARMADA_PGV08(bool value){ raw = (raw & 0xfffffffffffffffe) | ((uint64_t)value & 0x1) << 0; }

    /** Gets state variable 08h */
    bool get_ARMADA_PGV08() const { return (bool)(raw >> 0 & 0x1); }
        
} SD_RS_ARMADA;



class ECU_ARMADA {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            switch(can_id) {
                case ARMADA_A1_CAN_ID:
                    LAST_FRAME_TIMES[0] = timestamp_now;
                    FRAME_DATA[0] = value;
                    return true;
                case ARMADA_A2_CAN_ID:
                    LAST_FRAME_TIMES[1] = timestamp_now;
                    FRAME_DATA[1] = value;
                    return true;
                case SD_RS_ARMADA_CAN_ID:
                    LAST_FRAME_TIMES[2] = timestamp_now;
                    FRAME_DATA[2] = value;
                    return true;
                default:
                    return false;
            }
        }
        
        /** Sets data in pointer to ARMADA_A1
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ARMADA_A1(uint64_t now, uint64_t max_expire_time, ARMADA_A1* dest) const {
            if (LAST_FRAME_TIMES[0] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[0] && now - LAST_FRAME_TIMES[0] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[0];
                return true;
            }
        }
            
        /** Sets data in pointer to ARMADA_A2
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_ARMADA_A2(uint64_t now, uint64_t max_expire_time, ARMADA_A2* dest) const {
            if (LAST_FRAME_TIMES[1] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[1] && now - LAST_FRAME_TIMES[1] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[1];
                return true;
            }
        }
            
        /** Sets data in pointer to SD_RS_ARMADA
          * 
          * If this function returns false, then the CAN Frame is invalid or has not been seen
          * on the CANBUS network yet. Meaning it's data cannot be used.
          *
          * If the function returns true, then the pointer to 'dest' has been updated with the new CAN data
          */
        bool get_SD_RS_ARMADA(uint64_t now, uint64_t max_expire_time, SD_RS_ARMADA* dest) const {
            if (LAST_FRAME_TIMES[2] == 0 || dest == nullptr) { // CAN Frame has not been seen on bus yet / NULL pointer
                return false;
            } else if (now > LAST_FRAME_TIMES[2] && now - LAST_FRAME_TIMES[2] > max_expire_time) { // CAN Frame has not refreshed in valid interval
                return false;
            } else { // CAN Frame is valid! return it
                dest->raw = FRAME_DATA[2];
                return true;
            }
        }
            
	private:
		uint64_t FRAME_DATA[3];
		uint64_t LAST_FRAME_TIMES[3];
};
#endif // __ECU_ARMADA_H_