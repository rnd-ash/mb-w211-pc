
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ZGW'
*/
    
pub const ZGW_A4_CAN_ID: u16 = 0x01BC;
pub const ZGW_A5_CAN_ID: u16 = 0x001F;
pub const ZGW_A6_CAN_ID: u16 = 0x001E;
pub const GW_C_B1_CAN_ID: u16 = 0x0002;
pub const GW_C_B2_CAN_ID: u16 = 0x0003;
pub const GW_C_B3_CAN_ID: u16 = 0x0222;
pub const GW_C_B4_CAN_ID: u16 = 0x0322;
pub const GW_C_B5_CAN_ID: u16 = 0x010A;
pub const GW_C_B7_CAN_ID: u16 = 0x0005;
pub const GW_D_B1_CAN_ID: u16 = 0x018C;

/// Status Service Warning
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A4_SV_WARN {
	KEINE_WARN = 0, // no warning
	SV_JETZT = 1, // Service reached
	SV_UEBZGN = 2, // Service overstated
	SNV = 3, // Signal not present
}

impl TryFrom<u8> for ZGW_A4_SV_WARN {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::KEINE_WARN),
			1 => Ok(Self::SV_JETZT),
			2 => Ok(Self::SV_UEBZGN),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// display mode
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A4_SV_ANZ_MOD {
	ANZ_REST = 0, // Service in x days/km/miles
	ANZ_UEBZGN = 1, // Service exceeded by x days/km/miles.
	ANZ_SV = 2, // Perform service
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for ZGW_A4_SV_ANZ_MOD {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::ANZ_REST),
			1 => Ok(Self::ANZ_UEBZGN),
			2 => Ok(Self::ANZ_SV),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// scope of service
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A4_SV_UMFANG {
	KEIN_SV = 0, // no display
	SC_WART = 1, // Service code WR
	SV_A = 2, // Service scope "A"
	SV_B = 3, // Service scope "B"
}

impl TryFrom<u8> for ZGW_A4_SV_UMFANG {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::KEIN_SV),
			1 => Ok(Self::SC_WART),
			2 => Ok(Self::SV_A),
			3 => Ok(Self::SV_B),
			_ => Err(())
		}
	}
}
/// Country specific SA coding
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A5_LAND {
	RDW = 0, // Rest of the world
	C494 = 1, // USA version (CODE 494)
	C460 = 2, // Canada (CODE 460)
	C498 = 3, // Japan (CODE 498)
	C823 = 4, // Switzerland (CODE 823)
	C625 = 5, // Australia (CODE 625)
	C623 = 6, // Gulf States (CODE 623)
	SNV = 15, // SG not programmed
}

impl TryFrom<u8> for ZGW_A5_LAND {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::RDW),
			1 => Ok(Self::C494),
			2 => Ok(Self::C460),
			3 => Ok(Self::C498),
			4 => Ok(Self::C823),
			5 => Ok(Self::C625),
			6 => Ok(Self::C623),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Left/Right Hand Drive
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A5_LL_RL {
	LL = 1, // Left hand drive
	RL = 2, // Right hand drive
	SNV = 3, // SG not programmed
}

impl TryFrom<u8> for ZGW_A5_LL_RL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			1 => Ok(Self::LL),
			2 => Ok(Self::RL),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// vehicle code body
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A5_FCOD_KAR {
	W = 0, // W - sedan (or G short BM1/3 for BR 463, G for 461)
	V = 1, // V - long sedan (or VF for BR 210/211, G long BM6 for BR 463)
	C = 2, // C - Coup√© (or VV for BR 210/211/220)
	S = 3, // S - T-model (or special protection B4 for BR W240, T for BR 245)
	A = 4, // A - convertible (or X for BR 164)
	R = 5, // R - Roadster (or special protection B4 for BR 210/211/220/V240)
	SS = 6, // SS - special protection B6/7 (or CL for BR 203)
	SNV = 7, // Code not available
}

impl TryFrom<u8> for ZGW_A5_FCOD_KAR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::W),
			1 => Ok(Self::V),
			2 => Ok(Self::C),
			3 => Ok(Self::S),
			4 => Ok(Self::A),
			5 => Ok(Self::R),
			6 => Ok(Self::SS),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// vehicle code series
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A5_FCOD_BR {
	BR221 = 0, // BR 221 or BR 140
	BR129 = 1, // Class 129
	BR210 = 2, // BR 210 or BR 212
	BR202 = 3, // BR 202 or BR 204
	BR220 = 4, // Class 220
	BR170 = 5, // Class 170
	BR203 = 6, // Class 203
	BR168 = 7, // Class 168
	BR163 = 8, // Class 163
	BR208 = 9, // Class 208
	BR463 = 10, // Class 463
	BR215 = 11, // Class 215
	BR230 = 12, // Class 230
	BR211 = 13, // Class 211
	BR209 = 14, // Class 209
	BR461 = 15, // Class 461
	BR240 = 16, // Class 240
	BR251 = 17, // Class 251
	BR171 = 18, // Class 171
	BR164 = 19, // Class 164
	BR169 = 20, // BR 169 or BR 245
	BR199 = 21, // BR 199
	BR216 = 22, // Class 216
	BR219 = 23, // Class 219
	BR454 = 24, // BR 454 (z-car)
	NCV2 = 25, // NCV2
	VITO = 26, // V class/Vito
	SPRINTER = 27, // sprinters
	NCV3 = 28, // NCV3
	NCV1 = 29, // NCV1
	REST = 30, // all other BR
	SNV = 31, // Code not available
}

impl TryFrom<u8> for ZGW_A5_FCOD_BR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::BR221),
			1 => Ok(Self::BR129),
			2 => Ok(Self::BR210),
			3 => Ok(Self::BR202),
			4 => Ok(Self::BR220),
			5 => Ok(Self::BR170),
			6 => Ok(Self::BR203),
			7 => Ok(Self::BR168),
			8 => Ok(Self::BR163),
			9 => Ok(Self::BR208),
			10 => Ok(Self::BR463),
			11 => Ok(Self::BR215),
			12 => Ok(Self::BR230),
			13 => Ok(Self::BR211),
			14 => Ok(Self::BR209),
			15 => Ok(Self::BR461),
			16 => Ok(Self::BR240),
			17 => Ok(Self::BR251),
			18 => Ok(Self::BR171),
			19 => Ok(Self::BR164),
			20 => Ok(Self::BR169),
			21 => Ok(Self::BR199),
			22 => Ok(Self::BR216),
			23 => Ok(Self::BR219),
			24 => Ok(Self::BR454),
			25 => Ok(Self::NCV2),
			26 => Ok(Self::VITO),
			27 => Ok(Self::SPRINTER),
			28 => Ok(Self::NCV3),
			29 => Ok(Self::NCV1),
			30 => Ok(Self::REST),
			31 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Vehicle code engine
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A5_FCOD_MOT {
	M272E35_DE35 = 0, // M272 E35 or M272 DE35
	M271E18ML105 = 1, // M271 E18 ML red. (105kW)
	M271E18ML120 = 2, // M271 E18ML (120kW)
	M112E37 = 3, // M112 E37
	M272E25_DE25 = 4, // M272 E25 or M272 DE25
	M272E30_DE30 = 5, // M272 E30 or M272 DE30
	M112E28 = 7, // M112 E28
	M112E32 = 8, // M112 E32
	M273E46_DE46 = 10, // M273 E46 or M273 DE46
	M273E55_DE55 = 11, // M273 E55 or M273 DE55
	M112E26 = 12, // M112 E26
	M113E43 = 13, // M113 E43
	M113E50 = 14, // M113 E50
	M271E18ML140 = 18, // M271 E18 ML/1 (140 kW)
	M271DE18ML105 = 19, // M271 DE18 ML red. (105kW)
	M271DE18ML125 = 20, // M271 DE18ML (125kW)
	M111E_E23ML = 22, // M111E E23 ML
	M111E_E20 = 23, // M111E E20
	M111E_E20ML = 24, // M111E E20ML
	M112E32_140 = 25, // M112 E32 red. (140kW)
	M266E20ATL = 26, // M266 E20 ATL
	M266E15 = 27, // M266 E15
	M266E17 = 28, // M266 E17
	M266E20 = 29, // M266 E20
	M275E55 = 30, // M275 E55 or M285 E55
	M137E58 = 31, // M137 E58
	OM640DE20LA60 = 32, // OM 640 DE20 LA (60 kW)
	OM640DE20LA80 = 34, // OM 640 DE20 LA (80 kW)
	OM642DE30LA160 = 35, // OM642 DE30 LA (155/160 kW)
	OM640DE20LA100 = 36, // OM 640 DE20 LA (100 kW)
	OM613DE32LA = 37, // OM613 DE32 LA or OM648 DE32 LA
	OM639DE15LA = 38, // OM 639 DE15 LA (70/50 kW)
	OM628DE40LA = 39, // OM628 DE40 LA
	OM642DE30LA140 = 40, // OM642 DE30 LA (140kW)
	OM612DE27LA = 43, // OM612 DE27 LA or OM647 DE27 LA (120/130 kW)
	OM611DE22LA100 = 44, // OM611 DE22 LA (105/100 kW) or OM646 DE22 LA (100/105/110 kW)
	OM611DE22LA85 = 45, // OM611 DE22 LA (85 kW) or OM646 DE22 LA (90 kW)
	OM611DE22LA75 = 46, // OM611 DE22 LA (75 kW) or OM646 DE22 LA (75 kW)
	AMGM112E32ML = 48, // AMG M112 E32 ML
	AMGM113E55ML = 49, // AMG M113 E55 ML
	AMGM155E55ML = 50, // AMG M155 E55 ML
	AMGM275E60 = 51, // AMG M275 E60
	AMGOM612DE30LA = 52, // AMG OM612 DE30 LA
	AMGM137E63 = 56, // AMG M137 E63
	AMGM113E55 = 57, // AMG M113 E55
	AMGM156E60ML = 60, // AMG M156 E60 ML
	AMGM156E55ML = 61, // AMG M156 E63
	VR6 = 62, // VR6 from VW
	SNV = 63, // Code not available
}

impl TryFrom<u8> for ZGW_A5_FCOD_MOT {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::M272E35_DE35),
			1 => Ok(Self::M271E18ML105),
			2 => Ok(Self::M271E18ML120),
			3 => Ok(Self::M112E37),
			4 => Ok(Self::M272E25_DE25),
			5 => Ok(Self::M272E30_DE30),
			7 => Ok(Self::M112E28),
			8 => Ok(Self::M112E32),
			10 => Ok(Self::M273E46_DE46),
			11 => Ok(Self::M273E55_DE55),
			12 => Ok(Self::M112E26),
			13 => Ok(Self::M113E43),
			14 => Ok(Self::M113E50),
			18 => Ok(Self::M271E18ML140),
			19 => Ok(Self::M271DE18ML105),
			20 => Ok(Self::M271DE18ML125),
			22 => Ok(Self::M111E_E23ML),
			23 => Ok(Self::M111E_E20),
			24 => Ok(Self::M111E_E20ML),
			25 => Ok(Self::M112E32_140),
			26 => Ok(Self::M266E20ATL),
			27 => Ok(Self::M266E15),
			28 => Ok(Self::M266E17),
			29 => Ok(Self::M266E20),
			30 => Ok(Self::M275E55),
			31 => Ok(Self::M137E58),
			32 => Ok(Self::OM640DE20LA60),
			34 => Ok(Self::OM640DE20LA80),
			35 => Ok(Self::OM642DE30LA160),
			36 => Ok(Self::OM640DE20LA100),
			37 => Ok(Self::OM613DE32LA),
			38 => Ok(Self::OM639DE15LA),
			39 => Ok(Self::OM628DE40LA),
			40 => Ok(Self::OM642DE30LA140),
			43 => Ok(Self::OM612DE27LA),
			44 => Ok(Self::OM611DE22LA100),
			45 => Ok(Self::OM611DE22LA85),
			46 => Ok(Self::OM611DE22LA75),
			48 => Ok(Self::AMGM112E32ML),
			49 => Ok(Self::AMGM113E55ML),
			50 => Ok(Self::AMGM155E55ML),
			51 => Ok(Self::AMGM275E60),
			52 => Ok(Self::AMGOM612DE30LA),
			56 => Ok(Self::AMGM137E63),
			57 => Ok(Self::AMGM113E55),
			60 => Ok(Self::AMGM156E60ML),
			61 => Ok(Self::AMGM156E55ML),
			62 => Ok(Self::VR6),
			63 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// year
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A6_VER_JAHR {
	Y2000 = 0, // Unknown
	Y2001 = 1, // Unknown
	Y2002 = 2, // Unknown
	Y2003 = 3, // Unknown
	Y2004 = 4, // Unknown
	Y2005 = 5, // Unknown
	Y2006 = 6, // Unknown
	Y2007 = 7, // Unknown
	Y2008 = 8, // Unknown
	Y2009 = 9, // Unknown
	Y2010 = 10, // Unknown
	Y2011 = 11, // Unknown
	Y2012 = 12, // Unknown
	Y2013 = 13, // Unknown
	Y2014 = 14, // Unknown
	Y2015 = 15, // Unknown
	Y2016 = 16, // Unknown
	Y2017 = 17, // Unknown
	Y2018 = 18, // Unknown
	Y2019 = 19, // Unknown
	Y2020 = 20, // Unknown
	Y2021 = 21, // Unknown
	Y2022 = 22, // Unknown
	Y2023 = 23, // Unknown
	Y2024 = 24, // Unknown
	Y2025 = 25, // Unknown
	Y2026 = 26, // Unknown
	Y2027 = 27, // Unknown
	Y2028 = 28, // Unknown
	Y2029 = 29, // Unknown
	YN_DEF = 30, // undefined
	SB = 31, // Start of series production
}

impl TryFrom<u8> for ZGW_A6_VER_JAHR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::Y2000),
			1 => Ok(Self::Y2001),
			2 => Ok(Self::Y2002),
			3 => Ok(Self::Y2003),
			4 => Ok(Self::Y2004),
			5 => Ok(Self::Y2005),
			6 => Ok(Self::Y2006),
			7 => Ok(Self::Y2007),
			8 => Ok(Self::Y2008),
			9 => Ok(Self::Y2009),
			10 => Ok(Self::Y2010),
			11 => Ok(Self::Y2011),
			12 => Ok(Self::Y2012),
			13 => Ok(Self::Y2013),
			14 => Ok(Self::Y2014),
			15 => Ok(Self::Y2015),
			16 => Ok(Self::Y2016),
			17 => Ok(Self::Y2017),
			18 => Ok(Self::Y2018),
			19 => Ok(Self::Y2019),
			20 => Ok(Self::Y2020),
			21 => Ok(Self::Y2021),
			22 => Ok(Self::Y2022),
			23 => Ok(Self::Y2023),
			24 => Ok(Self::Y2024),
			25 => Ok(Self::Y2025),
			26 => Ok(Self::Y2026),
			27 => Ok(Self::Y2027),
			28 => Ok(Self::Y2028),
			29 => Ok(Self::Y2029),
			30 => Ok(Self::YN_DEF),
			31 => Ok(Self::SB),
			_ => Err(())
		}
	}
}
/// Year of change
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_A6_VER_AE {
	V1 = 0, // Unknown
	VX = 1, // Unknown
	V2 = 2, // Unknown
	SB = 3, // Start of series production
}

impl TryFrom<u8> for ZGW_A6_VER_AE {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::V1),
			1 => Ok(Self::VX),
			2 => Ok(Self::V2),
			3 => Ok(Self::SB),
			_ => Err(())
		}
	}
}
/// Brake light switch status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B2_BLS_ST {
	BREMSE_NBET = 0, // Brake not applied
	BREMSE_BET = 1, // Brake applied
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B2_BLS_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::BREMSE_NBET),
			1 => Ok(Self::BREMSE_BET),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// loading
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B2_BELADUNG {
	LEER = 0, // Unloaded
	HALB = 1, // Half loaded
	VOLL = 2, // Fully loaded
	SNV = 3, // Load not recognized
}

impl TryFrom<u8> for GW_C_B2_BELADUNG {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::LEER),
			1 => Ok(Self::HALB),
			2 => Ok(Self::VOLL),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Gear selector lever position (NAG only)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B2_WHC {
	D = 5, // selector lever in position "D"
	N = 6, // Selector lever in "N" position
	R = 7, // selector lever in position "R"
	P = 8, // selector lever in position "P"
	PLUS = 9, // Selector lever in "+" position
	MINUS = 10, // Selector lever in "-" position
	N_ZW_D = 11, // selector lever in intermediate position "N-D"
	N_ZW_R = 12, // selector lever in intermediate position "N-R"
	P_ZW_R = 13, // selector lever in intermediate position "P-R"
	SNV = 15, // Selector lever position implausible
}

impl TryFrom<u8> for GW_C_B2_WHC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			5 => Ok(Self::D),
			6 => Ok(Self::N),
			7 => Ok(Self::R),
			8 => Ok(Self::P),
			9 => Ok(Self::PLUS),
			10 => Ok(Self::MINUS),
			11 => Ok(Self::N_ZW_D),
			12 => Ok(Self::N_ZW_R),
			13 => Ok(Self::P_ZW_R),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front left
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B2_DRTGVL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B2_DRTGVL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Gear selector lever position (NAG, KSG, CVT)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B2_WHST {
	P = 0, // Gear selector lever in position "P"
	R = 1, // Gear selector lever in position "R"
	N = 2, // Gear selector lever in position "N"
	D = 4, // Gear selector lever in position "D"
	SNV = 7, // Signal not available
}

impl TryFrom<u8> for GW_C_B2_WHST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::P),
			1 => Ok(Self::R),
			2 => Ok(Self::N),
			4 => Ok(Self::D),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// EHB vehicle electrical system status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B3_EHB_BN {
	U_GRUEN = 0, // U_EHB > 10.5 V for t > 500 ms
	U_GELB = 1, // 9.5 V < U_EHB <= 10.5 V for t > 500 ms
	U_ROT = 2, // 8.5 V < U_EHB <= 9.5 V for t > 500 ms
	U_MIN = 3, // U_EHB <= 8.5 V (Bosch only: or signal not available)
}

impl TryFrom<u8> for GW_C_B3_EHB_BN {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::U_GRUEN),
			1 => Ok(Self::U_GELB),
			2 => Ok(Self::U_ROT),
			3 => Ok(Self::U_MIN),
			_ => Err(())
		}
	}
}
/// Heat output status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B3_HZL_ST {
	ZU = 0, // Heater shut-off valve is closed
	AUF = 1, // Heater shut-off valve is open
	TAKT = 2, // Heating shut-off valve is clocked
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B3_HZL_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::ZU),
			1 => Ok(Self::AUF),
			2 => Ok(Self::TAKT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Presafe adjustment seat front right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_R_SVR {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_R_SVR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Presafe adjustment of the front left seat
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_L_SVL {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_L_SVL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Presafe adjustment window front right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_R_FH {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_R_FH {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Presafe adjustment window front left
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_L_FH {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_L_FH {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Presafe sliding/tilting sunroof adjustment
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_R_SHD {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_R_SHD {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Presafe sliding/tilting sunroof adjustment
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B4_PRESF_L_SHD {
	AUS = 0, // Presafe off
	PRESAFE = 1, // Approach presafe position
	ZURUECK = 2, // Approach starting position
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GW_C_B4_PRESF_L_SHD {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::PRESAFE),
			2 => Ok(Self::ZURUECK),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear wheel to the right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B5_DRTGHR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B5_DRTGHR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear left wheel
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B5_DRTGHL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B5_DRTGHL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GW_C_B7_DRTGVR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GW_C_B7_DRTGVR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ZGW_A4(pub u64);

impl ZGW_A4 {

	/// Gets CAN ID of ZGW_A4
	pub const fn get_canid() -> u16 { ZGW_A4_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets remaining distance in km [0], miles [1]

    pub fn set_RLS_KM_M(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets remaining distance in km [0], miles [1]
    pub fn get_RLS_KM_M(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Priority: remaining distance [0], remaining time [1]

    pub fn set_RLSZ_PRIO(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Priority: remaining distance [0], remaining time [1]
    pub fn get_RLSZ_PRIO(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Status Service Warning

    pub fn set_SV_WARN(&mut self, value: ZGW_A4_SV_WARN){ self.0 = (self.0 & 0xcfffffffffffffff) | ((value as u64) & 0x3) << 60; }

    /// Gets Status Service Warning
    pub fn get_SV_WARN(&self) -> std::result::Result<ZGW_A4_SV_WARN, ()> { return ZGW_A4_SV_WARN::try_from((self.0 >> 60 & 0x3) as u8) }
        
    /// Sets display mode

    pub fn set_SV_ANZ_MOD(&mut self, value: ZGW_A4_SV_ANZ_MOD){ self.0 = (self.0 & 0xf3ffffffffffffff) | ((value as u64) & 0x3) << 58; }

    /// Gets display mode
    pub fn get_SV_ANZ_MOD(&self) -> std::result::Result<ZGW_A4_SV_ANZ_MOD, ()> { return ZGW_A4_SV_ANZ_MOD::try_from((self.0 >> 58 & 0x3) as u8) }
        
    /// Sets scope of service

    pub fn set_SV_UMFANG(&mut self, value: ZGW_A4_SV_UMFANG){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets scope of service
    pub fn get_SV_UMFANG(&self) -> std::result::Result<ZGW_A4_SV_UMFANG, ()> { return ZGW_A4_SV_UMFANG::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets Service value. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: ASCII)

    pub fn set_SV_WERT(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Service value. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: ASCII)
    pub fn get_SV_WERT(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Remaining term. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Tage)

    pub fn set_REST_ZEIT(&mut self, value: u16){ self.0 = (self.0 & 0xffff0000ffffffff) | ((value as u64) & 0xffff) << 32; }

    /// Gets Remaining term. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Tage)
    pub fn get_REST_ZEIT(&self) -> u16 { (self.0 >> 32 & 0xffff) as u16 }
        
    /// Sets no. special service [0] no disp., [1] display

    pub fn set_SV_ANZ_SS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets no. special service [0] no disp., [1] display
    pub fn get_SV_ANZ_SS(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets WR data valid [0] invalid, [1] valid

    pub fn set_WARTUNG_OK(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets WR data valid [0] invalid, [1] valid
    pub fn get_WARTUNG_OK(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets remaining distance. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: km(miles))

    pub fn set_REST_WEG(&mut self, value: u32){ self.0 = (self.0 & 0xffffffffff000000) | ((value as u64) & 0xffffff) << 0; }

    /// Gets remaining distance. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: km(miles))
    pub fn get_REST_WEG(&self) -> u32 { (self.0 >> 0 & 0xffffff) as u32 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ZGW_A5(pub u64);

impl ZGW_A5 {

	/// Gets CAN ID of ZGW_A5
	pub const fn get_canid() -> u16 { ZGW_A5_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Country specific SA coding

    pub fn set_LAND(&mut self, value: ZGW_A5_LAND){ self.0 = (self.0 & 0x0fffffffffffffff) | ((value as u64) & 0xf) << 60; }

    /// Gets Country specific SA coding
    pub fn get_LAND(&self) -> std::result::Result<ZGW_A5_LAND, ()> { return ZGW_A5_LAND::try_from((self.0 >> 60 & 0xf) as u8) }
        
    /// Sets Left/Right Hand Drive

    pub fn set_LL_RL(&mut self, value: ZGW_A5_LL_RL){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets Left/Right Hand Drive
    pub fn get_LL_RL(&self) -> std::result::Result<ZGW_A5_LL_RL, ()> { return ZGW_A5_LL_RL::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets Special Protection Guard B4

    pub fn set_GUARD_B4(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets Special Protection Guard B4
    pub fn get_GUARD_B4(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Modification for the disabled (via testers only)

    pub fn set_BEHI_FZG(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets Modification for the disabled (via testers only)
    pub fn get_BEHI_FZG(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets Radio override taxi

    pub fn set_TAXI_FUNKAUF(&mut self, value: bool){ self.0 = (self.0 & 0xffdfffffffffffff) | ((value as u64) & 0x1) << 53; }

    /// Gets Radio override taxi
    pub fn get_TAXI_FUNKAUF(&self) -> bool { (self.0 >> 53 & 0x1) != 0 }
        
    /// Sets special vehicle

    pub fn set_SO_FZG(&mut self, value: bool){ self.0 = (self.0 & 0xffefffffffffffff) | ((value as u64) & 0x1) << 52; }

    /// Gets special vehicle
    pub fn get_SO_FZG(&self) -> bool { (self.0 >> 52 & 0x1) != 0 }
        
    /// Sets Taxi call for help

    pub fn set_TAXI_HIRU(&mut self, value: bool){ self.0 = (self.0 & 0xfff7ffffffffffff) | ((value as u64) & 0x1) << 51; }

    /// Gets Taxi call for help
    pub fn get_TAXI_HIRU(&self) -> bool { (self.0 >> 51 & 0x1) != 0 }
        
    /// Sets Connection for roof sign

    pub fn set_TAXI_DZ(&mut self, value: bool){ self.0 = (self.0 & 0xfffbffffffffffff) | ((value as u64) & 0x1) << 50; }

    /// Gets Connection for roof sign
    pub fn get_TAXI_DZ(&self) -> bool { (self.0 >> 50 & 0x1) != 0 }
        
    /// Sets Taxi emergency alarm system

    pub fn set_TAXI_NOTALM(&mut self, value: bool){ self.0 = (self.0 & 0xfffdffffffffffff) | ((value as u64) & 0x1) << 49; }

    /// Gets Taxi emergency alarm system
    pub fn get_TAXI_NOTALM(&self) -> bool { (self.0 >> 49 & 0x1) != 0 }
        
    /// Sets Taxi power supply

    pub fn set_TAXI_INT(&mut self, value: bool){ self.0 = (self.0 & 0xfffeffffffffffff) | ((value as u64) & 0x1) << 48; }

    /// Gets Taxi power supply
    pub fn get_TAXI_INT(&self) -> bool { (self.0 >> 48 & 0x1) != 0 }
        
    /// Sets Disable air recirculation comfort controls

    pub fn set_KB_SPERR_KLA(&mut self, value: bool){ self.0 = (self.0 & 0xffff7fffffffffff) | ((value as u64) & 0x1) << 47; }

    /// Gets Disable air recirculation comfort controls
    pub fn get_KB_SPERR_KLA(&self) -> bool { (self.0 >> 47 & 0x1) != 0 }
        
    /// Sets Recirculation comfort run mode automatic [0], manual [1]

    pub fn set_KB_MAN_KLA(&mut self, value: bool){ self.0 = (self.0 & 0xffffbfffffffffff) | ((value as u64) & 0x1) << 46; }

    /// Gets Recirculation comfort run mode automatic [0], manual [1]
    pub fn get_KB_MAN_KLA(&self) -> bool { (self.0 >> 46 & 0x1) != 0 }
        
    /// Sets Comfort run mode manual [0], automatic [1]

    pub fn set_KB_AUTO(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets Comfort run mode manual [0], automatic [1]
    pub fn get_KB_AUTO(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Emergency opening inactive (only via tester)

    pub fn set_ZV_NOT_PAS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffdffffffffff) | ((value as u64) & 0x1) << 41; }

    /// Gets Emergency opening inactive (only via tester)
    pub fn get_ZV_NOT_PAS(&self) -> bool { (self.0 >> 41 & 0x1) != 0 }
        
    /// Sets Special Protection Guard B6/7

    pub fn set_GUARD_B6(&mut self, value: bool){ self.0 = (self.0 & 0xfffffeffffffffff) | ((value as u64) & 0x1) << 40; }

    /// Gets Special Protection Guard B6/7
    pub fn get_GUARD_B6(&self) -> bool { (self.0 >> 40 & 0x1) != 0 }
        
    /// Sets vehicle code body

    pub fn set_FCOD_KAR(&mut self, value: ZGW_A5_FCOD_KAR){ self.0 = (self.0 & 0xffffff1fffffffff) | ((value as u64) & 0x7) << 37; }

    /// Gets vehicle code body
    pub fn get_FCOD_KAR(&self) -> std::result::Result<ZGW_A5_FCOD_KAR, ()> { return ZGW_A5_FCOD_KAR::try_from((self.0 >> 37 & 0x7) as u8) }
        
    /// Sets vehicle code series

    pub fn set_FCOD_BR(&mut self, value: ZGW_A5_FCOD_BR){ self.0 = (self.0 & 0xffffffe0ffffffff) | ((value as u64) & 0x1f) << 32; }

    /// Gets vehicle code series
    pub fn get_FCOD_BR(&self) -> std::result::Result<ZGW_A5_FCOD_BR, ()> { return ZGW_A5_FCOD_BR::try_from((self.0 >> 32 & 0x1f) as u8) }
        
    /// Sets Flat roll warning available

    pub fn set_PRW_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets Flat roll warning available
    pub fn get_PRW_VH(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Vehicle code engine

    pub fn set_FCOD_MOT(&mut self, value: ZGW_A5_FCOD_MOT){ self.0 = (self.0 & 0xffffffffc0ffffff) | ((value as u64) & 0x3f) << 24; }

    /// Gets Vehicle code engine
    pub fn get_FCOD_MOT(&self) -> std::result::Result<ZGW_A5_FCOD_MOT, ()> { return ZGW_A5_FCOD_MOT::try_from((self.0 >> 24 & 0x3f) as u8) }
        
    /// Sets Xenon light present

    pub fn set_XEN_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets Xenon light present
    pub fn get_XEN_VH(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets headlight cleaning system available

    pub fn set_SRA_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffdfffff) | ((value as u64) & 0x1) << 21; }

    /// Gets headlight cleaning system available
    pub fn get_SRA_VH(&self) -> bool { (self.0 >> 21 & 0x1) != 0 }
        
    /// Sets air conditioning available

    pub fn set_KLA_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffefffff) | ((value as u64) & 0x1) << 20; }

    /// Gets air conditioning available
    pub fn get_KLA_VH(&self) -> bool { (self.0 >> 20 & 0x1) != 0 }
        
    /// Sets Automatic transmission available

    pub fn set_NAG_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffff7ffff) | ((value as u64) & 0x1) << 19; }

    /// Gets Automatic transmission available
    pub fn get_NAG_VH(&self) -> bool { (self.0 >> 19 & 0x1) != 0 }
        
    /// Sets Comfort manual transmission available

    pub fn set_KSG_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffbffff) | ((value as u64) & 0x1) << 18; }

    /// Gets Comfort manual transmission available
    pub fn get_KSG_VH(&self) -> bool { (self.0 >> 18 & 0x1) != 0 }
        
    /// Sets Driver's seat memory available

    pub fn set_MEMORY_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffdffff) | ((value as u64) & 0x1) << 17; }

    /// Gets Driver's seat memory available
    pub fn get_MEMORY_VH(&self) -> bool { (self.0 >> 17 & 0x1) != 0 }
        
    /// Sets Communication platform available

    pub fn set_KP_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffeffff) | ((value as u64) & 0x1) << 16; }

    /// Gets Communication platform available
    pub fn get_KP_VH(&self) -> bool { (self.0 >> 16 & 0x1) != 0 }
        
    /// Sets SA ART available

    pub fn set_ART_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets SA ART available
    pub fn get_ART_VH(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets SA parking heater available

    pub fn set_STH_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets SA parking heater available
    pub fn get_STH_VH(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets SA trunk lid remote closure

    pub fn set_HFS_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets SA trunk lid remote closure
    pub fn get_HFS_VH(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets SA automatic loading floor available

    pub fn set_ALB_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffff7ff) | ((value as u64) & 0x1) << 11; }

    /// Gets SA automatic loading floor available
    pub fn get_ALB_VH(&self) -> bool { (self.0 >> 11 & 0x1) != 0 }
        
    /// Sets SA CD changer available

    pub fn set_CDC_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffbff) | ((value as u64) & 0x1) << 10; }

    /// Gets SA CD changer available
    pub fn get_CDC_VH(&self) -> bool { (self.0 >> 10 & 0x1) != 0 }
        
    /// Sets Parktronic system available

    pub fn set_PTS_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffff7f) | ((value as u64) & 0x1) << 7; }

    /// Gets Parktronic system available
    pub fn get_PTS_VH(&self) -> bool { (self.0 >> 7 & 0x1) != 0 }
        
    /// Sets Trailer hitch present

    pub fn set_AHK_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffbf) | ((value as u64) & 0x1) << 6; }

    /// Gets Trailer hitch present
    pub fn get_AHK_VH(&self) -> bool { (self.0 >> 6 & 0x1) != 0 }
        
    /// Sets Rear blind available

    pub fn set_HR_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffdf) | ((value as u64) & 0x1) << 5; }

    /// Gets Rear blind available
    pub fn get_HR_VH(&self) -> bool { (self.0 >> 5 & 0x1) != 0 }
        
    /// Sets SA anti-theft alarm system available

    pub fn set_EDW_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffef) | ((value as u64) & 0x1) << 4; }

    /// Gets SA anti-theft alarm system available
    pub fn get_EDW_VH(&self) -> bool { (self.0 >> 4 & 0x1) != 0 }
        
    /// Sets SA interior protection available

    pub fn set_IRS_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffff7) | ((value as u64) & 0x1) << 3; }

    /// Gets SA interior protection available
    pub fn get_IRS_VH(&self) -> bool { (self.0 >> 3 & 0x1) != 0 }
        
    /// Sets SA Keyless Go available

    pub fn set_KG_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffb) | ((value as u64) & 0x1) << 2; }

    /// Gets SA Keyless Go available
    pub fn get_KG_VH(&self) -> bool { (self.0 >> 2 & 0x1) != 0 }
        
    /// Sets Complete replacement light allowed

    pub fn set_ERS_LICHT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffd) | ((value as u64) & 0x1) << 1; }

    /// Gets Complete replacement light allowed
    pub fn get_ERS_LICHT(&self) -> bool { (self.0 >> 1 & 0x1) != 0 }
        
    /// Sets washer fluid hose heating RL or C490 [0], LL or C875 [1]

    pub fn set_WWSH_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffe) | ((value as u64) & 0x1) << 0; }

    /// Gets washer fluid hose heating RL or C490 [0], LL or C875 [1]
    pub fn get_WWSH_VH(&self) -> bool { (self.0 >> 0 & 0x1) != 0 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ZGW_A6(pub u64);

impl ZGW_A6 {

	/// Gets CAN ID of ZGW_A6
	pub const fn get_canid() -> u16 { ZGW_A6_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets year

    pub fn set_VER_JAHR(&mut self, value: ZGW_A6_VER_JAHR){ self.0 = (self.0 & 0x83ffffffffffffff) | ((value as u64) & 0x1f) << 58; }

    /// Gets year
    pub fn get_VER_JAHR(&self) -> std::result::Result<ZGW_A6_VER_JAHR, ()> { return ZGW_A6_VER_JAHR::try_from((self.0 >> 58 & 0x1f) as u8) }
        
    /// Sets Year of change

    pub fn set_VER_AE(&mut self, value: ZGW_A6_VER_AE){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets Year of change
    pub fn get_VER_AE(&self) -> std::result::Result<ZGW_A6_VER_AE, ()> { return ZGW_A6_VER_AE::try_from((self.0 >> 56 & 0x3) as u8) }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B1(pub u64);

impl GW_C_B1 {

	/// Gets CAN ID of GW_C_B1
	pub const fn get_canid() -> u16 { GW_C_B1_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse)

    pub fn set_RIZ_VL(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse)
    pub fn get_RIZ_VL(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse)

    pub fn set_RIZ_VR(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse)
    pub fn get_RIZ_VR(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets engine speed. Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: 1/min)

    pub fn set_N_MOT(&mut self, value: u16){ self.0 = (self.0 & 0xffff0000ffffffff) | ((value as u64) & 0xffff) << 32; }

    /// Gets engine speed. Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: 1/min)
    pub fn get_N_MOT(&self) -> u16 { (self.0 >> 32 & 0xffff) as u16 }
        
    /// Sets Engine coolant temperature. Conversion formula (To raw from real): y=(x+40.0)/1.00 (Unit: ¬∞C)

    pub fn set_T_MOT(&mut self, value: u8){ self.0 = (self.0 & 0xffffffff00ffffff) | ((value as u64) & 0xff) << 24; }

    /// Gets Engine coolant temperature. Conversion formula (To real from raw): y=(1.00x)-40.0 (Unit: ¬∞C)
    pub fn get_T_MOT(&self) -> u8 { (self.0 >> 24 & 0xff) as u8 }
        
    /// Sets Steering angle parity bit (even parity)

    pub fn set_LW_PA_GW(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffff7fffff) | ((value as u64) & 0x1) << 23; }

    /// Gets Steering angle parity bit (even parity)
    pub fn get_LW_PA_GW(&self) -> bool { (self.0 >> 23 & 0x1) != 0 }
        
    /// Sets Steering Angle Sensor: Overflow

    pub fn set_LW_OV_GW(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets Steering Angle Sensor: Overflow
    pub fn get_LW_OV_GW(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets Steering angle sensor: code error

    pub fn set_LW_CF_GW(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffdfffff) | ((value as u64) & 0x1) << 21; }

    /// Gets Steering angle sensor: code error
    pub fn get_LW_CF_GW(&self) -> bool { (self.0 >> 21 & 0x1) != 0 }
        
    /// Sets Steering angle sensor: not initialized

    pub fn set_LW_INI_GW(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffefffff) | ((value as u64) & 0x1) << 20; }

    /// Gets Steering angle sensor: not initialized
    pub fn get_LW_INI_GW(&self) -> bool { (self.0 >> 20 & 0x1) != 0 }
        
    /// Sets Steering angle sign (right [0], left [1])

    pub fn set_LW_VZ_GW(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffff7ffff) | ((value as u64) & 0x1) << 19; }

    /// Gets Steering angle sign (right [0], left [1])
    pub fn get_LW_VZ_GW(&self) -> bool { (self.0 >> 19 & 0x1) != 0 }
        
    /// Sets steering angle. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: ¬∞)

    pub fn set_LW_GW(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffff800ff) | ((value as u64) & 0x7ff) << 8; }

    /// Gets steering angle. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: ¬∞)
    pub fn get_LW_GW(&self) -> u16 { (self.0 >> 8 & 0x7ff) as u16 }
        
    /// Sets oil temperature. Conversion formula (To raw from real): y=(x+40.0)/1.00 (Unit: ¬∞C)

    pub fn set_T_OEL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff) << 0; }

    /// Gets oil temperature. Conversion formula (To real from raw): y=(1.00x)-40.0 (Unit: ¬∞C)
    pub fn get_T_OEL(&self) -> u8 { (self.0 >> 0 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B2(pub u64);

impl GW_C_B2 {

	/// Gets CAN ID of GW_C_B2
	pub const fn get_canid() -> u16 { GW_C_B2_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets ART distance warning is on

    pub fn set_ART_ABW_AKT(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets ART distance warning is on
    pub fn get_ART_ABW_AKT(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Switch off air conditioning compressor: Acceleration

    pub fn set_KOMP_BAUS(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Switch off air conditioning compressor: Acceleration
    pub fn get_KOMP_BAUS(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets A/C compressor emergency shutdown

    pub fn set_KOMP_NOTAUS(&mut self, value: bool){ self.0 = (self.0 & 0xdfffffffffffffff) | ((value as u64) & 0x1) << 61; }

    /// Gets A/C compressor emergency shutdown
    pub fn get_KOMP_NOTAUS(&self) -> bool { (self.0 >> 61 & 0x1) != 0 }
        
    /// Sets Motor fan faulty indicator lamp

    pub fn set_LUEFT_MOT_KL(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets Motor fan faulty indicator lamp
    pub fn get_LUEFT_MOT_KL(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets ESP brake intervention active

    pub fn set_BRE_AKT_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets ESP brake intervention active
    pub fn get_BRE_AKT_ESP(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
    /// Sets brake light suppression

    pub fn set_BLS_UNT(&mut self, value: bool){ self.0 = (self.0 & 0xfbffffffffffffff) | ((value as u64) & 0x1) << 58; }

    /// Gets brake light suppression
    pub fn get_BLS_UNT(&self) -> bool { (self.0 >> 58 & 0x1) != 0 }
        
    /// Sets Brake light switch status

    pub fn set_BLS_ST(&mut self, value: GW_C_B2_BLS_ST){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets Brake light switch status
    pub fn get_BLS_ST(&self) -> std::result::Result<GW_C_B2_BLS_ST, ()> { return GW_C_B2_BLS_ST::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets reverse gear engaged (all transmissions)

    pub fn set_RG(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets reverse gear engaged (all transmissions)
    pub fn get_RG(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Park position engaged

    pub fn set_P(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets Park position engaged
    pub fn get_P(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets loading

    pub fn set_BELADUNG(&mut self, value: GW_C_B2_BELADUNG){ self.0 = (self.0 & 0xffcfffffffffffff) | ((value as u64) & 0x3) << 52; }

    /// Gets loading
    pub fn get_BELADUNG(&self) -> std::result::Result<GW_C_B2_BELADUNG, ()> { return GW_C_B2_BELADUNG::try_from((self.0 >> 52 & 0x3) as u8) }
        
    /// Sets Gear selector lever position (NAG only)

    pub fn set_WHC(&mut self, value: GW_C_B2_WHC){ self.0 = (self.0 & 0xfff0ffffffffffff) | ((value as u64) & 0xf) << 48; }

    /// Gets Gear selector lever position (NAG only)
    pub fn get_WHC(&self) -> std::result::Result<GW_C_B2_WHC, ()> { return GW_C_B2_WHC::try_from((self.0 >> 48 & 0xf) as u8) }
        
    /// Sets Direction of rotation of wheel, front left

    pub fn set_DRTGVL(&mut self, value: GW_C_B2_DRTGVL){ self.0 = (self.0 & 0xffff3fffffffffff) | ((value as u64) & 0x3) << 46; }

    /// Gets Direction of rotation of wheel, front left
    pub fn get_DRTGVL(&self) -> std::result::Result<GW_C_B2_DRTGVL, ()> { return GW_C_B2_DRTGVL::try_from((self.0 >> 46 & 0x3) as u8) }
        
    /// Sets Front left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min)

    pub fn set_DVL(&mut self, value: u16){ self.0 = (self.0 & 0xffffc000ffffffff) | ((value as u64) & 0x3fff) << 32; }

    /// Gets Front left wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min)
    pub fn get_DVL(&self) -> u16 { (self.0 >> 32 & 0x3fff) as u16 }
        
    /// Sets LED 2-stage switch steady light

    pub fn set_ST2_LED_DL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets LED 2-stage switch steady light
    pub fn get_ST2_LED_DL(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Right LED 3-position switch flashing light

    pub fn set_ST3_LEDR_BL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Right LED 3-position switch flashing light
    pub fn get_ST3_LEDR_BL(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets Right LED 3-position switch steady light

    pub fn set_ST3_LEDR_DL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets Right LED 3-position switch steady light
    pub fn get_ST3_LEDR_DL(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets Left LED 3-position switch flashing light

    pub fn set_ST3_LEDL_BL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets Left LED 3-position switch flashing light
    pub fn get_ST3_LEDL_BL(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets Left LED 3-position switch steady light

    pub fn set_ST3_LEDL_DL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets Left LED 3-position switch steady light
    pub fn get_ST3_LEDL_DL(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets FSG: EHB-ASG in fallback level

    pub fn set_INF_RFE_FSG(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets FSG: EHB-ASG in fallback level
    pub fn get_INF_RFE_FSG(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Clutch engaged

    pub fn set_KPL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffdffffff) | ((value as u64) & 0x1) << 25; }

    /// Gets Clutch engaged
    pub fn get_KPL(&self) -> bool { (self.0 >> 25 & 0x1) != 0 }
        
    /// Sets Line monitoring possible

    pub fn set_LTG_CHK_POS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffeffffff) | ((value as u64) & 0x1) << 24; }

    /// Gets Line monitoring possible
    pub fn get_LTG_CHK_POS(&self) -> bool { (self.0 >> 24 & 0x1) != 0 }
        
    /// Sets Gear selector lever position (NAG, KSG, CVT)

    pub fn set_WHST(&mut self, value: GW_C_B2_WHST){ self.0 = (self.0 & 0xffffffffff1fffff) | ((value as u64) & 0x7) << 21; }

    /// Gets Gear selector lever position (NAG, KSG, CVT)
    pub fn get_WHST(&self) -> std::result::Result<GW_C_B2_WHST, ()> { return GW_C_B2_WHST::try_from((self.0 >> 21 & 0x7) as u8) }
        
    /// Sets Set braking torque. Conversion formula (To raw from real): y=(x-0.0)/3.00 (Unit: Nm)

    pub fn set_MBRE_ESP(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffff000ff) | ((value as u64) & 0xfff) << 8; }

    /// Gets Set braking torque. Conversion formula (To real from raw): y=(3.00x)+0.0 (Unit: Nm)
    pub fn get_MBRE_ESP(&self) -> u16 { (self.0 >> 8 & 0xfff) as u16 }
        
    /// Sets Switch on auxiliary water pump

    pub fn set_ZWP_EIN_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffff7f) | ((value as u64) & 0x1) << 7; }

    /// Gets Switch on auxiliary water pump
    pub fn get_ZWP_EIN_MS(&self) -> bool { (self.0 >> 7 & 0x1) != 0 }
        
    /// Sets PTC auxiliary heater request off

    pub fn set_ZH_AUS_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffbf) | ((value as u64) & 0x1) << 6; }

    /// Gets PTC auxiliary heater request off
    pub fn get_ZH_AUS_MS(&self) -> bool { (self.0 >> 6 & 0x1) != 0 }
        
    /// Sets SBC-S/H active, ASG must not switch to "N".

    pub fn set_N_VRBT_SBCSH_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffdf) | ((value as u64) & 0x1) << 5; }

    /// Gets SBC-S/H active, ASG must not switch to "N".
    pub fn get_N_VRBT_SBCSH_AKT(&self) -> bool { (self.0 >> 5 & 0x1) != 0 }
        
    /// Sets emergency braking (brake light flashing)

    pub fn set_NOTBRE(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffef) | ((value as u64) & 0x1) << 4; }

    /// Gets emergency braking (brake light flashing)
    pub fn get_NOTBRE(&self) -> bool { (self.0 >> 4 & 0x1) != 0 }
        
    /// Sets Switch on additional consumers

    pub fn set_ZVB_EIN_MS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffff7) | ((value as u64) & 0x1) << 3; }

    /// Gets Switch on additional consumers
    pub fn get_ZVB_EIN_MS(&self) -> bool { (self.0 >> 3 & 0x1) != 0 }
        
    /// Sets Substitution of left low beam

    pub fn set_SUB_ABL_L(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffb) | ((value as u64) & 0x1) << 2; }

    /// Gets Substitution of left low beam
    pub fn get_SUB_ABL_L(&self) -> bool { (self.0 >> 2 & 0x1) != 0 }
        
    /// Sets Substitution of the low beam on the right

    pub fn set_SUB_ABL_R(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffd) | ((value as u64) & 0x1) << 1; }

    /// Gets Substitution of the low beam on the right
    pub fn get_SUB_ABL_R(&self) -> bool { (self.0 >> 1 & 0x1) != 0 }
        
    /// Sets Idle is stable

    pub fn set_LL_STBL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffe) | ((value as u64) & 0x1) << 0; }

    /// Gets Idle is stable
    pub fn get_LL_STBL(&self) -> bool { (self.0 >> 0 & 0x1) != 0 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B3(pub u64);

impl GW_C_B3 {

	/// Gets CAN ID of GW_C_B3
	pub const fn get_canid() -> u16 { GW_C_B3_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Transmission oil temperature. Conversion formula (To raw from real): y=(x+50.0)/1.00 (Unit: ¬∞C)

    pub fn set_T_GET(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Transmission oil temperature. Conversion formula (To real from raw): y=(1.00x)-50.0 (Unit: ¬∞C)
    pub fn get_T_GET(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To raw from real): y=(x+10.239999771118164)/0.08 (Unit: m/s¬≤)

    pub fn set_AY_S(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To real from raw): y=(0.08x)-10.239999771118164 (Unit: m/s¬≤)
    pub fn get_AY_S(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Acceleration type code (>100: more dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_BMI(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Acceleration type code (>100: more dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_BMI(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets code for lateral acceleration type (>100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_LMI(&mut self, value: u8){ self.0 = (self.0 & 0xffffff00ffffffff) | ((value as u64) & 0xff) << 32; }

    /// Gets code for lateral acceleration type (>100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_LMI(&self) -> u8 { (self.0 >> 32 & 0xff) as u8 }
        
    /// Sets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To raw from real): y=(x+327.67999267578125)/0.01 (Unit: ¬∞/s)

    pub fn set_GIER_ROH(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffff0000ff) | ((value as u64) & 0xffff) << 8; }

    /// Gets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To real from raw): y=(0.01x)-327.67999267578125 (Unit: ¬∞/s)
    pub fn get_GIER_ROH(&self) -> u16 { (self.0 >> 8 & 0xffff) as u16 }
        
    /// Sets EHB vehicle electrical system status

    pub fn set_EHB_BN(&mut self, value: GW_C_B3_EHB_BN){ self.0 = (self.0 & 0xffffffffffffff3f) | ((value as u64) & 0x3) << 6; }

    /// Gets EHB vehicle electrical system status
    pub fn get_EHB_BN(&self) -> std::result::Result<GW_C_B3_EHB_BN, ()> { return GW_C_B3_EHB_BN::try_from((self.0 >> 6 & 0x3) as u8) }
        
    /// Sets Heat output status

    pub fn set_HZL_ST(&mut self, value: GW_C_B3_HZL_ST){ self.0 = (self.0 & 0xffffffffffffffcf) | ((value as u64) & 0x3) << 4; }

    /// Gets Heat output status
    pub fn get_HZL_ST(&self) -> std::result::Result<GW_C_B3_HZL_ST, ()> { return GW_C_B3_HZL_ST::try_from((self.0 >> 4 & 0x3) as u8) }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B4(pub u64);

impl GW_C_B4 {

	/// Gets CAN ID of GW_C_B4
	pub const fn get_canid() -> u16 { GW_C_B4_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Presafe toggle bit

    pub fn set_PRESF_TGL(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Presafe toggle bit
    pub fn get_PRESF_TGL(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Presafe adjustment seat front right

    pub fn set_PRESF_R_SVR(&mut self, value: GW_C_B4_PRESF_R_SVR){ self.0 = (self.0 & 0xf3ffffffffffffff) | ((value as u64) & 0x3) << 58; }

    /// Gets Presafe adjustment seat front right
    pub fn get_PRESF_R_SVR(&self) -> std::result::Result<GW_C_B4_PRESF_R_SVR, ()> { return GW_C_B4_PRESF_R_SVR::try_from((self.0 >> 58 & 0x3) as u8) }
        
    /// Sets Presafe adjustment of the front left seat

    pub fn set_PRESF_L_SVL(&mut self, value: GW_C_B4_PRESF_L_SVL){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets Presafe adjustment of the front left seat
    pub fn get_PRESF_L_SVL(&self) -> std::result::Result<GW_C_B4_PRESF_L_SVL, ()> { return GW_C_B4_PRESF_L_SVL::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets Presafe adjustment window front right

    pub fn set_PRESF_R_FH(&mut self, value: GW_C_B4_PRESF_R_FH){ self.0 = (self.0 & 0xff3fffffffffffff) | ((value as u64) & 0x3) << 54; }

    /// Gets Presafe adjustment window front right
    pub fn get_PRESF_R_FH(&self) -> std::result::Result<GW_C_B4_PRESF_R_FH, ()> { return GW_C_B4_PRESF_R_FH::try_from((self.0 >> 54 & 0x3) as u8) }
        
    /// Sets Presafe adjustment window front left

    pub fn set_PRESF_L_FH(&mut self, value: GW_C_B4_PRESF_L_FH){ self.0 = (self.0 & 0xffcfffffffffffff) | ((value as u64) & 0x3) << 52; }

    /// Gets Presafe adjustment window front left
    pub fn get_PRESF_L_FH(&self) -> std::result::Result<GW_C_B4_PRESF_L_FH, ()> { return GW_C_B4_PRESF_L_FH::try_from((self.0 >> 52 & 0x3) as u8) }
        
    /// Sets Presafe sliding/tilting sunroof adjustment

    pub fn set_PRESF_R_SHD(&mut self, value: GW_C_B4_PRESF_R_SHD){ self.0 = (self.0 & 0xfff3ffffffffffff) | ((value as u64) & 0x3) << 50; }

    /// Gets Presafe sliding/tilting sunroof adjustment
    pub fn get_PRESF_R_SHD(&self) -> std::result::Result<GW_C_B4_PRESF_R_SHD, ()> { return GW_C_B4_PRESF_R_SHD::try_from((self.0 >> 50 & 0x3) as u8) }
        
    /// Sets Presafe sliding/tilting sunroof adjustment

    pub fn set_PRESF_L_SHD(&mut self, value: GW_C_B4_PRESF_L_SHD){ self.0 = (self.0 & 0xfffcffffffffffff) | ((value as u64) & 0x3) << 48; }

    /// Gets Presafe sliding/tilting sunroof adjustment
    pub fn get_PRESF_L_SHD(&self) -> std::result::Result<GW_C_B4_PRESF_L_SHD, ()> { return GW_C_B4_PRESF_L_SHD::try_from((self.0 >> 48 & 0x3) as u8) }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B5(pub u64);

impl GW_C_B5 {

	/// Gets CAN ID of GW_C_B5
	pub const fn get_canid() -> u16 { GW_C_B5_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse)

    pub fn set_RIZ_HL(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse)
    pub fn get_RIZ_HL(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00 (Unit: Impulse)

    pub fn set_RIZ_HR(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0 (Unit: Impulse)
    pub fn get_RIZ_HR(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Direction of rotation of rear wheel to the right

    pub fn set_DRTGHR(&mut self, value: GW_C_B5_DRTGHR){ self.0 = (self.0 & 0xffff3fffffffffff) | ((value as u64) & 0x3) << 46; }

    /// Gets Direction of rotation of rear wheel to the right
    pub fn get_DRTGHR(&self) -> std::result::Result<GW_C_B5_DRTGHR, ()> { return GW_C_B5_DRTGHR::try_from((self.0 >> 46 & 0x3) as u8) }
        
    /// Sets Rear right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min)

    pub fn set_DHR(&mut self, value: u16){ self.0 = (self.0 & 0xffffc000ffffffff) | ((value as u64) & 0x3fff) << 32; }

    /// Gets Rear right wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min)
    pub fn get_DHR(&self) -> u16 { (self.0 >> 32 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of rear left wheel

    pub fn set_DRTGHL(&mut self, value: GW_C_B5_DRTGHL){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Direction of rotation of rear left wheel
    pub fn get_DRTGHL(&self) -> std::result::Result<GW_C_B5_DRTGHL, ()> { return GW_C_B5_DRTGHL::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets Rear left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min)

    pub fn set_DHL(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffc000ffff) | ((value as u64) & 0x3fff) << 16; }

    /// Gets Rear left wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min)
    pub fn get_DHL(&self) -> u16 { (self.0 >> 16 & 0x3fff) as u16 }
        
    /// Sets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To raw from real): y=(x-0.0)/0.01

    pub fn set_FMMOTMAX(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff00ff) | ((value as u64) & 0xff) << 8; }

    /// Gets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To real from raw): y=(0.01x)+0.0
    pub fn get_FMMOTMAX(&self) -> u8 { (self.0 >> 8 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_C_B7(pub u64);

impl GW_C_B7 {

	/// Gets CAN ID of GW_C_B7
	pub const fn get_canid() -> u16 { GW_C_B7_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Direction of rotation of wheel, front right

    pub fn set_DRTGVR(&mut self, value: GW_C_B7_DRTGVR){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Direction of rotation of wheel, front right
    pub fn get_DRTGVR(&self) -> std::result::Result<GW_C_B7_DRTGVR, ()> { return GW_C_B7_DRTGVR::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets front right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/0.50 (Unit: 1/min)

    pub fn set_DVR(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffc000ffff) | ((value as u64) & 0x3fff) << 16; }

    /// Gets front right wheel speed. Conversion formula (To real from raw): y=(0.50x)+0.0 (Unit: 1/min)
    pub fn get_DVR(&self) -> u16 { (self.0 >> 16 & 0x3fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GW_D_B1(pub u64);

impl GW_D_B1 {

	/// Gets CAN ID of GW_D_B1
	pub const fn get_canid() -> u16 { GW_D_B1_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Authorization status: [0] not authorized, [1] authorized

    pub fn set_AUT_STAT(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets Authorization status: [0] not authorized, [1] authorized
    pub fn get_AUT_STAT(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets Alive message CP

    pub fn set_LIVE_CP(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets Alive message CP
    pub fn get_LIVE_CP(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
}