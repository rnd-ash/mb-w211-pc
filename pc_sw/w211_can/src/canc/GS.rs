
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'GS'
*/
    
pub const GS_218_CAN_ID: u16 = 0x0218;
pub const GS_338_CAN_ID: u16 = 0x0338;
pub const GS_418_CAN_ID: u16 = 0x0418;

/// target gear
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_218h_GZC {
	N = 0, // target gear "N"
	D1 = 1, // target gear "1"
	D2 = 2, // target gear "2"
	D3 = 3, // target gear "3"
	D4 = 4, // target gear "4"
	D5 = 5, // target gear "5"
	D6 = 6, // target gear "6"
	D7 = 7, // target gear "7"
	D_CVT = 8, // Target gear "continuously forward
	R_CVT = 9, // Target gear "continuously reverse"
	R3 = 10, // Target gear "R3"
	R = 11, // target gear "R"
	R2 = 12, // Target gear "R2"
	P = 13, // target gear "P"
	ABBRUCH = 14, // Circuit abort
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for GS_218h_GZC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::N),
			1 => Ok(Self::D1),
			2 => Ok(Self::D2),
			3 => Ok(Self::D3),
			4 => Ok(Self::D4),
			5 => Ok(Self::D5),
			6 => Ok(Self::D6),
			7 => Ok(Self::D7),
			8 => Ok(Self::D_CVT),
			9 => Ok(Self::R_CVT),
			10 => Ok(Self::R3),
			11 => Ok(Self::R),
			12 => Ok(Self::R2),
			13 => Ok(Self::P),
			14 => Ok(Self::ABBRUCH),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// actual gear
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_218h_GIC {
	N = 0, // actual gear "N"
	D1 = 1, // Actual gear "1"
	D2 = 2, // Actual gear "2"
	D3 = 3, // Actual gear "3"
	D4 = 4, // Actual gear "4"
	D5 = 5, // Actual gear "5"
	D6 = 6, // Actual gear "6"
	D7 = 7, // Actual gear "7"
	D_CVT = 8, // Istgang "continuously forward
	R_CVT = 9, // Actual gear "infinitely reverse"
	R3 = 10, // Actual gear "R3"
	R = 11, // Actual gear "R"
	R2 = 12, // Actual gear "R2"
	P = 13, // Actual gear "P"
	KRAFTFREI = 14, // Powerless
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for GS_218h_GIC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::N),
			1 => Ok(Self::D1),
			2 => Ok(Self::D2),
			3 => Ok(Self::D3),
			4 => Ok(Self::D4),
			5 => Ok(Self::D5),
			6 => Ok(Self::D6),
			7 => Ok(Self::D7),
			8 => Ok(Self::D_CVT),
			9 => Ok(Self::R_CVT),
			10 => Ok(Self::R3),
			11 => Ok(Self::R),
			12 => Ok(Self::R2),
			13 => Ok(Self::P),
			14 => Ok(Self::KRAFTFREI),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Driving program for AAD
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_218h_FPC_AAD {
	SPORT = 0, // Sports (default)
	KOMFORT = 1, // comfort
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for GS_218h_FPC_AAD {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::SPORT),
			1 => Ok(Self::KOMFORT),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Error check status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_218h_FEHLPRF_ST {
	WAIT = 0, // Error check not yet fully completed
	OK = 1, // Complete error check, result i. O.
	ERROR = 2, // Error detected, enter current environment data
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for GS_218h_FEHLPRF_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::WAIT),
			1 => Ok(Self::OK),
			2 => Ok(Self::ERROR),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// speed level
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_FSC {
	BLANK = 32, // Blank (" ")
	EINS = 49, // gear "1"
	ZWEI = 50, // gear "2"
	DREI = 51, // gear "3"
	VIER = 52, // gear "4"
	FUENF = 53, // gear "5"
	SECHS = 54, // gear "6"
	SIEBEN = 55, // gear "7"
	A = 65, // gear "A"
	D = 68, // gear "D"
	F = 70, // Error mark "F"
	N = 78, // gear "N"
	P = 80, // gear "P"
	R = 82, // gear "R"
	SNV = 255, // passive value
}

impl TryFrom<u8> for GS_418h_FSC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			32 => Ok(Self::BLANK),
			49 => Ok(Self::EINS),
			50 => Ok(Self::ZWEI),
			51 => Ok(Self::DREI),
			52 => Ok(Self::VIER),
			53 => Ok(Self::FUENF),
			54 => Ok(Self::SECHS),
			55 => Ok(Self::SIEBEN),
			65 => Ok(Self::A),
			68 => Ok(Self::D),
			70 => Ok(Self::F),
			78 => Ok(Self::N),
			80 => Ok(Self::P),
			82 => Ok(Self::R),
			255 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Driving program
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_FPC {
	C_MGFB_WT = 2, // "C", message "Transmission, apply parking brake!" with warning sound
	C_MGSNN = 3, // "C", message "Transmission, shift lever to N!"
	C_MGBB = 4, // "C", message "Transmission, apply brake!"
	C_MGGEA = 6, // "C" , message "Transmission, request gear again!"
	C_MGZSN = 7, // "C" , message "Gear, engage N to start!"
	A_MGFB_WT = 10, // "A", message "Transmission, apply parking brake!" with warning sound
	A_MGSNN = 11, // "A", message "Transmission, shift lever to N!"
	A_MGBB = 12, // "A", message "Transmission, apply brake!"
	A_MGGEA = 14, // "A" , message "Transmission, request gear again!"
	A_MGZSN = 15, // "A" , message "Gear, engage N to start!"
	S_MGFB_WT = 18, // "S", message "Transmission, apply parking brake!" with warning sound
	S_MGSNN = 19, // "S", message "Transmission, shift lever to N!"
	S_MGBB = 20, // "S", message "Transmission, apply brake!"
	S_MGGEA = 22, // "S" , message "Transmission, request gear again!"
	S_MGZSN = 23, // "S" , message "Gear, engage N to start!"
	HOCH = 24, // Shift recommendation "shift up"
	RUNTER = 25, // Shift recommendation "downshift"
	BLANK = 32, // " " (Blank)
	BLANK_MGN = 64, // " " (blank), message "Gear, engage N!"
	A = 65, // "A"
	C = 67, // "C"
	F = 70, // Error mark "F"
	M = 77, // "M"
	S = 83, // "S"
	W = 87, // "W"
	UNDERSCORE = 95, // "_" (underscore)
	BLANK_MGW = 96, // " " (blank), message "Transmission, visit workshop!"
	A_MGN = 97, // "A", message "Gear, engage N!"
	C_MGN = 99, // "C", message "Gear, engage N!"
	M_MGN = 109, // "M", message "Gear, engage N!"
	S_MGN = 115, // "S", message "Gear, engage N!"
	W_MGN = 119, // "W", message "Gear, engage N!"
	UNDERSCORE_MGN = 127, // "_" (underscore), message "Gear, engage N!"
	A_MGW = 129, // "A", message "Transmission, visit workshop!"
	C_MGW = 131, // "C", message "Transmission, visit workshop!"
	F_MGW = 134, // Error marking "F" , message "Transmission, visit workshop!"
	M_MGW = 141, // "M", message "Transmission, visit workshop!"
	S_MGW = 147, // "S", message "Transmission, visit workshop!"
	W_MGW = 151, // "W", message "Transmission, visit workshop!"
	UNDERSCORE_MGW = 159, // "_" (underscore), message "Transmission, visit workshop!"
	SNV = 255, // passive value
}

impl TryFrom<u8> for GS_418h_FPC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			2 => Ok(Self::C_MGFB_WT),
			3 => Ok(Self::C_MGSNN),
			4 => Ok(Self::C_MGBB),
			6 => Ok(Self::C_MGGEA),
			7 => Ok(Self::C_MGZSN),
			10 => Ok(Self::A_MGFB_WT),
			11 => Ok(Self::A_MGSNN),
			12 => Ok(Self::A_MGBB),
			14 => Ok(Self::A_MGGEA),
			15 => Ok(Self::A_MGZSN),
			18 => Ok(Self::S_MGFB_WT),
			19 => Ok(Self::S_MGSNN),
			20 => Ok(Self::S_MGBB),
			22 => Ok(Self::S_MGGEA),
			23 => Ok(Self::S_MGZSN),
			24 => Ok(Self::HOCH),
			25 => Ok(Self::RUNTER),
			32 => Ok(Self::BLANK),
			64 => Ok(Self::BLANK_MGN),
			65 => Ok(Self::A),
			67 => Ok(Self::C),
			70 => Ok(Self::F),
			77 => Ok(Self::M),
			83 => Ok(Self::S),
			87 => Ok(Self::W),
			95 => Ok(Self::UNDERSCORE),
			96 => Ok(Self::BLANK_MGW),
			97 => Ok(Self::A_MGN),
			99 => Ok(Self::C_MGN),
			109 => Ok(Self::M_MGN),
			115 => Ok(Self::S_MGN),
			119 => Ok(Self::W_MGN),
			127 => Ok(Self::UNDERSCORE_MGN),
			129 => Ok(Self::A_MGW),
			131 => Ok(Self::C_MGW),
			134 => Ok(Self::F_MGW),
			141 => Ok(Self::M_MGW),
			147 => Ok(Self::S_MGW),
			151 => Ok(Self::W_MGW),
			159 => Ok(Self::UNDERSCORE_MGW),
			255 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Transmission mechanical variant
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_MECH {
	GROSS = 0, // NAG, Big gear
	KLEIN = 1, // NAG, Small gear
	GROSS2 = 2, // NAG2, Large gear
	KLEIN2 = 3, // NAG2, Small gear
}

impl TryFrom<u8> for GS_418h_MECH {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::GROSS),
			1 => Ok(Self::KLEIN),
			2 => Ok(Self::GROSS2),
			3 => Ok(Self::KLEIN2),
			_ => Err(())
		}
	}
}
/// target gear
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_GZC {
	N = 0, // target gear "N"
	D1 = 1, // target gear "1"
	D2 = 2, // target gear "2"
	D3 = 3, // target gear "3"
	D4 = 4, // target gear "4"
	D5 = 5, // target gear "5"
	D6 = 6, // target gear "6"
	D7 = 7, // target gear "7"
	D_CVT = 8, // Target gear "continuously forward
	R_CVT = 9, // Target gear "continuously reverse"
	R3 = 10, // Target gear "R3"
	R = 11, // target gear "R"
	R2 = 12, // Target gear "R2"
	P = 13, // target gear "P"
	ABBRUCH = 14, // Circuit abort
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for GS_418h_GZC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::N),
			1 => Ok(Self::D1),
			2 => Ok(Self::D2),
			3 => Ok(Self::D3),
			4 => Ok(Self::D4),
			5 => Ok(Self::D5),
			6 => Ok(Self::D6),
			7 => Ok(Self::D7),
			8 => Ok(Self::D_CVT),
			9 => Ok(Self::R_CVT),
			10 => Ok(Self::R3),
			11 => Ok(Self::R),
			12 => Ok(Self::R2),
			13 => Ok(Self::P),
			14 => Ok(Self::ABBRUCH),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// actual gear
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_GIC {
	N = 0, // actual gear "N"
	D1 = 1, // Actual gear "1"
	D2 = 2, // Actual gear "2"
	D3 = 3, // Actual gear "3"
	D4 = 4, // Actual gear "4"
	D5 = 5, // Actual gear "5"
	D6 = 6, // Actual gear "6"
	D7 = 7, // Actual gear "7"
	D_CVT = 8, // Istgang "continuously forward
	R_CVT = 9, // Actual gear "infinitely reverse"
	R3 = 10, // Actual gear "R3"
	R = 11, // Actual gear "R"
	R2 = 12, // Actual gear "R2"
	P = 13, // Actual gear "P"
	KRAFTFREI = 14, // Powerless
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for GS_418h_GIC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::N),
			1 => Ok(Self::D1),
			2 => Ok(Self::D2),
			3 => Ok(Self::D3),
			4 => Ok(Self::D4),
			5 => Ok(Self::D5),
			6 => Ok(Self::D6),
			7 => Ok(Self::D7),
			8 => Ok(Self::D_CVT),
			9 => Ok(Self::R_CVT),
			10 => Ok(Self::R3),
			11 => Ok(Self::R),
			12 => Ok(Self::R2),
			13 => Ok(Self::P),
			14 => Ok(Self::KRAFTFREI),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Gear selector lever position (NAG, KSG, CVT)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum GS_418h_WHST {
	P = 0, // Gear selector lever in position "P"
	R = 1, // Gear selector lever in position "R"
	N = 2, // Gear selector lever in position "N"
	D = 4, // Gear selector lever in position "D"
	SNV = 7, // Signal not available
}

impl TryFrom<u8> for GS_418h_WHST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::P),
			1 => Ok(Self::R),
			2 => Ok(Self::N),
			4 => Ok(Self::D),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GS_218(pub u64);

impl GS_218 {

	/// Gets CAN ID of GS_218
	pub const fn get_canid() -> u16 { GS_218_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Motor torque req. Toggle 40ms +-10

    pub fn set_MTGL_EGS(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Motor torque req. Toggle 40ms +-10
    pub fn get_MTGL_EGS(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Engine torque request Min

    pub fn set_MMIN_EGS(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Engine torque request Min
    pub fn get_MMIN_EGS(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Engine torque request max

    pub fn set_MMAX_EGS(&mut self, value: bool){ self.0 = (self.0 & 0xdfffffffffffffff) | ((value as u64) & 0x1) << 61; }

    /// Gets Engine torque request max
    pub fn get_MMAX_EGS(&self) -> bool { (self.0 >> 61 & 0x1) != 0 }
        
    /// Sets Required. engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_EGS(&mut self, value: u16){ self.0 = (self.0 & 0xe000ffffffffffff) | ((value as u64) & 0x1fff) << 48; }

    /// Gets Required. engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_EGS(&self) -> u16 { (self.0 >> 48 & 0x1fff) as u16 }
        
    /// Sets target gear

    pub fn set_GZC(&mut self, value: GS_218h_GZC){ self.0 = (self.0 & 0xffff0fffffffffff) | ((value as u64) & 0xf) << 44; }

    /// Gets target gear
    pub fn get_GZC(&self) -> std::result::Result<GS_218h_GZC, ()> { return GS_218h_GZC::try_from((self.0 >> 44 & 0xf) as u8) }
        
    /// Sets actual gear

    pub fn set_GIC(&mut self, value: GS_218h_GIC){ self.0 = (self.0 & 0xfffff0ffffffffff) | ((value as u64) & 0xf) << 40; }

    /// Gets actual gear
    pub fn get_GIC(&self) -> std::result::Result<GS_218h_GIC, ()> { return GS_218h_GIC::try_from((self.0 >> 40 & 0xf) as u8) }
        
    /// Sets Cons. (converter lockup) clutch "slip"

    pub fn set_K_S_B(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Cons. (converter lockup) clutch "slip"
    pub fn get_K_S_B(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Best. (converter lockup) clutch "open"

    pub fn set_K_O_B(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Best. (converter lockup) clutch "open"
    pub fn get_K_O_B(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Best. (converter lockup) clutch "closed"

    pub fn set_K_G_B(&mut self, value: bool){ self.0 = (self.0 & 0xffffffdfffffffff) | ((value as u64) & 0x1) << 37; }

    /// Gets Best. (converter lockup) clutch "closed"
    pub fn get_K_G_B(&self) -> bool { (self.0 >> 37 & 0x1) != 0 }
        
    /// Sets Off-road gear

    pub fn set_G_G(&mut self, value: bool){ self.0 = (self.0 & 0xffffffefffffffff) | ((value as u64) & 0x1) << 36; }

    /// Gets Off-road gear
    pub fn get_G_G(&self) -> bool { (self.0 >> 36 & 0x1) != 0 }
        
    /// Sets basic switching program o.k.

    pub fn set_GSP_OK(&mut self, value: bool){ self.0 = (self.0 & 0xfffffff7ffffffff) | ((value as u64) & 0x1) << 35; }

    /// Gets basic switching program o.k.
    pub fn get_GSP_OK(&self) -> bool { (self.0 >> 35 & 0x1) != 0 }
        
    /// Sets Driving resistance high

    pub fn set_FW_HOCH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets Driving resistance high
    pub fn get_FW_HOCH(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets circuit

    pub fn set_SCHALT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets circuit
    pub fn get_SCHALT(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets manual shift mode

    pub fn set_HSM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets manual shift mode
    pub fn get_HSM(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets Transmission ok

    pub fn set_GET_OK(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets Transmission ok
    pub fn get_GET_OK(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Bang start

    pub fn set_KS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Bang start
    pub fn get_KS(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets start release

    pub fn set_ALF(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets start release
    pub fn get_ALF(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets GS in limp mode

    pub fn set_GS_NOTL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets GS in limp mode
    pub fn get_GS_NOTL(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets Transmission overtemperature

    pub fn set_UEHITZ_GET(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets Transmission overtemperature
    pub fn get_UEHITZ_GET(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets Kick down

    pub fn set_KD(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets Kick down
    pub fn get_KD(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Driving program for AAD

    pub fn set_FPC_AAD(&mut self, value: GS_218h_FPC_AAD){ self.0 = (self.0 & 0xfffffffffcffffff) | ((value as u64) & 0x3) << 24; }

    /// Gets Driving program for AAD
    pub fn get_FPC_AAD(&self) -> std::result::Result<GS_218h_FPC_AAD, ()> { return GS_218h_FPC_AAD::try_from((self.0 >> 24 & 0x3) as u8) }
        
    /// Sets Engine torque request parity (even parity)

    pub fn set_MPAR_EGS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffff7fffff) | ((value as u64) & 0x1) << 23; }

    /// Gets Engine torque request parity (even parity)
    pub fn get_MPAR_EGS(&self) -> bool { (self.0 >> 23 & 0x1) != 0 }
        
    /// Sets intervention mode/torque control

    pub fn set_DYN1_EGS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets intervention mode/torque control
    pub fn get_DYN1_EGS(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets intervention mode/torque control

    pub fn set_DYN0_AMR_EGS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffdfffff) | ((value as u64) & 0x1) << 21; }

    /// Gets intervention mode/torque control
    pub fn get_DYN0_AMR_EGS(&self) -> bool { (self.0 >> 21 & 0x1) != 0 }
        
    /// Sets Torque converter lockup clutch no load

    pub fn set_K_LSTFR(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffbffff) | ((value as u64) & 0x1) << 18; }

    /// Gets Torque converter lockup clutch no load
    pub fn get_K_LSTFR(&self) -> bool { (self.0 >> 18 & 0x1) != 0 }
        
    /// Sets MOT_NAUS confirmation bit

    pub fn set_MOT_NAUS_CNF(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffdffff) | ((value as u64) & 0x1) << 17; }

    /// Gets MOT_NAUS confirmation bit
    pub fn get_MOT_NAUS_CNF(&self) -> bool { (self.0 >> 17 & 0x1) != 0 }
        
    /// Sets engine emergency stop

    pub fn set_MOT_NAUS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffeffff) | ((value as u64) & 0x1) << 16; }

    /// Gets engine emergency stop
    pub fn get_MOT_NAUS(&self) -> bool { (self.0 >> 16 & 0x1) != 0 }
        
    /// Sets Creeping torque (FFh for EGS, CVT) or CALID/CVN. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_MKRIECH(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff00ff) | ((value as u64) & 0xff) << 8; }

    /// Gets Creeping torque (FFh for EGS, CVT) or CALID/CVN. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_MKRIECH(&self) -> u8 { (self.0 >> 8 & 0xff) as u8 }
        
    /// Sets Error check status

    pub fn set_FEHLPRF_ST(&mut self, value: GS_218h_FEHLPRF_ST){ self.0 = (self.0 & 0xffffffffffffff3f) | ((value as u64) & 0x3) << 6; }

    /// Gets Error check status
    pub fn get_FEHLPRF_ST(&self) -> std::result::Result<GS_218h_FEHLPRF_ST, ()> { return GS_218h_FEHLPRF_ST::try_from((self.0 >> 6 & 0x3) as u8) }
        
    /// Sets CALID/CVN transfer active

    pub fn set_CALID_CVN_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffdf) | ((value as u64) & 0x1) << 5; }

    /// Gets CALID/CVN transfer active
    pub fn get_CALID_CVN_AKT(&self) -> bool { (self.0 >> 5 & 0x1) != 0 }
        
    /// Sets Error number or counter for CALID/CVN transmission. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FEHLER(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffffe0) | ((value as u64) & 0x1f) << 0; }

    /// Gets Error number or counter for CALID/CVN transmission. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FEHLER(&self) -> u8 { (self.0 >> 0 & 0x1f) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GS_338(pub u64);

impl GS_338 {

	/// Gets CAN ID of GS_338
	pub const fn get_canid() -> u16 { GS_338_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Transmission output speed (only 463/461, otherwise FFFFh). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_NAB(&mut self, value: u16){ self.0 = (self.0 & 0x0000ffffffffffff) | ((value as u64) & 0xffff) << 48; }

    /// Gets Transmission output speed (only 463/461, otherwise FFFFh). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_NAB(&self) -> u16 { (self.0 >> 48 & 0xffff) as u16 }
        
    /// Sets Turbine speed (EGS52-NAG, VGS-NAG2). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_NTURBINE(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffff0000) | ((value as u64) & 0xffff) << 0; }

    /// Gets Turbine speed (EGS52-NAG, VGS-NAG2). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_NTURBINE(&self) -> u16 { (self.0 >> 0 & 0xffff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct GS_418(pub u64);

impl GS_418 {

	/// Gets CAN ID of GS_418
	pub const fn get_canid() -> u16 { GS_418_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets speed level

    pub fn set_FSC(&mut self, value: GS_418h_FSC){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets speed level
    pub fn get_FSC(&self) -> std::result::Result<GS_418h_FSC, ()> { return GS_418h_FSC::try_from((self.0 >> 56 & 0xff) as u8) }
        
    /// Sets Driving program

    pub fn set_FPC(&mut self, value: GS_418h_FPC){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Driving program
    pub fn get_FPC(&self) -> std::result::Result<GS_418h_FPC, ()> { return GS_418h_FPC::try_from((self.0 >> 48 & 0xff) as u8) }
        
    /// Sets Transmission oil temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_T_GET(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Transmission oil temperature. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_T_GET(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets all-wheel drive

    pub fn set_ALLRAD(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets all-wheel drive
    pub fn get_ALLRAD(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets front-wheel drive [1], rear-wheel drive [0]

    pub fn set_FRONT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets front-wheel drive [1], rear-wheel drive [0]
    pub fn get_FRONT(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets circuit

    pub fn set_SCHALT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffdfffffffff) | ((value as u64) & 0x1) << 37; }

    /// Gets circuit
    pub fn get_SCHALT(&self) -> bool { (self.0 >> 37 & 0x1) != 0 }
        
    /// Sets continuously variable transmission [1], stepped transmission [0]

    pub fn set_CVT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffefffffffff) | ((value as u64) & 0x1) << 36; }

    /// Gets continuously variable transmission [1], stepped transmission [0]
    pub fn get_CVT(&self) -> bool { (self.0 >> 36 & 0x1) != 0 }
        
    /// Sets Transmission mechanical variant

    pub fn set_MECH(&mut self, value: GS_418h_MECH){ self.0 = (self.0 & 0xfffffff3ffffffff) | ((value as u64) & 0x3) << 34; }

    /// Gets Transmission mechanical variant
    pub fn get_MECH(&self) -> std::result::Result<GS_418h_MECH, ()> { return GS_418h_MECH::try_from((self.0 >> 34 & 0x3) as u8) }
        
    /// Sets Apply the brake when switching on

    pub fn set_ESV_BRE(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets Apply the brake when switching on
    pub fn get_ESV_BRE(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets Kick down

    pub fn set_KD(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets Kick down
    pub fn get_KD(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets target gear

    pub fn set_GZC(&mut self, value: GS_418h_GZC){ self.0 = (self.0 & 0xffffffff0fffffff) | ((value as u64) & 0xf) << 28; }

    /// Gets target gear
    pub fn get_GZC(&self) -> std::result::Result<GS_418h_GZC, ()> { return GS_418h_GZC::try_from((self.0 >> 28 & 0xf) as u8) }
        
    /// Sets actual gear

    pub fn set_GIC(&mut self, value: GS_418h_GIC){ self.0 = (self.0 & 0xfffffffff0ffffff) | ((value as u64) & 0xf) << 24; }

    /// Gets actual gear
    pub fn get_GIC(&self) -> std::result::Result<GS_418h_GIC, ()> { return GS_418h_GIC::try_from((self.0 >> 24 & 0xf) as u8) }
        
    /// Sets Torque loss (FFh at KSG). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_VERL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Torque loss (FFh at KSG). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_VERL(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets Wheel torque parity factor (even parity)

    pub fn set_FMRADPAR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Wheel torque parity factor (even parity)
    pub fn get_FMRADPAR(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets Factor wheel torque toggle 40ms +-10

    pub fn set_FMRADTGL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets Factor wheel torque toggle 40ms +-10
    pub fn get_FMRADTGL(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets Gear selector lever position (NAG, KSG, CVT)

    pub fn set_WHST(&mut self, value: GS_418h_WHST){ self.0 = (self.0 & 0xffffffffffffc7ff) | ((value as u64) & 0x7) << 11; }

    /// Gets Gear selector lever position (NAG, KSG, CVT)
    pub fn get_WHST(&self) -> std::result::Result<GS_418h_WHST, ()> { return GS_418h_WHST::try_from((self.0 >> 11 & 0x7) as u8) }
        
    /// Sets Wheel torque factor (7FFh with KSG). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FMRAD(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffffff800) | ((value as u64) & 0x7ff) << 0; }

    /// Gets Wheel torque factor (7FFh with KSG). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FMRAD(&self) -> u16 { (self.0 >> 0 & 0x7ff) as u16 }
        
}