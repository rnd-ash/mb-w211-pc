
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ZGW'
*/
    
pub const ZGW_248_CAN_ID: u16 = 0x0248;
pub const ZGW_24C_CAN_ID: u16 = 0x024C;
pub const KLA_410_CAN_ID: u16 = 0x0410;
pub const DGR_65B_CAN_ID: u16 = 0x065B;
pub const CONFIG_6FF_CAN_ID: u16 = 0x06FF;

/// LF/ABC 2-position switch actuated
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_ST2_BET {
	NBET = 0, // Not operated (rocker and push push)
	UNBET_NDEF = 1, // Bottom Actuated (Rocker), Undefined (Push Push)
	OBBET_BET = 2, // Top Actuated (Rocker), Actuated (Push Push)
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for ZGW_248h_ST2_BET {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NBET),
			1 => Ok(Self::UNBET_NDEF),
			2 => Ok(Self::OBBET_BET),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// LF/ABC 3-position switch operated
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_ST3_BET {
	NBET = 0, // Not operated (rocker and push push)
	UNBET_NDEF = 1, // Bottom Actuated (Rocker), Undefined (Push Push)
	OBBET_BET = 2, // Top Actuated (Rocker), Actuated (Push Push)
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for ZGW_248h_ST3_BET {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NBET),
			1 => Ok(Self::UNBET_NDEF),
			2 => Ok(Self::OBBET_BET),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Trailer operation detected
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_ANH_ERK2 {
	KEIN = 0, // Trailer not recognized
	OK = 1, // Trailer detected
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for ZGW_248h_ANH_ERK2 {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::KEIN),
			1 => Ok(Self::OK),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// ESP on/off actuated
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_ESP_BET {
	NBET = 0, // Not operated (rocker and push push)
	AUS_BET = 1, // ESP off actuated (rocker), actuated (push push)
	EIN_NDEF = 2, // ESP on actuated (rocker), not defined (push push)
	SNV = 3, // No signal (rocker and push push)
}

impl TryFrom<u8> for ZGW_248h_ESP_BET {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NBET),
			1 => Ok(Self::AUS_BET),
			2 => Ok(Self::EIN_NDEF),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Passenger seat belt buckle
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_GS_BF {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for ZGW_248h_GS_BF {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::GS_OK),
			1 => Ok(Self::GS_NOK),
			2 => Ok(Self::GS_FEHLER),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Seat belt buckle driver
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_GS_F {
	GS_OK = 0, // Seat belt buckle inserted
	GS_NOK = 1, // Seat belt buckle not inserted
	GS_FEHLER = 2, // Seat belt buckle error
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for ZGW_248h_GS_F {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::GS_OK),
			1 => Ok(Self::GS_NOK),
			2 => Ok(Self::GS_FEHLER),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Occupant classification passenger
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_OC_BF {
	OC_0 = 0, // Occupant classification 0
	OC_1 = 1, // Occupant Classification 1
	OC_2 = 2, // Occupant classification 2
	OC_3 = 3, // Occupant classification 3
	OC_4 = 4, // Occupant classification 4
	OC_FEHLER = 6, // Error OC
	SNV = 7, // Signal not available
}

impl TryFrom<u8> for ZGW_248h_OC_BF {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OC_0),
			1 => Ok(Self::OC_1),
			2 => Ok(Self::OC_2),
			3 => Ok(Self::OC_3),
			4 => Ok(Self::OC_4),
			6 => Ok(Self::OC_FEHLER),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Parctronic operated completely on/off
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ZGW_248h_PTS_BET {
	NBET = 0, // Not activated
	NICHT_DEFINIERT = 1, // Unknown
	BET = 2, // Confirmed
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for ZGW_248h_PTS_BET {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NBET),
			1 => Ok(Self::NICHT_DEFINIERT),
			2 => Ok(Self::BET),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Switching characteristic shift DGR
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DGR_65Bh_SLV_DGR {
	SKL0 = 0, // Switching characteristic "0"
	SKL1 = 1, // Switching characteristic "1"
	SKL2 = 2, // Switching characteristic "2"
	SKL3 = 3, // Switching characteristic "3"
	SKL4 = 4, // Switching characteristic "4"
	SKL5 = 5, // Switching characteristic "5"
	SKL6 = 6, // Switching characteristic "6"
	SKL7 = 7, // Switching characteristic "7"
	SKL8 = 8, // Switching characteristic "8"
	SKL9 = 9, // Switching characteristic "9"
	SKL10 = 10, // Switching characteristic "10"
}

impl TryFrom<u8> for DGR_65Bh_SLV_DGR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::SKL0),
			1 => Ok(Self::SKL1),
			2 => Ok(Self::SKL2),
			3 => Ok(Self::SKL3),
			4 => Ok(Self::SKL4),
			5 => Ok(Self::SKL5),
			6 => Ok(Self::SKL6),
			7 => Ok(Self::SKL7),
			8 => Ok(Self::SKL8),
			9 => Ok(Self::SKL9),
			10 => Ok(Self::SKL10),
			_ => Err(())
		}
	}
}
/// Target gear upper limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DGR_65Bh_GMAX_DGR {
	PASSIV = 0, // passive value
	G1 = 1, // target gear, lower limit = 1
	G2 = 2, // target gear, lower limit = 2
	G3 = 3, // target gear, lower limit = 3
	G4 = 4, // Desired gear, lower limit = 4
	G5 = 5, // Desired gear, lower limit = 5
	G6 = 6, // Desired gear, lower limit = 6
	G7 = 7, // target gear, lower limit = 7
}

impl TryFrom<u8> for DGR_65Bh_GMAX_DGR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// Target gear lower limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DGR_65Bh_GMIN_DGR {
	PASSIV = 0, // passive value
	G1 = 1, // target gear, lower limit = 1
	G2 = 2, // target gear, lower limit = 2
	G3 = 3, // target gear, lower limit = 3
	G4 = 4, // Desired gear, lower limit = 4
	G5 = 5, // Desired gear, lower limit = 5
	G6 = 6, // Desired gear, lower limit = 6
	G7 = 7, // target gear, lower limit = 7
}

impl TryFrom<u8> for DGR_65Bh_GMIN_DGR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// Left Hand Drive/Right Hand Drive
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum CONFIG_6FFh_LL_RLC {
	NICHT_DEFINIERT = 0, // Unknown
	LL = 1, // Left hand drive
	RL = 2, // Right hand drive
	SNV = 3, // Code not available
}

impl TryFrom<u8> for CONFIG_6FFh_LL_RLC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NICHT_DEFINIERT),
			1 => Ok(Self::LL),
			2 => Ok(Self::RL),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// country code
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum CONFIG_6FFh_LDC {
	RDW = 0, // Rest of the world
	USA_CAN = 1, // USA/Canada
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Code not available
}

impl TryFrom<u8> for CONFIG_6FFh_LDC {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::RDW),
			1 => Ok(Self::USA_CAN),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// year
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum CONFIG_6FFh_VER_JAHR {
	JAHR00 = 0, // Year 0 (beginning of year 2000)
	JAHR01 = 1, // year 1
	JAHR29 = 29, // Year 29
	N_DEF = 30, // undefined
	SB = 31, // Start of series production
}

impl TryFrom<u8> for CONFIG_6FFh_VER_JAHR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::JAHR00),
			1 => Ok(Self::JAHR01),
			29 => Ok(Self::JAHR29),
			30 => Ok(Self::N_DEF),
			31 => Ok(Self::SB),
			_ => Err(())
		}
	}
}
/// Year of change
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum CONFIG_6FFh_VER_AE {
	AE1 = 0, // Change year "/1"
	AEX = 1, // Change year "/X"
	AE2 = 2, // Change year "/2"
	SB = 3, // Start of series production
}

impl TryFrom<u8> for CONFIG_6FFh_VER_AE {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AE1),
			1 => Ok(Self::AEX),
			2 => Ok(Self::AE2),
			3 => Ok(Self::SB),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ZGW_248(pub u64);

impl ZGW_248 {

	/// Gets CAN ID of ZGW_248
	pub const fn get_canid() -> u16 { ZGW_248_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Start Xenon4 diagnostic procedure passenger side

    pub fn set_DIAG_X4_B(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Start Xenon4 diagnostic procedure passenger side
    pub fn get_DIAG_X4_B(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Start Xenon4 diagnostic procedure driver's side

    pub fn set_DIAG_X4_F(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Start Xenon4 diagnostic procedure driver's side
    pub fn get_DIAG_X4_F(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Turn on low beam

    pub fn set_ABL_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets Turn on low beam
    pub fn get_ABL_EIN(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets LF/ABC 2-position switch actuated

    pub fn set_ST2_BET(&mut self, value: ZGW_248h_ST2_BET){ self.0 = (self.0 & 0xf3ffffffffffffff) | ((value as u64) & 0x3) << 58; }

    /// Gets LF/ABC 2-position switch actuated
    pub fn get_ST2_BET(&self) -> std::result::Result<ZGW_248h_ST2_BET, ()> { return ZGW_248h_ST2_BET::try_from((self.0 >> 58 & 0x3) as u8) }
        
    /// Sets LF/ABC 3-position switch operated

    pub fn set_ST3_BET(&mut self, value: ZGW_248h_ST3_BET){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets LF/ABC 3-position switch operated
    pub fn get_ST3_BET(&self) -> std::result::Result<ZGW_248h_ST3_BET, ()> { return ZGW_248h_ST3_BET::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets Vehicle electrical system warning: starter battery state of charge

    pub fn set_BN_SOCS(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets Vehicle electrical system warning: starter battery state of charge
    pub fn get_BN_SOCS(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Transmission selector lever position "P" detected

    pub fn set_GWHST_P_SAM(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets Transmission selector lever position "P" detected
    pub fn get_GWHST_P_SAM(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets Bonnet is up

    pub fn set_MOT_AUF(&mut self, value: bool){ self.0 = (self.0 & 0xffefffffffffffff) | ((value as u64) & 0x1) << 52; }

    /// Gets Bonnet is up
    pub fn get_MOT_AUF(&self) -> bool { (self.0 >> 52 & 0x1) != 0 }
        
    /// Sets AFL request: Turn on low beam

    pub fn set_AFL_ABL_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfff7ffffffffffff) | ((value as u64) & 0x1) << 51; }

    /// Gets AFL request: Turn on low beam
    pub fn get_AFL_ABL_EIN(&self) -> bool { (self.0 >> 51 & 0x1) != 0 }
        
    /// Sets Auxiliary water pump is running

    pub fn set_ZWP_LFT(&mut self, value: bool){ self.0 = (self.0 & 0xfffbffffffffffff) | ((value as u64) & 0x1) << 50; }

    /// Gets Auxiliary water pump is running
    pub fn get_ZWP_LFT(&self) -> bool { (self.0 >> 50 & 0x1) != 0 }
        
    /// Sets Trailer operation detected

    pub fn set_ANH_ERK2(&mut self, value: ZGW_248h_ANH_ERK2){ self.0 = (self.0 & 0xfffcffffffffffff) | ((value as u64) & 0x3) << 48; }

    /// Gets Trailer operation detected
    pub fn get_ANH_ERK2(&self) -> std::result::Result<ZGW_248h_ANH_ERK2, ()> { return ZGW_248h_ANH_ERK2::try_from((self.0 >> 48 & 0x3) as u8) }
        
    /// Sets SAM/x passive, x = Bb (230), V (211), F (240)

    pub fn set_SAM_PAS(&mut self, value: bool){ self.0 = (self.0 & 0xfffff7ffffffffff) | ((value as u64) & 0x1) << 43; }

    /// Gets SAM/x passive, x = Bb (230), V (211), F (240)
    pub fn get_SAM_PAS(&self) -> bool { (self.0 >> 43 & 0x1) != 0 }
        
    /// Sets SAM/x: EHB-ASG in fallback level, x = B (230), V (211,164,251), F (240)

    pub fn set_INF_RFE_SAM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffbffffffffff) | ((value as u64) & 0x1) << 42; }

    /// Gets SAM/x: EHB-ASG in fallback level, x = B (230), V (211,164,251), F (240)
    pub fn get_INF_RFE_SAM(&self) -> bool { (self.0 >> 42 & 0x1) != 0 }
        
    /// Sets SAM/x: v-signal from EHB-ASG, x = B (230), V (211), F ( 240)

    pub fn set_VSTAT_A(&mut self, value: bool){ self.0 = (self.0 & 0xfffffdffffffffff) | ((value as u64) & 0x1) << 41; }

    /// Gets SAM/x: v-signal from EHB-ASG, x = B (230), V (211), F ( 240)
    pub fn get_VSTAT_A(&self) -> bool { (self.0 >> 41 & 0x1) != 0 }
        
    /// Sets SAM/x: brake light switch output EHB-ASG, x = B (230), V (211), F (240)

    pub fn set_BLS_A(&mut self, value: bool){ self.0 = (self.0 & 0xfffffeffffffffff) | ((value as u64) & 0x1) << 40; }

    /// Gets SAM/x: brake light switch output EHB-ASG, x = B (230), V (211), F (240)
    pub fn get_BLS_A(&self) -> bool { (self.0 >> 40 & 0x1) != 0 }
        
    /// Sets Terminal 54 hardware active

    pub fn set_KL54_RM(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Terminal 54 hardware active
    pub fn get_KL54_RM(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Vehicle power supply emergency mode: Prio1 and Prio2 consumers off, second battery supports

    pub fn set_BN_NTLF(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Vehicle power supply emergency mode: Prio1 and Prio2 consumers off, second battery supports
    pub fn get_BN_NTLF(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets ESP on/off actuated

    pub fn set_ESP_BET(&mut self, value: ZGW_248h_ESP_BET){ self.0 = (self.0 & 0xffffffcfffffffff) | ((value as u64) & 0x3) << 36; }

    /// Gets ESP on/off actuated
    pub fn get_ESP_BET(&self) -> std::result::Result<ZGW_248h_ESP_BET, ()> { return ZGW_248h_ESP_BET::try_from((self.0 >> 36 & 0x3) as u8) }
        
    /// Sets Handbrake applied (indicator lamp)

    pub fn set_HAS_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffff7ffffffff) | ((value as u64) & 0x1) << 35; }

    /// Gets Handbrake applied (indicator lamp)
    pub fn get_HAS_KL(&self) -> bool { (self.0 >> 35 & 0x1) != 0 }
        
    /// Sets Wiper out of park position

    pub fn set_KL_31B(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets Wiper out of park position
    pub fn get_KL_31B(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets Onboard power supply control unit active

    pub fn set_BNS_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets Onboard power supply control unit active
    pub fn get_BNS_AKT(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets SBC added value: run-on active

    pub fn set_MW_AKT_SAM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets SBC added value: run-on active
    pub fn get_MW_AKT_SAM(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets Passenger seat belt buckle

    pub fn set_GS_BF(&mut self, value: ZGW_248h_GS_BF){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Passenger seat belt buckle
    pub fn get_GS_BF(&self) -> std::result::Result<ZGW_248h_GS_BF, ()> { return ZGW_248h_GS_BF::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets Seat belt buckle driver

    pub fn set_GS_F(&mut self, value: ZGW_248h_GS_F){ self.0 = (self.0 & 0xffffffffcfffffff) | ((value as u64) & 0x3) << 28; }

    /// Gets Seat belt buckle driver
    pub fn get_GS_F(&self) -> std::result::Result<ZGW_248h_GS_F, ()> { return ZGW_248h_GS_F::try_from((self.0 >> 28 & 0x3) as u8) }
        
    /// Sets Occupant classification passenger

    pub fn set_OC_BF(&mut self, value: ZGW_248h_OC_BF){ self.0 = (self.0 & 0xfffffffff8ffffff) | ((value as u64) & 0x7) << 24; }

    /// Gets Occupant classification passenger
    pub fn get_OC_BF(&self) -> std::result::Result<ZGW_248h_OC_BF, ()> { return ZGW_248h_OC_BF::try_from((self.0 >> 24 & 0x7) as u8) }
        
    /// Sets Kombi is value-added

    pub fn set_KOMBI_MW_OK(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffff7fffff) | ((value as u64) & 0x1) << 23; }

    /// Gets Kombi is value-added
    pub fn get_KOMBI_MW_OK(&self) -> bool { (self.0 >> 23 & 0x1) != 0 }
        
    /// Sets Parctronic operated completely on/off

    pub fn set_PTS_BET(&mut self, value: ZGW_248h_PTS_BET){ self.0 = (self.0 & 0xffffffffffcfffff) | ((value as u64) & 0x3) << 20; }

    /// Gets Parctronic operated completely on/off
    pub fn get_PTS_BET(&self) -> std::result::Result<ZGW_248h_PTS_BET, ()> { return ZGW_248h_PTS_BET::try_from((self.0 >> 20 & 0x3) as u8) }
        
    /// Sets Crash signal from airbag SG

    pub fn set_CRASH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffbffff) | ((value as u64) & 0x1) << 18; }

    /// Gets Crash signal from airbag SG
    pub fn get_CRASH(&self) -> bool { (self.0 >> 18 & 0x1) != 0 }
        
    /// Sets CRASH confirm bit

    pub fn set_CRASH_CNF(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffdffff) | ((value as u64) & 0x1) << 17; }

    /// Gets CRASH confirm bit
    pub fn get_CRASH_CNF(&self) -> bool { (self.0 >> 17 & 0x1) != 0 }
        
    /// Sets Any crash event

    pub fn set_X_CRASH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffeffff) | ((value as u64) & 0x1) << 16; }

    /// Gets Any crash event
    pub fn get_X_CRASH(&self) -> bool { (self.0 >> 16 & 0x1) != 0 }
        
    /// Sets ART available

    pub fn set_ART_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffff7f) | ((value as u64) & 0x1) << 7; }

    /// Gets ART available
    pub fn get_ART_VH(&self) -> bool { (self.0 >> 7 & 0x1) != 0 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ZGW_24C(pub u64);

impl ZGW_24C {

	/// Gets CAN ID of ZGW_24C
	pub const fn get_canid() -> u16 { ZGW_24C_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Low beam defective passenger/right (depending on BR)

    pub fn set_ABL_DEF_BF_R(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffdffffff) | ((value as u64) & 0x1) << 25; }

    /// Gets Low beam defective passenger/right (depending on BR)
    pub fn get_ABL_DEF_BF_R(&self) -> bool { (self.0 >> 25 & 0x1) != 0 }
        
    /// Sets Low beam defective driver/left (depending on BR)

    pub fn set_ABL_DEF_F_L(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffeffffff) | ((value as u64) & 0x1) << 24; }

    /// Gets Low beam defective driver/left (depending on BR)
    pub fn get_ABL_DEF_F_L(&self) -> bool { (self.0 >> 24 & 0x1) != 0 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct KLA_410(pub u64);

impl KLA_410 {

	/// Gets CAN ID of KLA_410
	pub const fn get_canid() -> u16 { KLA_410_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Activation of auxiliary heater permitted

    pub fn set_ZH_EIN_OK(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Activation of auxiliary heater permitted
    pub fn get_ZH_EIN_OK(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets No-load speed increase to increase cooling capacity

    pub fn set_LL_DZA(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets No-load speed increase to increase cooling capacity
    pub fn get_LL_DZA(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Air conditioning compressor switched on

    pub fn set_KOMP_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfeffffffffffffff) | ((value as u64) & 0x1) << 56; }

    /// Gets Air conditioning compressor switched on
    pub fn get_KOMP_EIN(&self) -> bool { (self.0 >> 56 & 0x1) != 0 }
        
    /// Sets refrigerant pressure. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_P_KAELTE8(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets refrigerant pressure. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_P_KAELTE8(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Torque absorption refrigeration compressor. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_KOMP(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Torque absorption refrigeration compressor. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_KOMP(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets Motor fan target speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_NLFTS(&mut self, value: u8){ self.0 = (self.0 & 0xffffff00ffffffff) | ((value as u64) & 0xff) << 32; }

    /// Gets Motor fan target speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_NLFTS(&self) -> u8 { (self.0 >> 32 & 0xff) as u8 }
        
    /// Sets Demand for additional heat output. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_ZH_ANF(&mut self, value: u8){ self.0 = (self.0 & 0xfffffffff1ffffff) | ((value as u64) & 0x7) << 25; }

    /// Gets Demand for additional heat output. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_ZH_ANF(&self) -> u8 { (self.0 >> 25 & 0x7) as u8 }
        
    /// Sets Outside air temperature for thermal management. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_T_AUSSEN_WM(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Outside air temperature for thermal management. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_T_AUSSEN_WM(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DGR_65B(pub u64);

impl DGR_65B {

	/// Gets CAN ID of DGR_65B
	pub const fn get_canid() -> u16 { DGR_65B_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Switching characteristic shift DGR

    pub fn set_SLV_DGR(&mut self, value: DGR_65Bh_SLV_DGR){ self.0 = (self.0 & 0x0fffffffffffffff) | ((value as u64) & 0xf) << 60; }

    /// Gets Switching characteristic shift DGR
    pub fn get_SLV_DGR(&self) -> std::result::Result<DGR_65Bh_SLV_DGR, ()> { return DGR_65Bh_SLV_DGR::try_from((self.0 >> 60 & 0xf) as u8) }
        
    /// Sets DGR OK

    pub fn set_DGR_OK(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets DGR OK
    pub fn get_DGR_OK(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
    /// Sets DGR brakes

    pub fn set_DGR_BRE(&mut self, value: bool){ self.0 = (self.0 & 0xfbffffffffffffff) | ((value as u64) & 0x1) << 58; }

    /// Gets DGR brakes
    pub fn get_DGR_BRE(&self) -> bool { (self.0 >> 58 & 0x1) != 0 }
        
    /// Sets suppression dyn. full power downshift

    pub fn set_DYN_UNT_DGR(&mut self, value: bool){ self.0 = (self.0 & 0xfeffffffffffffff) | ((value as u64) & 0x1) << 56; }

    /// Gets suppression dyn. full power downshift
    pub fn get_DYN_UNT_DGR(&self) -> bool { (self.0 >> 56 & 0x1) != 0 }
        
    /// Sets Torque request parity (even par.)

    pub fn set_MPAR_DGR(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets Torque request parity (even par.)
    pub fn get_MPAR_DGR(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Dynamic engine torque request

    pub fn set_MDYN_DGR(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets Dynamic engine torque request
    pub fn get_MDYN_DGR(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets Braking torque request parity (even par.)

    pub fn set_MBREPAR_DGR(&mut self, value: bool){ self.0 = (self.0 & 0xffefffffffffffff) | ((value as u64) & 0x1) << 52; }

    /// Gets Braking torque request parity (even par.)
    pub fn get_MBREPAR_DGR(&self) -> bool { (self.0 >> 52 & 0x1) != 0 }
        
    /// Sets Pre-filling of the braking system

    pub fn set_DGR_VF(&mut self, value: bool){ self.0 = (self.0 & 0xfff7ffffffffffff) | ((value as u64) & 0x1) << 51; }

    /// Gets Pre-filling of the braking system
    pub fn get_DGR_VF(&self) -> bool { (self.0 >> 51 & 0x1) != 0 }
        
    /// Sets DGR regulates

    pub fn set_DGR_REG(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets DGR regulates
    pub fn get_DGR_REG(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Required engine torque DGR. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_DGR(&mut self, value: u16){ self.0 = (self.0 & 0xffffe000ffffffff) | ((value as u64) & 0x1fff) << 32; }

    /// Gets Required engine torque DGR. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_DGR(&self) -> u16 { (self.0 >> 32 & 0x1fff) as u16 }
        
    /// Sets message counter DGR. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_BZ65Bh(&mut self, value: u8){ self.0 = (self.0 & 0xffffffff0fffffff) | ((value as u64) & 0xf) << 28; }

    /// Gets message counter DGR. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_BZ65Bh(&self) -> u8 { (self.0 >> 28 & 0xf) as u8 }
        
    /// Sets braking torque DGR (000h: passive value). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_MBRE_DGR(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffff000ffff) | ((value as u64) & 0xfff) << 16; }

    /// Gets braking torque DGR (000h: passive value). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_MBRE_DGR(&self) -> u16 { (self.0 >> 16 & 0xfff) as u16 }
        
    /// Sets DGR request "Active downshift"

    pub fn set_AKT_R_DGR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets DGR request "Active downshift"
    pub fn get_AKT_R_DGR(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets Target gear upper limit

    pub fn set_GMAX_DGR(&mut self, value: DGR_65Bh_GMAX_DGR){ self.0 = (self.0 & 0xffffffffffffc7ff) | ((value as u64) & 0x7) << 11; }

    /// Gets Target gear upper limit
    pub fn get_GMAX_DGR(&self) -> std::result::Result<DGR_65Bh_GMAX_DGR, ()> { return DGR_65Bh_GMAX_DGR::try_from((self.0 >> 11 & 0x7) as u8) }
        
    /// Sets Target gear lower limit

    pub fn set_GMIN_DGR(&mut self, value: DGR_65Bh_GMIN_DGR){ self.0 = (self.0 & 0xfffffffffffff8ff) | ((value as u64) & 0x7) << 8; }

    /// Gets Target gear lower limit
    pub fn get_GMIN_DGR(&self) -> std::result::Result<DGR_65Bh_GMIN_DGR, ()> { return DGR_65Bh_GMIN_DGR::try_from((self.0 >> 8 & 0x7) as u8) }
        
    /// Sets CRC checksum byte 1-7 according to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_CRC_DGR_65Bh(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff) << 0; }

    /// Gets CRC checksum byte 1-7 according to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_CRC_DGR_65Bh(&self) -> u8 { (self.0 >> 0 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct CONFIG_6FF(pub u64);

impl CONFIG_6FF {

	/// Gets CAN ID of CONFIG_6FF
	pub const fn get_canid() -> u16 { CONFIG_6FF_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets E-suction fan: basic ventilation off

    pub fn set_GBL_AUS(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets E-suction fan: basic ventilation off
    pub fn get_GBL_AUS(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Left Hand Drive/Right Hand Drive

    pub fn set_LL_RLC(&mut self, value: CONFIG_6FFh_LL_RLC){ self.0 = (self.0 & 0xf3ffffffffffffff) | ((value as u64) & 0x3) << 58; }

    /// Gets Left Hand Drive/Right Hand Drive
    pub fn get_LL_RLC(&self) -> std::result::Result<CONFIG_6FFh_LL_RLC, ()> { return CONFIG_6FFh_LL_RLC::try_from((self.0 >> 58 & 0x3) as u8) }
        
    /// Sets country code

    pub fn set_LDC(&mut self, value: CONFIG_6FFh_LDC){ self.0 = (self.0 & 0xfcffffffffffffff) | ((value as u64) & 0x3) << 56; }

    /// Gets country code
    pub fn get_LDC(&self) -> std::result::Result<CONFIG_6FFh_LDC, ()> { return CONFIG_6FFh_LDC::try_from((self.0 >> 56 & 0x3) as u8) }
        
    /// Sets Special Protection Guard B6/7

    pub fn set_GUARD_B6(&mut self, value: bool){ self.0 = (self.0 & 0xfffdffffffffffff) | ((value as u64) & 0x1) << 49; }

    /// Gets Special Protection Guard B6/7
    pub fn get_GUARD_B6(&self) -> bool { (self.0 >> 49 & 0x1) != 0 }
        
    /// Sets Special Protection Guard B4

    pub fn set_GUARD_B4(&mut self, value: bool){ self.0 = (self.0 & 0xfffeffffffffffff) | ((value as u64) & 0x1) << 48; }

    /// Gets Special Protection Guard B4
    pub fn get_GUARD_B4(&self) -> bool { (self.0 >> 48 & 0x1) != 0 }
        
    /// Sets year

    pub fn set_VER_JAHR(&mut self, value: CONFIG_6FFh_VER_JAHR){ self.0 = (self.0 & 0xffff83ffffffffff) | ((value as u64) & 0x1f) << 42; }

    /// Gets year
    pub fn get_VER_JAHR(&self) -> std::result::Result<CONFIG_6FFh_VER_JAHR, ()> { return CONFIG_6FFh_VER_JAHR::try_from((self.0 >> 42 & 0x1f) as u8) }
        
    /// Sets Year of change

    pub fn set_VER_AE(&mut self, value: CONFIG_6FFh_VER_AE){ self.0 = (self.0 & 0xfffffcffffffffff) | ((value as u64) & 0x3) << 40; }

    /// Gets Year of change
    pub fn get_VER_AE(&self) -> std::result::Result<CONFIG_6FFh_VER_AE, ()> { return CONFIG_6FFh_VER_AE::try_from((self.0 >> 40 & 0x3) as u8) }
        
    /// Sets air conditioning available

    pub fn set_KLA_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets air conditioning available
    pub fn get_KLA_VH(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets Braking cruise control present (in the SBC or RDU)

    pub fn set_TM_BRE_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets Braking cruise control present (in the SBC or RDU)
    pub fn get_TM_BRE_VH(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets ART available

    pub fn set_ART_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffff7ff) | ((value as u64) & 0x1) << 11; }

    /// Gets ART available
    pub fn get_ART_VH(&self) -> bool { (self.0 >> 11 & 0x1) != 0 }
        
    /// Sets Trailer hitch present

    pub fn set_AHK_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffbff) | ((value as u64) & 0x1) << 10; }

    /// Gets Trailer hitch present
    pub fn get_AHK_VH(&self) -> bool { (self.0 >> 10 & 0x1) != 0 }
        
    /// Sets Parking assistant available

    pub fn set_PAS_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffdff) | ((value as u64) & 0x1) << 9; }

    /// Gets Parking assistant available
    pub fn get_PAS_VH(&self) -> bool { (self.0 >> 9 & 0x1) != 0 }
        
    /// Sets distance assistant available

    pub fn set_AAS_VH(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffeff) | ((value as u64) & 0x1) << 8; }

    /// Gets distance assistant available
    pub fn get_AAS_VH(&self) -> bool { (self.0 >> 8 & 0x1) != 0 }
        
}