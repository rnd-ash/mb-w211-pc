
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'MS'
*/
    
pub const CNG_ANZ_CAN_ID: u16 = 0x0326;
pub const MS_210_CAN_ID: u16 = 0x0210;
pub const MS_212_CAN_ID: u16 = 0x0212;
pub const MS_268_CAN_ID: u16 = 0x0268;
pub const MS_2F3_CAN_ID: u16 = 0x02F3;
pub const MS_308_CAN_ID: u16 = 0x0308;
pub const MS_312_CAN_ID: u16 = 0x0312;
pub const AAD_580_CAN_ID: u16 = 0x0580;
pub const MS_608_CAN_ID: u16 = 0x0608;

/// Switching line shift MS
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_210h_SLV_MS {
	SKL0 = 0, // Switching characteristic "0"
	SKL1 = 1, // Switching characteristic "1"
	SKL2 = 2, // Switching characteristic "2"
	SKL3 = 3, // Switching characteristic "3"
	SKL4 = 4, // Switching characteristic "4"
	SKL5 = 5, // Switching characteristic "5"
	SKL6 = 6, // Switching characteristic "6"
	SKL7 = 7, // Switching characteristic "7"
	SKL8 = 8, // Switching characteristic "8"
	SKL9 = 9, // Switching characteristic "9"
	SKL10 = 10, // Switching characteristic "10"
}

impl TryFrom<u8> for MS_210h_SLV_MS {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::SKL0),
			1 => Ok(Self::SKL1),
			2 => Ok(Self::SKL2),
			3 => Ok(Self::SKL3),
			4 => Ok(Self::SKL4),
			5 => Ok(Self::SKL5),
			6 => Ok(Self::SKL6),
			7 => Ok(Self::SKL7),
			8 => Ok(Self::SKL8),
			9 => Ok(Self::SKL9),
			10 => Ok(Self::SKL10),
			_ => Err(())
		}
	}
}
/// target gear, upper limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_210h_GMAX_MS {
	PASSIV = 0, // passive value
	G1 = 1, // Target gear, upper limit = 1
	G2 = 2, // target gear, upper limit = 2
	G3 = 3, // target gear, upper limit = 3
	G4 = 4, // Target gear, upper limit = 4
	G5 = 5, // target gear, upper limit = 5
	G6 = 6, // target gear, upper limit = 6
	G7 = 7, // target gear, upper limit = 7
}

impl TryFrom<u8> for MS_210h_GMAX_MS {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// target gear, lower limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_210h_GMIN_MS {
	PASSIV = 0, // passive value
	G1 = 1, // target gear, lower limit = 1
	G2 = 2, // target gear, lower limit = 2
	G3 = 3, // target gear, lower limit = 3
	G4 = 4, // Desired gear, lower limit = 4
	G5 = 5, // Desired gear, lower limit = 5
	G6 = 6, // Desired gear, lower limit = 6
	G7 = 7, // target gear, lower limit = 7
}

impl TryFrom<u8> for MS_210h_GMIN_MS {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// Heat output status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_268h_HZL_ST {
	ZU = 0, // Heater shut-off valve is closed
	AUF = 1, // Heater shut-off valve is open
	TAKT = 2, // Heating shut-off valve is clocked
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for MS_268h_HZL_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::ZU),
			1 => Ok(Self::AUF),
			2 => Ok(Self::TAKT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Gear shift recommendation "actual"
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_2F3h_FSC_IST {
	BLANK = 32, // Blank (" ")
	EINS = 49, // gear "1"
	ZWEI = 50, // gear "2"
	DREI = 51, // gear "3"
	VIER = 52, // gear "4"
	FUENF = 53, // gear "5"
	SECHS = 54, // gear "6"
	SIEBEN = 55, // gear "7"
	A = 65, // gear "A"
	D = 68, // gear "D"
	F = 70, // Error mark "F"
	N = 78, // gear "N"
	P = 80, // gear "P"
	R = 82, // gear "R"
	SNV = 255, // passive value
}

impl TryFrom<u8> for MS_2F3h_FSC_IST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			32 => Ok(Self::BLANK),
			49 => Ok(Self::EINS),
			50 => Ok(Self::ZWEI),
			51 => Ok(Self::DREI),
			52 => Ok(Self::VIER),
			53 => Ok(Self::FUENF),
			54 => Ok(Self::SECHS),
			55 => Ok(Self::SIEBEN),
			65 => Ok(Self::A),
			68 => Ok(Self::D),
			70 => Ok(Self::F),
			78 => Ok(Self::N),
			80 => Ok(Self::P),
			82 => Ok(Self::R),
			255 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Gear shift recommendation "Target"
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_2F3h_FSC_SOLL {
	HOCH = 1, // "Shift up" / arrow
	RUNTER = 2, // "shift down" / arrow
	BLANK_OR_PAS = 32, // Blank (" ") / Passive
	EINS = 49, // gear "1"
	ZWEI = 50, // gear "2"
	DREI = 51, // gear "3"
	VIER = 52, // gear "4"
	FUENF = 53, // gear "5"
	SECHS = 54, // gear "6"
	SIEBEN = 55, // gear "7"
	A = 65, // gear "A"
	D = 68, // gear "D"
	F = 70, // Error mark "F"
	N = 78, // gear "N"
	P = 80, // gear "P"
	R = 82, // gear "R"
	SNV = 255, // passive value
}

impl TryFrom<u8> for MS_2F3h_FSC_SOLL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			1 => Ok(Self::HOCH),
			2 => Ok(Self::RUNTER),
			32 => Ok(Self::BLANK_OR_PAS),
			49 => Ok(Self::EINS),
			50 => Ok(Self::ZWEI),
			51 => Ok(Self::DREI),
			52 => Ok(Self::VIER),
			53 => Ok(Self::FUENF),
			54 => Ok(Self::SECHS),
			55 => Ok(Self::SIEBEN),
			65 => Ok(Self::A),
			68 => Ok(Self::D),
			70 => Ok(Self::F),
			78 => Ok(Self::N),
			80 => Ok(Self::P),
			82 => Ok(Self::R),
			255 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// vehicle code body
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_608h_FCOD_KAR {
	W = 0, // W - sedan (or G short BM1/3 for BR 463, G for 461)
	V = 1, // V - long sedan (or VF for BR 210/211, G long BM6 for BR 463)
	C = 2, // C - Coup√© (or VV for BR 210/211/220)
	S = 3, // S - T-model (or special protection B4 for BR W240, T for BR 245)
	A = 4, // A - convertible (or X for BR 164)
	R = 5, // R - Roadster (or special protection B4 for BR 210/211/220/V240)
	SS = 6, // SS - special protection B6/7 (or CL for BR 203)
	SNV = 7, // Code not available
}

impl TryFrom<u8> for MS_608h_FCOD_KAR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::W),
			1 => Ok(Self::V),
			2 => Ok(Self::C),
			3 => Ok(Self::S),
			4 => Ok(Self::A),
			5 => Ok(Self::R),
			6 => Ok(Self::SS),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// vehicle code series
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_608h_FCOD_BR {
	BR221 = 0, // BR 221 or BR 140
	BR129 = 1, // Class 129
	BR210 = 2, // BR 210 or BR 212
	BR202 = 3, // BR 202 or BR 204
	BR220 = 4, // Class 220
	BR170 = 5, // Class 170
	BR203 = 6, // Class 203
	BR168 = 7, // Class 168
	BR163 = 8, // Class 163
	BR208 = 9, // Class 208
	BR463 = 10, // Class 463
	BR215 = 11, // Class 215
	BR230 = 12, // Class 230
	BR211 = 13, // Class 211
	BR209 = 14, // Class 209
	BR461 = 15, // Class 461
	BR240 = 16, // Class 240
	BR251 = 17, // Class 251
	BR171 = 18, // Class 171
	BR164 = 19, // Class 164
	BR169 = 20, // BR 169 or BR 245
	BR199 = 21, // BR 199
	BR216 = 22, // Class 216
	BR219 = 23, // Class 219
	BR454 = 24, // BR 454 (z-car)
	NCV2 = 25, // NCV2
	VITO = 26, // V class/Vito
	SPRINTER = 27, // sprinters
	NCV3 = 28, // NCV3
	NCV1 = 29, // NCV1
	REST = 30, // all other BR
	SNV = 31, // Code not available
}

impl TryFrom<u8> for MS_608h_FCOD_BR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::BR221),
			1 => Ok(Self::BR129),
			2 => Ok(Self::BR210),
			3 => Ok(Self::BR202),
			4 => Ok(Self::BR220),
			5 => Ok(Self::BR170),
			6 => Ok(Self::BR203),
			7 => Ok(Self::BR168),
			8 => Ok(Self::BR163),
			9 => Ok(Self::BR208),
			10 => Ok(Self::BR463),
			11 => Ok(Self::BR215),
			12 => Ok(Self::BR230),
			13 => Ok(Self::BR211),
			14 => Ok(Self::BR209),
			15 => Ok(Self::BR461),
			16 => Ok(Self::BR240),
			17 => Ok(Self::BR251),
			18 => Ok(Self::BR171),
			19 => Ok(Self::BR164),
			20 => Ok(Self::BR169),
			21 => Ok(Self::BR199),
			22 => Ok(Self::BR216),
			23 => Ok(Self::BR219),
			24 => Ok(Self::BR454),
			25 => Ok(Self::NCV2),
			26 => Ok(Self::VITO),
			27 => Ok(Self::SPRINTER),
			28 => Ok(Self::NCV3),
			29 => Ok(Self::NCV1),
			30 => Ok(Self::REST),
			31 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Vehicle code motor 7-bit, bit0-5 (bit6--> signal FCOD_MOT6)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_608h_FCOD_MOT {
	M272E35 = 0, // M272 E35
	M271E18ML105 = 1, // M271 E18 ML red. (105kW)
	M271E18ML120 = 2, // M271 E18ML (120kW)
	M112E37 = 3, // M112 E37
	M272E25 = 4, // M272 E25
	M272E30 = 5, // M272 E30
	M112E28 = 7, // M112 E28
	M112E32 = 8, // M112 E32
	M273E46 = 10, // M273 E46
	M273E55 = 11, // M273 E55
	M112E26 = 12, // M112 E26
	M113E43 = 13, // M113 E43
	M113E50 = 14, // M113 E50
	M271E18ML140 = 18, // M271 E18 ML/1 (140 kW)
	M271DE18ML105 = 19, // M271 DE18 ML red. (105kW)
	M271DE18ML125 = 20, // M271 DE18ML (125kW)
	M111E_E23ML = 22, // M111E E23 ML
	M111E_E20 = 23, // M111E E20
	M111E_E20ML = 24, // M111E E20ML
	M112E32_140 = 25, // M112 E32 red. (140kW)
	M266E20ATL = 26, // M266 E20 ATL
	M266E15 = 27, // M266 E15
	M266E17 = 28, // M266 E17
	M266E20 = 29, // M266 E20
	M275E55 = 30, // M275 E55 or M285 E55
	M137E58 = 31, // M137 E58
	OM640DE20LA60 = 32, // OM 640 DE20 LA (60 kW)
	OM640DE20LA80 = 34, // OM 640 DE20 LA (80 kW)
	OM642DE30LA160 = 35, // OM642 DE30 LA (155/160 kW)
	OM640DE20LA100 = 36, // OM 640 DE20 LA (100 kW)
	OM613DE32LA = 37, // OM613 DE32 LA or OM648 DE32 LA
	OM639DE15LA = 38, // OM 639 DE15 LA (70/50 kW)
	OM628DE40LA = 39, // OM628 DE40 LA
	OM642DE30LA140 = 40, // OM642 DE30 LA (140kW)
	OM612DE27LA = 43, // OM612 DE27 LA or OM647 DE27 LA (120/130 kW)
	OM611DE22LA100 = 44, // OM611 DE22 LA (105/100 kW) or OM646 DE22 LA (100/105/110 kW)
	OM611DE22LA85 = 45, // OM611 DE22 LA (85 kW) or OM646 DE22 LA (90 kW)
	OM611DE22LA75 = 46, // OM611 DE22 LA (75 kW) or OM646 DE22 LA (75 kW)
	M134E11 = 64, // M134 E11 (3A91)
	M135E13 = 65, // M135 E13 (4A90)
	M135E15 = 66, // M135 E15 (4A91)
	M135E15ATL = 67, // M135 E15ATL
	M272DE25 = 68, // M272 DE25
	M272DE30 = 69, // M272 DE30
	M272DE35 = 70, // M272 DE35
	M273DE46 = 71, // M273 DE46
	M273DE55 = 72, // M273 DE55
	M271E18MLATTR115 = 79, // M271 E18 ML Attr. (115kW)
	M271E18MLATTR141 = 80, // M271 E18 ML Attr. (141kW)
	OM629DE40LA = 96, // OM629 DE40 LA
	OM646DE22EVO120 = 97, // OM646 DE22 EVO (120/125kW)
	OM646DE22LAEVO100 = 98, // OM646 DE22 LA EVO (100kW)
	OM642DE30LARED140 = 99, // OM642 DE30 LA red. (140kW)
}

impl TryFrom<u8> for MS_608h_FCOD_MOT {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::M272E35),
			1 => Ok(Self::M271E18ML105),
			2 => Ok(Self::M271E18ML120),
			3 => Ok(Self::M112E37),
			4 => Ok(Self::M272E25),
			5 => Ok(Self::M272E30),
			7 => Ok(Self::M112E28),
			8 => Ok(Self::M112E32),
			10 => Ok(Self::M273E46),
			11 => Ok(Self::M273E55),
			12 => Ok(Self::M112E26),
			13 => Ok(Self::M113E43),
			14 => Ok(Self::M113E50),
			18 => Ok(Self::M271E18ML140),
			19 => Ok(Self::M271DE18ML105),
			20 => Ok(Self::M271DE18ML125),
			22 => Ok(Self::M111E_E23ML),
			23 => Ok(Self::M111E_E20),
			24 => Ok(Self::M111E_E20ML),
			25 => Ok(Self::M112E32_140),
			26 => Ok(Self::M266E20ATL),
			27 => Ok(Self::M266E15),
			28 => Ok(Self::M266E17),
			29 => Ok(Self::M266E20),
			30 => Ok(Self::M275E55),
			31 => Ok(Self::M137E58),
			32 => Ok(Self::OM640DE20LA60),
			34 => Ok(Self::OM640DE20LA80),
			35 => Ok(Self::OM642DE30LA160),
			36 => Ok(Self::OM640DE20LA100),
			37 => Ok(Self::OM613DE32LA),
			38 => Ok(Self::OM639DE15LA),
			39 => Ok(Self::OM628DE40LA),
			40 => Ok(Self::OM642DE30LA140),
			43 => Ok(Self::OM612DE27LA),
			44 => Ok(Self::OM611DE22LA100),
			45 => Ok(Self::OM611DE22LA85),
			46 => Ok(Self::OM611DE22LA75),
			64 => Ok(Self::M134E11),
			65 => Ok(Self::M135E13),
			66 => Ok(Self::M135E15),
			67 => Ok(Self::M135E15ATL),
			68 => Ok(Self::M272DE25),
			69 => Ok(Self::M272DE30),
			70 => Ok(Self::M272DE35),
			71 => Ok(Self::M273DE46),
			72 => Ok(Self::M273DE55),
			79 => Ok(Self::M271E18MLATTR115),
			80 => Ok(Self::M271E18MLATTR141),
			96 => Ok(Self::OM629DE40LA),
			97 => Ok(Self::OM646DE22EVO120),
			98 => Ok(Self::OM646DE22LAEVO100),
			99 => Ok(Self::OM642DE30LARED140),
			_ => Err(())
		}
	}
}
/// Particulate filter warning
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum MS_608h_PFW {
	OK = 0, // No warning
	PFW1 = 1, // Filter closed warning, level 1
	PFW2 = 2, // Filter closed warning, level 2
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for MS_608h_PFW {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::PFW1),
			2 => Ok(Self::PFW2),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct CNG_ANZ(pub u64);

impl CNG_ANZ {

	/// Gets CAN ID of CNG_ANZ
	pub const fn get_canid() -> u16 { CNG_ANZ_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Natural gas tank level. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_TANK_FS_GAS(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Natural gas tank level. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_TANK_FS_GAS(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Confirmation of operating mode changeover

    pub fn set_BTRBSART_UMSCH_BEST(&mut self, value: bool){ self.0 = (self.0 & 0xffdfffffffffffff) | ((value as u64) & 0x1) << 53; }

    /// Gets Confirmation of operating mode changeover
    pub fn get_BTRBSART_UMSCH_BEST(&self) -> bool { (self.0 >> 53 & 0x1) != 0 }
        
    /// Sets operating mode

    pub fn set_BTRBSART(&mut self, value: bool){ self.0 = (self.0 & 0xffefffffffffffff) | ((value as u64) & 0x1) << 52; }

    /// Gets operating mode
    pub fn get_BTRBSART(&self) -> bool { (self.0 >> 52 & 0x1) != 0 }
        
    /// Sets Natural gas tank cap open warning lamp

    pub fn set_TANK_KL_GAS(&mut self, value: bool){ self.0 = (self.0 & 0xfffdffffffffffff) | ((value as u64) & 0x1) << 49; }

    /// Gets Natural gas tank cap open warning lamp
    pub fn get_TANK_KL_GAS(&self) -> bool { (self.0 >> 49 & 0x1) != 0 }
        
    /// Sets Tank fill level minimum natural gas

    pub fn set_TFSM_GAS(&mut self, value: bool){ self.0 = (self.0 & 0xfffeffffffffffff) | ((value as u64) & 0x1) << 48; }

    /// Gets Tank fill level minimum natural gas
    pub fn get_TFSM_GAS(&self) -> bool { (self.0 >> 48 & 0x1) != 0 }
        
    /// Sets Message ""

    pub fn set_CNG_M8(&mut self, value: bool){ self.0 = (self.0 & 0xffff7fffffffffff) | ((value as u64) & 0x1) << 47; }

    /// Gets Message ""
    pub fn get_CNG_M8(&self) -> bool { (self.0 >> 47 & 0x1) != 0 }
        
    /// Sets Message ""

    pub fn set_CNG_M7(&mut self, value: bool){ self.0 = (self.0 & 0xffffbfffffffffff) | ((value as u64) & 0x1) << 46; }

    /// Gets Message ""
    pub fn get_CNG_M7(&self) -> bool { (self.0 >> 46 & 0x1) != 0 }
        
    /// Sets Message ""

    pub fn set_CNG_M6(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets Message ""
    pub fn get_CNG_M6(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Message ""

    pub fn set_CNG_M5(&mut self, value: bool){ self.0 = (self.0 & 0xffffefffffffffff) | ((value as u64) & 0x1) << 44; }

    /// Gets Message ""
    pub fn get_CNG_M5(&self) -> bool { (self.0 >> 44 & 0x1) != 0 }
        
    /// Sets Message "Gasoline mode prohibited due to malfunction"

    pub fn set_CNG_M4(&mut self, value: bool){ self.0 = (self.0 & 0xfffff7ffffffffff) | ((value as u64) & 0x1) << 43; }

    /// Gets Message "Gasoline mode prohibited due to malfunction"
    pub fn get_CNG_M4(&self) -> bool { (self.0 >> 43 & 0x1) != 0 }
        
    /// Sets Message "Gasoline mode prohibited due to level too low"

    pub fn set_CNG_M3(&mut self, value: bool){ self.0 = (self.0 & 0xfffffbffffffffff) | ((value as u64) & 0x1) << 42; }

    /// Gets Message "Gasoline mode prohibited due to level too low"
    pub fn get_CNG_M3(&self) -> bool { (self.0 >> 42 & 0x1) != 0 }
        
    /// Sets Message "Prohibited natural gas operating mode due to malfunction"

    pub fn set_CNG_M2(&mut self, value: bool){ self.0 = (self.0 & 0xfffffdffffffffff) | ((value as u64) & 0x1) << 41; }

    /// Gets Message "Prohibited natural gas operating mode due to malfunction"
    pub fn get_CNG_M2(&self) -> bool { (self.0 >> 41 & 0x1) != 0 }
        
    /// Sets Message "Prohibited natural gas mode due to level too low"

    pub fn set_CNG_M1(&mut self, value: bool){ self.0 = (self.0 & 0xfffffeffffffffff) | ((value as u64) & 0x1) << 40; }

    /// Gets Message "Prohibited natural gas mode due to level too low"
    pub fn get_CNG_M1(&self) -> bool { (self.0 >> 40 & 0x1) != 0 }
        
    /// Sets High pressure CNG. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_P_CNG(&mut self, value: u8){ self.0 = (self.0 & 0xffffff00ffffffff) | ((value as u64) & 0xff) << 32; }

    /// Gets High pressure CNG. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_P_CNG(&self) -> u8 { (self.0 >> 32 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_210(pub u64);

impl MS_210 {

	/// Gets CAN ID of MS_210
	pub const fn get_canid() -> u16 { MS_210_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets A/C compressor emergency shutdown

    pub fn set_KOMP_NOTAUS(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets A/C compressor emergency shutdown
    pub fn get_KOMP_NOTAUS(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Switching line shift MS

    pub fn set_SLV_MS(&mut self, value: MS_210h_SLV_MS){ self.0 = (self.0 & 0x87ffffffffffffff) | ((value as u64) & 0xf) << 59; }

    /// Gets Switching line shift MS
    pub fn get_SLV_MS(&self) -> Option<MS_210h_SLV_MS> {  MS_210h_SLV_MS::try_from((self.0 >> 59 & 0xf) as u8).ok() }
        
    /// Sets Turn off KSG creep

    pub fn set_KRIECH_AUS(&mut self, value: bool){ self.0 = (self.0 & 0xfdffffffffffffff) | ((value as u64) & 0x1) << 57; }

    /// Gets Turn off KSG creep
    pub fn get_KRIECH_AUS(&self) -> bool { (self.0 >> 57 & 0x1) != 0 }
        
    /// Sets MS request: "Start in 1st gear"

    pub fn set_ANF1(&mut self, value: bool){ self.0 = (self.0 & 0xfeffffffffffffff) | ((value as u64) & 0x1) << 56; }

    /// Gets MS request: "Start in 1st gear"
    pub fn get_ANF1(&self) -> bool { (self.0 >> 56 & 0x1) != 0 }
        
    /// Sets MS request: "Active downshift"

    pub fn set_AKT_R_MS(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets MS request: "Active downshift"
    pub fn get_AKT_R_MS(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Switch off auxiliary heater

    pub fn set_ZH_AUS_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets Switch off auxiliary heater
    pub fn get_ZH_AUS_MS(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets target gear, upper limit

    pub fn set_GMAX_MS(&mut self, value: MS_210h_GMAX_MS){ self.0 = (self.0 & 0xffc7ffffffffffff) | ((value as u64) & 0x7) << 51; }

    /// Gets target gear, upper limit
    pub fn get_GMAX_MS(&self) -> Option<MS_210h_GMAX_MS> {  MS_210h_GMAX_MS::try_from((self.0 >> 51 & 0x7) as u8).ok() }
        
    /// Sets target gear, lower limit

    pub fn set_GMIN_MS(&mut self, value: MS_210h_GMIN_MS){ self.0 = (self.0 & 0xfff8ffffffffffff) | ((value as u64) & 0x7) << 48; }

    /// Gets target gear, lower limit
    pub fn get_GMIN_MS(&self) -> Option<MS_210h_GMIN_MS> {  MS_210h_GMIN_MS::try_from((self.0 >> 48 & 0x7) as u8).ok() }
        
    /// Sets pedal value. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_PW(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets pedal value. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_PW(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets Retrigger minimum display time

    pub fn set_V_DSPL_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Retrigger minimum display time
    pub fn get_V_DSPL_NEU(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Idle is stable

    pub fn set_LL_STBL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Idle is stable
    pub fn get_LL_STBL(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Preheat status

    pub fn set_VGL_ST(&mut self, value: bool){ self.0 = (self.0 & 0xffffffdfffffffff) | ((value as u64) & 0x1) << 37; }

    /// Gets Preheat status
    pub fn get_VGL_ST(&self) -> bool { (self.0 >> 37 & 0x1) != 0 }
        
    /// Sets Engine start/stop system defective

    pub fn set_MSS_DEF(&mut self, value: bool){ self.0 = (self.0 & 0xffffffefffffffff) | ((value as u64) & 0x1) << 36; }

    /// Gets Engine start/stop system defective
    pub fn get_MSS_DEF(&self) -> bool { (self.0 >> 36 & 0x1) != 0 }
        
    /// Sets Engine start/stop system control lamp

    pub fn set_MSS_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffff7ffffffff) | ((value as u64) & 0x1) << 35; }

    /// Gets Engine start/stop system control lamp
    pub fn get_MSS_KL(&self) -> bool { (self.0 >> 35 & 0x1) != 0 }
        
    /// Sets Engine start/stop system active

    pub fn set_MSS_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets Engine start/stop system active
    pub fn get_MSS_AKT(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets Switch off air conditioning compressor: Acceleration

    pub fn set_KOMP_BAUS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets Switch off air conditioning compressor: Acceleration
    pub fn get_KOMP_BAUS(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets Crash signal from engine control

    pub fn set_CRASH_MS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets Crash signal from engine control
    pub fn get_CRASH_MS(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets Pedal position sensor error

    pub fn set_PWG_ERR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets Pedal position sensor error
    pub fn get_PWG_ERR(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets idle

    pub fn set_LL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets idle
    pub fn get_LL(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets start Torque converter lock-up clutch "slipping"

    pub fn set_KUEB_S_A(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets start Torque converter lock-up clutch "slipping"
    pub fn get_KUEB_S_A(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets Cruise control regulates

    pub fn set_TM_REG(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets Cruise control regulates
    pub fn get_TM_REG(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets Speed ‚Äã‚Äãlimit switched on

    pub fn set_V_MAX_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets Speed ‚Äã‚Äãlimit switched on
    pub fn get_V_MAX_EIN(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets Kickdown (conversion scenario open!)

    pub fn set_KD_MS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets Kickdown (conversion scenario open!)
    pub fn get_KD_MS(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Emergency mode

    pub fn set_NOTL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffdffffff) | ((value as u64) & 0x1) << 25; }

    /// Gets Emergency mode
    pub fn get_NOTL(&self) -> bool { (self.0 >> 25 & 0x1) != 0 }
        
    /// Sets Warning buzzer on

    pub fn set_V_MAX_SUM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffeffffff) | ((value as u64) & 0x1) << 24; }

    /// Gets Warning buzzer on
    pub fn get_V_MAX_SUM(&self) -> bool { (self.0 >> 24 & 0x1) != 0 }
        
    /// Sets FBStartError

    pub fn set_FBS_SE(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffff7fffff) | ((value as u64) & 0x1) << 23; }

    /// Gets FBStartError
    pub fn get_FBS_SE(&self) -> bool { (self.0 >> 23 & 0x1) != 0 }
        
    /// Sets "Winter tire limit reached" message on the display

    pub fn set_V_DSPL_PGB(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets "Winter tire limit reached" message on the display
    pub fn get_V_DSPL_PGB(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets Cruise control on

    pub fn set_TM_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffdfffff) | ((value as u64) & 0x1) << 21; }

    /// Gets Cruise control on
    pub fn get_TM_EIN(&self) -> bool { (self.0 >> 21 & 0x1) != 0 }
        
    /// Sets Speed ‚Äã‚Äãlimiter controls

    pub fn set_V_MAX_REG(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffefffff) | ((value as u64) & 0x1) << 20; }

    /// Gets Speed ‚Äã‚Äãlimiter controls
    pub fn get_V_MAX_REG(&self) -> bool { (self.0 >> 20 & 0x1) != 0 }
        
    /// Sets Display "Limit ?" on the screen

    pub fn set_V_DSPL_LIM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffff7ffff) | ((value as u64) & 0x1) << 19; }

    /// Gets Display "Limit ?" on the screen
    pub fn get_V_DSPL_LIM(&self) -> bool { (self.0 >> 19 & 0x1) != 0 }
        
    /// Sets "Error" message on the display

    pub fn set_V_DSPL_ERR(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffbffff) | ((value as u64) & 0x1) << 18; }

    /// Gets "Error" message on the display
    pub fn get_V_DSPL_ERR(&self) -> bool { (self.0 >> 18 & 0x1) != 0 }
        
    /// Sets Display flashes

    pub fn set_V_DSPL_BL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffdffff) | ((value as u64) & 0x1) << 17; }

    /// Gets Display flashes
    pub fn get_V_DSPL_BL(&self) -> bool { (self.0 >> 17 & 0x1) != 0 }
        
    /// Sets Speed ‚Äã‚ÄãLimiter/Cruise Control Display On

    pub fn set_V_DSPL_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffeffff) | ((value as u64) & 0x1) << 16; }

    /// Gets Speed ‚Äã‚ÄãLimiter/Cruise Control Display On
    pub fn get_V_DSPL_EIN(&self) -> bool { (self.0 >> 16 & 0x1) != 0 }
        
    /// Sets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FMMOTMAX(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff00ff) | ((value as u64) & 0xff) << 8; }

    /// Gets factor for devaluation. i.e. max. torque at detach. A.print. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FMMOTMAX(&self) -> u8 { (self.0 >> 8 & 0xff) as u8 }
        
    /// Sets Set maximum or cruise control speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_V_MAX_TM(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff); }

    /// Gets Set maximum or cruise control speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_V_MAX_TM(&self) -> u8 { (self.0 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_212(pub u64);

impl MS_212 {

	/// Gets CAN ID of MS_212
	pub const fn get_canid() -> u16 { MS_212_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Engine idle target speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_NMOTS(&mut self, value: u16){ self.0 = (self.0 & 0x0000ffffffffffff) | ((value as u64) & 0xffff) << 48; }

    /// Gets Engine idle target speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_NMOTS(&self) -> u16 { (self.0 >> 48 & 0xffff) as u16 }
        
    /// Sets Standard cruise control is variant-coded

    pub fn set_TM_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffbfffffffffff) | ((value as u64) & 0x1) << 46; }

    /// Gets Standard cruise control is variant-coded
    pub fn get_TM_MS(&self) -> bool { (self.0 >> 46 & 0x1) != 0 }
        
    /// Sets Enable torque request ART

    pub fn set_M_ART_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets Enable torque request ART
    pub fn get_M_ART_E(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Target torque driver. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_FV(&mut self, value: u16){ self.0 = (self.0 & 0xffffe000ffffffff) | ((value as u64) & 0x1fff) << 32; }

    /// Gets Target torque driver. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_FV(&self) -> u16 { (self.0 >> 32 & 0x1fff) as u16 }
        
    /// Sets Enable fast torque setting

    pub fn set_SME_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Enable fast torque setting
    pub fn get_SME_E(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets Enable torque request ESP

    pub fn set_M_ESP_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets Enable torque request ESP
    pub fn get_M_ESP_E(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets Substitute default torque driver. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_FEV(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffe000ffff) | ((value as u64) & 0x1fff) << 16; }

    /// Gets Substitute default torque driver. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_FEV(&self) -> u16 { (self.0 >> 16 & 0x1fff) as u16 }
        
    /// Sets Transmission CALID/CVN enable

    pub fn set_CALID_CVN_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Transmission CALID/CVN enable
    pub fn get_CALID_CVN_E(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets Acknowledgment of EGS torque request

    pub fn set_M_EGS_Q(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets Acknowledgment of EGS torque request
    pub fn get_M_EGS_Q(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets Enable torque request EGS

    pub fn set_M_EGS_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets Enable torque request EGS
    pub fn get_M_EGS_E(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets Target torque ESP. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_ESPV(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffffe000) | ((value as u64) & 0x1fff); }

    /// Gets Target torque ESP. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_ESPV(&self) -> u16 { (self.0 & 0x1fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_268(pub u64);

impl MS_268 {

	/// Gets CAN ID of MS_268
	pub const fn get_canid() -> u16 { MS_268_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Target ratio, lower limit (FCVT). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_IMIN_MS(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Target ratio, lower limit (FCVT). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_IMIN_MS(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Target ratio, upper limit (FCVT). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_IMAX_MS(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Target ratio, upper limit (FCVT). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_IMAX_MS(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Terminal 61

    pub fn set_KL_61_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xffff7fffffffffff) | ((value as u64) & 0x1) << 47; }

    /// Gets Terminal 61
    pub fn get_KL_61_EIN(&self) -> bool { (self.0 >> 47 & 0x1) != 0 }
        
    /// Sets Oil Info, Reserved M266

    pub fn set_OEL_INFO_169(&mut self, value: bool){ self.0 = (self.0 & 0xffffbfffffffffff) | ((value as u64) & 0x1) << 46; }

    /// Gets Oil Info, Reserved M266
    pub fn get_OEL_INFO_169(&self) -> bool { (self.0 >> 46 & 0x1) != 0 }
        
    /// Sets Cooling circuit shut-off valve M266 ATL

    pub fn set_ASV_KKL_169(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets Cooling circuit shut-off valve M266 ATL
    pub fn get_ASV_KKL_169(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Heat output status

    pub fn set_HZL_ST(&mut self, value: MS_268h_HZL_ST){ self.0 = (self.0 & 0xfffffcffffffffff) | ((value as u64) & 0x3) << 40; }

    /// Gets Heat output status
    pub fn get_HZL_ST(&self) -> Option<MS_268h_HZL_ST> {  MS_268h_HZL_ST::try_from((self.0 >> 40 & 0x3) as u8).ok() }
        
    /// Sets Request power-free in "D" (FCVT)

    pub fn set_KID_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Request power-free in "D" (FCVT)
    pub fn get_KID_MS(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Air control system mode

    pub fn set_LRS_MODE(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Air control system mode
    pub fn get_LRS_MODE(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Generator utilization (only for LIN generators!). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_LAST_GEN(&mut self, value: u8){ self.0 = (self.0 & 0xffffffc0ffffffff) | ((value as u64) & 0x3f) << 32; }

    /// Gets Generator utilization (only for LIN generators!). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_LAST_GEN(&self) -> u8 { (self.0 >> 32 & 0x3f) as u8 }
        
    /// Sets Max. air conditioning compressor torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_KOMP_MAX(&mut self, value: u8){ self.0 = (self.0 & 0xffffffff00ffffff) | ((value as u64) & 0xff) << 24; }

    /// Gets Max. air conditioning compressor torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_KOMP_MAX(&self) -> u8 { (self.0 >> 24 & 0xff) as u8 }
        
    /// Sets Pedal value driver (only 169). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_PW_F(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Pedal value driver (only 169). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_PW_F(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_2F3(pub u64);

impl MS_2F3 {

	/// Gets CAN ID of MS_2F3
	pub const fn get_canid() -> u16 { MS_2F3_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Gear shift recommendation "actual"

    pub fn set_FSC_IST(&mut self, value: MS_2F3h_FSC_IST){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Gear shift recommendation "actual"
    pub fn get_FSC_IST(&self) -> Option<MS_2F3h_FSC_IST> {  MS_2F3h_FSC_IST::try_from((self.0 >> 56 & 0xff) as u8).ok() }
        
    /// Sets Gear shift recommendation "Target"

    pub fn set_FSC_SOLL(&mut self, value: MS_2F3h_FSC_SOLL){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Gear shift recommendation "Target"
    pub fn get_FSC_SOLL(&self) -> Option<MS_2F3h_FSC_SOLL> {  MS_2F3h_FSC_SOLL::try_from((self.0 >> 16 & 0xff) as u8).ok() }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_308(pub u64);

impl MS_308 {

	/// Gets CAN ID of MS_308
	pub const fn get_canid() -> u16 { MS_308_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Clutch engaged

    pub fn set_KPL(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Clutch engaged
    pub fn get_KPL(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets start "Open" converter lock-up clutch

    pub fn set_KUEB_O_A(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets start "Open" converter lock-up clutch
    pub fn get_KUEB_O_A(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Speed ‚Äã‚Äãlimitation function active

    pub fn set_N_MAX_BG(&mut self, value: bool){ self.0 = (self.0 & 0xdfffffffffffffff) | ((value as u64) & 0x1) << 61; }

    /// Gets Speed ‚Äã‚Äãlimitation function active
    pub fn get_N_MAX_BG(&self) -> bool { (self.0 >> 61 & 0x1) != 0 }
        
    /// Sets partial fuel cut-off

    pub fn set_SAST(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets partial fuel cut-off
    pub fn get_SAST(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets fuel cut-off full

    pub fn set_SASV(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets fuel cut-off full
    pub fn get_SASV(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
    /// Sets Fuel filter clogged warning lamp (CR2-USA only)

    pub fn set_KSF_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfbffffffffffffff) | ((value as u64) & 0x1) << 58; }

    /// Gets Fuel filter clogged warning lamp (CR2-USA only)
    pub fn get_KSF_KL(&self) -> bool { (self.0 >> 58 & 0x1) != 0 }
        
    /// Sets Water in fuel warning light (CR2-USA only)

    pub fn set_WKS_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfdffffffffffffff) | ((value as u64) & 0x1) << 57; }

    /// Gets Water in fuel warning light (CR2-USA only)
    pub fn get_WKS_KL(&self) -> bool { (self.0 >> 57 & 0x1) != 0 }
        
    /// Sets Cylinder deactivation conditions met

    pub fn set_ZASBED(&mut self, value: bool){ self.0 = (self.0 & 0xfeffffffffffffff) | ((value as u64) & 0x1) << 56; }

    /// Gets Cylinder deactivation conditions met
    pub fn get_ZASBED(&self) -> bool { (self.0 >> 56 & 0x1) != 0 }
        
    /// Sets engine speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_NMOT(&mut self, value: u16){ self.0 = (self.0 & 0xff0000ffffffffff) | ((value as u64) & 0xffff) << 40; }

    /// Gets engine speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_NMOT(&self) -> u16 { (self.0 >> 40 & 0xffff) as u16 }
        
    /// Sets Eco power steering pump warning message

    pub fn set_ELHP_WARN(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Eco power steering pump warning message
    pub fn get_ELHP_WARN(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Ethanol operation detected

    pub fn set_EOH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffdfffffffff) | ((value as u64) & 0x1) << 37; }

    /// Gets Ethanol operation detected
    pub fn get_EOH(&self) -> bool { (self.0 >> 37 & 0x1) != 0 }
        
    /// Sets Air filter dirty warning lamp (diesel only)

    pub fn set_LUFI_KL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffefffffffff) | ((value as u64) & 0x1) << 36; }

    /// Gets Air filter dirty warning lamp (diesel only)
    pub fn get_LUFI_KL(&self) -> bool { (self.0 >> 36 & 0x1) != 0 }
        
    /// Sets Preglow indicator lamp

    pub fn set_VGL_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffff7ffffffff) | ((value as u64) & 0x1) << 35; }

    /// Gets Preglow indicator lamp
    pub fn get_VGL_KL(&self) -> bool { (self.0 >> 35 & 0x1) != 0 }
        
    /// Sets Oil level/oil pressure warning lamp

    pub fn set_OEL_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets Oil level/oil pressure warning lamp
    pub fn get_OEL_KL(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets Diagnostic control lamp (OBD II)

    pub fn set_DIAG_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets Diagnostic control lamp (OBD II)
    pub fn get_DIAG_KL(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets Tank cap open warning lamp

    pub fn set_TANK_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets Tank cap open warning lamp
    pub fn get_TANK_KL(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets Engine oil temperature too high (overheating)

    pub fn set_UEHITZ(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets Engine oil temperature too high (overheating)
    pub fn get_UEHITZ(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Cylinder deactivation

    pub fn set_ZAS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Cylinder deactivation
    pub fn get_ZAS(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets ADR warning lamp (only commercial vehicles)

    pub fn set_ADR_KL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets ADR warning lamp (only commercial vehicles)
    pub fn get_ADR_KL(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets ADR defective warning lamp (only commercial vehicles)

    pub fn set_ADR_DEF_KL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets ADR defective warning lamp (only commercial vehicles)
    pub fn get_ADR_DEF_KL(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets Starter running

    pub fn set_ANL_LFT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets Starter running
    pub fn get_ANL_LFT(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets Motor fan faulty indicator lamp

    pub fn set_LUEFT_MOT_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets Motor fan faulty indicator lamp
    pub fn get_LUEFT_MOT_KL(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Speed ‚Äã‚Äãlimitation for display active (0 with CR)

    pub fn set_DBAA(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffdffffff) | ((value as u64) & 0x1) << 25; }

    /// Gets Speed ‚Äã‚Äãlimitation for display active (0 with CR)
    pub fn get_DBAA(&self) -> bool { (self.0 >> 25 & 0x1) != 0 }
        
    /// Sets Cooling water temperature too high

    pub fn set_TEMP_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffeffffff) | ((value as u64) & 0x1) << 24; }

    /// Gets Cooling water temperature too high
    pub fn get_TEMP_KL(&self) -> bool { (self.0 >> 24 & 0x1) != 0 }
        
    /// Sets oil temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_T_OEL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets oil temperature. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_T_OEL(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets oil level. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OEL_FS(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff00ff) | ((value as u64) & 0xff) << 8; }

    /// Gets oil level. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OEL_FS(&self) -> u8 { (self.0 >> 8 & 0xff) as u8 }
        
    /// Sets Oil quality. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OEL_QUAL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff); }

    /// Gets Oil quality. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OEL_QUAL(&self) -> u8 { (self.0 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_312(pub u64);

impl MS_312 {

	/// Gets CAN ID of MS_312
	pub const fn get_canid() -> u16 { MS_312_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Static motor torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_STA(&mut self, value: u16){ self.0 = (self.0 & 0xe000ffffffffffff) | ((value as u64) & 0x1fff) << 48; }

    /// Gets Static motor torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_STA(&self) -> u16 { (self.0 >> 48 & 0x1fff) as u16 }
        
    /// Sets maximum motor torque incl. dyn. turbocharger share. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_MAX_ATL(&mut self, value: u16){ self.0 = (self.0 & 0xffffe000ffffffff) | ((value as u64) & 0x1fff) << 32; }

    /// Gets maximum motor torque incl. dyn. turbocharger share. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_MAX_ATL(&self) -> u16 { (self.0 >> 32 & 0x1fff) as u16 }
        
    /// Sets Maximum engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_MAX(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffe000ffff) | ((value as u64) & 0x1fff) << 16; }

    /// Gets Maximum engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_MAX(&self) -> u16 { (self.0 >> 16 & 0x1fff) as u16 }
        
    /// Sets Minimum engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_MIN(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffffe000) | ((value as u64) & 0x1fff); }

    /// Gets Minimum engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_MIN(&self) -> u16 { (self.0 & 0x1fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct AAD_580(pub u64);

impl AAD_580 {

	/// Gets CAN ID of AAD_580
	pub const fn get_canid() -> u16 { AAD_580_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Acceleration type code (>100: more dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_BMI(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Acceleration type code (>100: more dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_BMI(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets code for lateral acceleration type (>100: dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_LMI(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets code for lateral acceleration type (>100: dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_LMI(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Brake type code (>100: more dynamic). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_VMI(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Brake type code (>100: more dynamic). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_VMI(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets Max. diff. Pedal angle value per maneuver. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_FTK_DPW(&mut self, value: u8){ self.0 = (self.0 & 0xffffffff00ffffff) | ((value as u64) & 0xff) << 24; }

    /// Gets Max. diff. Pedal angle value per maneuver. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_FTK_DPW(&self) -> u8 { (self.0 >> 24 & 0xff) as u8 }
        
    /// Sets Continuous driver observation. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_AADKB(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Continuous driver observation. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_AADKB(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets Spontaneous dynamic requirement

    pub fn set_AADKBDYN(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Spontaneous dynamic requirement
    pub fn get_AADKBDYN(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets nervousness. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_AADNT(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff); }

    /// Gets nervousness. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_AADNT(&self) -> u8 { (self.0 & 0xff) as u8 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct MS_608(pub u64);

impl MS_608 {

	/// Gets CAN ID of MS_608
	pub const fn get_canid() -> u16 { MS_608_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Engine coolant temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_T_MOT(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Engine coolant temperature. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_T_MOT(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets intake air temperature. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_T_LUFT(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets intake air temperature. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_T_LUFT(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets vehicle code body

    pub fn set_FCOD_KAR(&mut self, value: MS_608h_FCOD_KAR){ self.0 = (self.0 & 0xffff1fffffffffff) | ((value as u64) & 0x7) << 45; }

    /// Gets vehicle code body
    pub fn get_FCOD_KAR(&self) -> Option<MS_608h_FCOD_KAR> {  MS_608h_FCOD_KAR::try_from((self.0 >> 45 & 0x7) as u8).ok() }
        
    /// Sets vehicle code series

    pub fn set_FCOD_BR(&mut self, value: MS_608h_FCOD_BR){ self.0 = (self.0 & 0xffffe0ffffffffff) | ((value as u64) & 0x1f) << 40; }

    /// Gets vehicle code series
    pub fn get_FCOD_BR(&self) -> Option<MS_608h_FCOD_BR> {  MS_608h_FCOD_BR::try_from((self.0 >> 40 & 0x1f) as u8).ok() }
        
    /// Sets Vehicle code engine with 7 bits, bit 6

    pub fn set_FCOD_MOT6(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Vehicle code engine with 7 bits, bit 6
    pub fn get_FCOD_MOT6(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Transmission control not available

    pub fn set_GS_NVH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Transmission control not available
    pub fn get_GS_NVH(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Vehicle code motor 7-bit, bit0-5 (bit6--> signal FCOD_MOT6)

    pub fn set_FCOD_MOT(&mut self, value: MS_608h_FCOD_MOT){ self.0 = (self.0 & 0xffffffc0ffffffff) | ((value as u64) & 0x3f) << 32; }

    /// Gets Vehicle code motor 7-bit, bit0-5 (bit6--> signal FCOD_MOT6)
    pub fn get_FCOD_MOT(&self) -> Option<MS_608h_FCOD_MOT> {  MS_608h_FCOD_MOT::try_from((self.0 >> 32 & 0x3f) as u8).ok() }
        
    /// Sets Fixed maximum speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_V_MAX_FIX(&mut self, value: u8){ self.0 = (self.0 & 0xffffffff00ffffff) | ((value as u64) & 0xff) << 24; }

    /// Gets Fixed maximum speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_V_MAX_FIX(&self) -> u8 { (self.0 >> 24 & 0xff) as u8 }
        
    /// Sets consumption. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_VB(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffff0000ff) | ((value as u64) & 0xffff) << 8; }

    /// Gets consumption. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_VB(&self) -> u16 { (self.0 >> 8 & 0xffff) as u16 }
        
    /// Sets Switch on auxiliary water pump

    pub fn set_ZWP_EIN_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffff7f) | ((value as u64) & 0x1) << 7; }

    /// Gets Switch on auxiliary water pump
    pub fn get_ZWP_EIN_MS(&self) -> bool { (self.0 >> 7 & 0x1) != 0 }
        
    /// Sets Particulate filter warning

    pub fn set_PFW(&mut self, value: MS_608h_PFW){ self.0 = (self.0 & 0xffffffffffffff9f) | ((value as u64) & 0x3) << 5; }

    /// Gets Particulate filter warning
    pub fn get_PFW(&self) -> Option<MS_608h_PFW> {  MS_608h_PFW::try_from((self.0 >> 5 & 0x3) as u8).ok() }
        
    /// Sets Switch on additional consumers

    pub fn set_ZVB_EIN_MS(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffffef) | ((value as u64) & 0x1) << 4; }

    /// Gets Switch on additional consumers
    pub fn get_ZVB_EIN_MS(&self) -> bool { (self.0 >> 4 & 0x1) != 0 }
        
    /// Sets Particulate filter correction offset FMMOTMAX. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_PFKO(&mut self, value: u8){ self.0 = (self.0 & 0xfffffffffffffff0) | ((value as u64) & 0xf); }

    /// Gets Particulate filter correction offset FMMOTMAX. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_PFKO(&self) -> u8 { (self.0 & 0xf) as u8 }
        
}