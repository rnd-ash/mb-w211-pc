
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'DTR'
*/
    
pub const DTR_A1_CAN_ID: u16 = 0x0254;
pub const DTR_A2_CAN_ID: u16 = 0x025C;
pub const DTR_A3_CAN_ID: u16 = 0x0260;
pub const DTR_A4_CAN_ID: u16 = 0x0264;
pub const DTR_A5_CAN_ID: u16 = 0x026C;

/// Active lane configuration numeric
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A1_DTR_AC_LANECFG {
	AC_NO_EXT = 0, // No external lane (3IDs)
	AC_ADD_EXT = 1, // Use external lane additional (3+2IDs)
	AC_ONLY_EXT = 2, // Use external lane only (1+2IDs)
	AC_RES = 3, // Reserved
}

impl TryFrom<u8> for DTR_A1_DTR_AC_LANECFG {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AC_NO_EXT),
			1 => Ok(Self::AC_ADD_EXT),
			2 => Ok(Self::AC_ONLY_EXT),
			3 => Ok(Self::AC_RES),
			_ => Err(())
		}
	}
}
/// DTR sensor diagnosis mode
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A1_DTR_SENS_DMODE {
	NO_DIAG = 0, // No diagnostic mode
	SENS_DIAG = 1, // Sensor in diagnostic mode
	BAND_DIAG = 2, // Sensor in end-of-band diagnostic mode
	FERN_DIAG = 3, // Sensor in remote diagnosis mode
}

impl TryFrom<u8> for DTR_A1_DTR_SENS_DMODE {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_DIAG),
			1 => Ok(Self::SENS_DIAG),
			2 => Ok(Self::BAND_DIAG),
			3 => Ok(Self::FERN_DIAG),
			_ => Err(())
		}
	}
}
/// Target loss reason numeric Relevant object
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A2_REL_ZIELVLST {
	NO_INF = 0, // No information
	E_KURVE = 1, // Tight curve
	KURVE = 2, // curve
	AUFG = 3, // Resolved
}

impl TryFrom<u8> for DTR_A2_REL_ZIELVLST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_INF),
			1 => Ok(Self::E_KURVE),
			2 => Ok(Self::KURVE),
			3 => Ok(Self::AUFG),
			_ => Err(())
		}
	}
}
/// Target loss reason numeric object 2
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A3_OBJ2_ZIELVLST {
	NO_INF = 0, // No information
	E_KURVE = 1, // Tight curve
	KURVE = 2, // curve
	AUFG = 3, // Resolved
}

impl TryFrom<u8> for DTR_A3_OBJ2_ZIELVLST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_INF),
			1 => Ok(Self::E_KURVE),
			2 => Ok(Self::KURVE),
			3 => Ok(Self::AUFG),
			_ => Err(())
		}
	}
}
/// Target loss reason numeric Object 3
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A4_OBJ3_ZIELVLST {
	NO_INF = 0, // No information
	E_KURVE = 1, // Tight curve
	KURVE = 2, // curve
	AUFG = 3, // Resolved
}

impl TryFrom<u8> for DTR_A4_OBJ3_ZIELVLST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_INF),
			1 => Ok(Self::E_KURVE),
			2 => Ok(Self::KURVE),
			3 => Ok(Self::AUFG),
			_ => Err(())
		}
	}
}
/// Target loss reason numeric object 4
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum DTR_A5_OBJ4_ZIELVLST {
	NO_INF = 0, // No information
	E_KURVE = 1, // Tight curve
	KURVE = 2, // curve
	AUFG = 3, // Resolved
}

impl TryFrom<u8> for DTR_A5_OBJ4_ZIELVLST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_INF),
			1 => Ok(Self::E_KURVE),
			2 => Ok(Self::KURVE),
			3 => Ok(Self::AUFG),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DTR_A1(pub u64);

impl DTR_A1 {

	/// Gets CAN ID of DTR_A1
	pub const fn get_canid() -> u16 { DTR_A1_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Sensor variant. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SENS_VAR(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Sensor variant. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SENS_VAR(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Sensor software year. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SENS_SW_JAHR(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Sensor software year. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SENS_SW_JAHR(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Sensor software calendar week. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SENS_SW_KW(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Sensor software calendar week. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SENS_SW_KW(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets Sensor defective

    pub fn set_SENS_DEF(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets Sensor defective
    pub fn get_SENS_DEF(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets Sensor out of adjustment

    pub fn set_SENS_DEJUST(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets Sensor out of adjustment
    pub fn get_SENS_DEJUST(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets Sensor shutdown due to temperature

    pub fn set_SENS_TEMP_ERR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffdfffffffff) | ((value as u64) & 0x1) << 37; }

    /// Gets Sensor shutdown due to temperature
    pub fn get_SENS_TEMP_ERR(&self) -> bool { (self.0 >> 37 & 0x1) != 0 }
        
    /// Sets External sensor fault

    pub fn set_SENS_EXT_ERR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffefffffffff) | ((value as u64) & 0x1) << 36; }

    /// Gets External sensor fault
    pub fn get_SENS_EXT_ERR(&self) -> bool { (self.0 >> 36 & 0x1) != 0 }
        
    /// Sets Sensor has transmission/reception problems

    pub fn set_SENS_TXRX_ERR(&mut self, value: bool){ self.0 = (self.0 & 0xfffffff7ffffffff) | ((value as u64) & 0x1) << 35; }

    /// Gets Sensor has transmission/reception problems
    pub fn get_SENS_TXRX_ERR(&self) -> bool { (self.0 >> 35 & 0x1) != 0 }
        
    /// Sets Sensor / sensor cover dirty

    pub fn set_SENS_DIRTY(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets Sensor / sensor cover dirty
    pub fn get_SENS_DIRTY(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets Object not measured

    pub fn set_OBJ_NVERM(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets Object not measured
    pub fn get_OBJ_NVERM(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets Sensor not initialized

    pub fn set_SENS_NINIT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets Sensor not initialized
    pub fn get_SENS_NINIT(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets Undervoltage detected

    pub fn set_UB_LOW(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets Undervoltage detected
    pub fn get_UB_LOW(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets IDs track status read in at least 2X (no passive values)

    pub fn set_RX_SPUR_VALID(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets IDs track status read in at least 2X (no passive values)
    pub fn get_RX_SPUR_VALID(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets DTR CAN valid (valid CAN data)

    pub fn set_DTR_CAN_VALID(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets DTR CAN valid (valid CAN data)
    pub fn get_DTR_CAN_VALID(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets RX invalid (timeout, parity, MC)

    pub fn set_DTR_RX_INVALID(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets RX invalid (timeout, parity, MC)
    pub fn get_DTR_RX_INVALID(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Active lane configuration numeric

    pub fn set_DTR_AC_LANECFG(&mut self, value: DTR_A1_DTR_AC_LANECFG){ self.0 = (self.0 & 0xfffffffffcffffff) | ((value as u64) & 0x3) << 24; }

    /// Gets Active lane configuration numeric
    pub fn get_DTR_AC_LANECFG(&self) -> Option<DTR_A1_DTR_AC_LANECFG> {  DTR_A1_DTR_AC_LANECFG::try_from((self.0 >> 24 & 0x3) as u8).ok() }
        
    /// Sets DTR - track. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DTR_LANE(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffff0000ff) | ((value as u64) & 0xffff) << 8; }

    /// Gets DTR - track. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DTR_LANE(&self) -> u16 { (self.0 >> 8 & 0xffff) as u16 }
        
    /// Sets message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_MSG_CNT_DTR_A1(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff0f) | ((value as u64) & 0xf) << 4; }

    /// Gets message counter. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_MSG_CNT_DTR_A1(&self) -> u8 { (self.0 >> 4 & 0xf) as u8 }
        
    /// Sets DTR sensor diagnosis mode

    pub fn set_DTR_SENS_DMODE(&mut self, value: DTR_A1_DTR_SENS_DMODE){ self.0 = (self.0 & 0xfffffffffffffffc) | ((value as u64) & 0x3); }

    /// Gets DTR sensor diagnosis mode
    pub fn get_DTR_SENS_DMODE(&self) -> Option<DTR_A1_DTR_SENS_DMODE> {  DTR_A1_DTR_SENS_DMODE::try_from((self.0 & 0x3) as u8).ok() }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DTR_A2(pub u64);

impl DTR_A2 {

	/// Gets CAN ID of DTR_A2
	pub const fn get_canid() -> u16 { DTR_A2_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets CRC checksum byte 2 - 8 according to SAE J1850. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_CRC25CH(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets CRC checksum byte 2 - 8 according to SAE J1850. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_CRC25CH(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets DTR storage Relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_REL_ABLAGE(&mut self, value: u16){ self.0 = (self.0 & 0xff007fffffffffff) | ((value as u64) & 0x1ff) << 47; }

    /// Gets DTR storage Relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_REL_ABLAGE(&self) -> u16 { (self.0 >> 47 & 0x1ff) as u16 }
        
    /// Sets DTR distance Relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_REL_ABSTAND(&mut self, value: u16){ self.0 = (self.0 & 0xffff800fffffffff) | ((value as u64) & 0x7ff) << 36; }

    /// Gets DTR distance Relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_REL_ABSTAND(&self) -> u16 { (self.0 >> 36 & 0x7ff) as u16 }
        
    /// Sets DTR relative speed Relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_REL_V_REL(&mut self, value: u16){ self.0 = (self.0 & 0xfffffff000ffffff) | ((value as u64) & 0xfff) << 24; }

    /// Gets DTR relative speed Relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_REL_V_REL(&self) -> u16 { (self.0 >> 24 & 0xfff) as u16 }
        
    /// Sets DTR acceleration Relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_REL_A_OBJ(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets DTR acceleration Relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_REL_A_OBJ(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets Collision Mitigation System Obj. valid

    pub fn set_CMS_VAL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Collision Mitigation System Obj. valid
    pub fn get_CMS_VAL(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets DTR status of object data (object moving to standing) Relevant object

    pub fn set_REL_FAHRT_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets DTR status of object data (object moving to standing) Relevant object
    pub fn get_REL_FAHRT_STEHT(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets DTR status object data Relevant object

    pub fn set_REL_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets DTR status object data Relevant object
    pub fn get_REL_STEHT(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets DTR status object data Relevant object

    pub fn set_REL_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets DTR status object data Relevant object
    pub fn get_REL_NEU(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Target loss reason numeric Relevant object

    pub fn set_REL_ZIELVLST(&mut self, value: DTR_A2_REL_ZIELVLST){ self.0 = (self.0 & 0xfffffffffffff3ff) | ((value as u64) & 0x3) << 10; }

    /// Gets Target loss reason numeric Relevant object
    pub fn get_REL_ZIELVLST(&self) -> Option<DTR_A2_REL_ZIELVLST> {  DTR_A2_REL_ZIELVLST::try_from((self.0 >> 10 & 0x3) as u8).ok() }
        
    /// Sets DTR ABL GRAD Relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_REL_ABL_GRAD(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffffffc00) | ((value as u64) & 0x3ff); }

    /// Gets DTR ABL GRAD Relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_REL_ABL_GRAD(&self) -> u16 { (self.0 & 0x3ff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DTR_A3(pub u64);

impl DTR_A3 {

	/// Gets CAN ID of DTR_A3
	pub const fn get_canid() -> u16 { DTR_A3_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets DTR storage object 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ2_ABLAGE(&mut self, value: u16){ self.0 = (self.0 & 0xff007fffffffffff) | ((value as u64) & 0x1ff) << 47; }

    /// Gets DTR storage object 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ2_ABLAGE(&self) -> u16 { (self.0 >> 47 & 0x1ff) as u16 }
        
    /// Sets DTR distance object 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ2_ABSTAND(&mut self, value: u16){ self.0 = (self.0 & 0xffff800fffffffff) | ((value as u64) & 0x7ff) << 36; }

    /// Gets DTR distance object 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ2_ABSTAND(&self) -> u16 { (self.0 >> 36 & 0x7ff) as u16 }
        
    /// Sets DTR relative speed object 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ2_V_REL(&mut self, value: u16){ self.0 = (self.0 & 0xfffffff000ffffff) | ((value as u64) & 0xfff) << 24; }

    /// Gets DTR relative speed object 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ2_V_REL(&self) -> u16 { (self.0 >> 24 & 0xfff) as u16 }
        
    /// Sets DTR acceleration object 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ2_A_OBJ(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets DTR acceleration object 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ2_A_OBJ(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets DTR status object data (object moving to standing) object 2

    pub fn set_OBJ2_FAHRT_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets DTR status object data (object moving to standing) object 2
    pub fn get_OBJ2_FAHRT_STEHT(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets DTR status object data object 2

    pub fn set_OBJ2_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets DTR status object data object 2
    pub fn get_OBJ2_STEHT(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets DTR status object data object 2

    pub fn set_OBJ2_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets DTR status object data object 2
    pub fn get_OBJ2_NEU(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Target loss reason numeric object 2

    pub fn set_OBJ2_ZIELVLST(&mut self, value: DTR_A3_OBJ2_ZIELVLST){ self.0 = (self.0 & 0xfffffffffffff3ff) | ((value as u64) & 0x3) << 10; }

    /// Gets Target loss reason numeric object 2
    pub fn get_OBJ2_ZIELVLST(&self) -> Option<DTR_A3_OBJ2_ZIELVLST> {  DTR_A3_OBJ2_ZIELVLST::try_from((self.0 >> 10 & 0x3) as u8).ok() }
        
    /// Sets DTR ABL GRAD object 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ2_ABL_GRAD(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffffffc00) | ((value as u64) & 0x3ff); }

    /// Gets DTR ABL GRAD object 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ2_ABL_GRAD(&self) -> u16 { (self.0 & 0x3ff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DTR_A4(pub u64);

impl DTR_A4 {

	/// Gets CAN ID of DTR_A4
	pub const fn get_canid() -> u16 { DTR_A4_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets DTR storage object 3. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ3_ABLAGE(&mut self, value: u16){ self.0 = (self.0 & 0xff007fffffffffff) | ((value as u64) & 0x1ff) << 47; }

    /// Gets DTR storage object 3. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ3_ABLAGE(&self) -> u16 { (self.0 >> 47 & 0x1ff) as u16 }
        
    /// Sets DTR distance object 3. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ3_ABSTAND(&mut self, value: u16){ self.0 = (self.0 & 0xffff800fffffffff) | ((value as u64) & 0x7ff) << 36; }

    /// Gets DTR distance object 3. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ3_ABSTAND(&self) -> u16 { (self.0 >> 36 & 0x7ff) as u16 }
        
    /// Sets DTR relative speed object 3. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ3_V_REL(&mut self, value: u16){ self.0 = (self.0 & 0xfffffff000ffffff) | ((value as u64) & 0xfff) << 24; }

    /// Gets DTR relative speed object 3. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ3_V_REL(&self) -> u16 { (self.0 >> 24 & 0xfff) as u16 }
        
    /// Sets DTR acceleration object 3. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ3_A_OBJ(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets DTR acceleration object 3. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ3_A_OBJ(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets DTR status object data (object moving to standing) object 3

    pub fn set_OBJ3_FAHRT_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets DTR status object data (object moving to standing) object 3
    pub fn get_OBJ3_FAHRT_STEHT(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets DTR status object data object 3

    pub fn set_OBJ3_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets DTR status object data object 3
    pub fn get_OBJ3_STEHT(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets DTR status object data object 3

    pub fn set_OBJ3_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets DTR status object data object 3
    pub fn get_OBJ3_NEU(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Target loss reason numeric Object 3

    pub fn set_OBJ3_ZIELVLST(&mut self, value: DTR_A4_OBJ3_ZIELVLST){ self.0 = (self.0 & 0xfffffffffffff3ff) | ((value as u64) & 0x3) << 10; }

    /// Gets Target loss reason numeric Object 3
    pub fn get_OBJ3_ZIELVLST(&self) -> Option<DTR_A4_OBJ3_ZIELVLST> {  DTR_A4_OBJ3_ZIELVLST::try_from((self.0 >> 10 & 0x3) as u8).ok() }
        
    /// Sets DTR ABL GRAD Object 3. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ3_ABL_GRAD(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffffffc00) | ((value as u64) & 0x3ff); }

    /// Gets DTR ABL GRAD Object 3. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ3_ABL_GRAD(&self) -> u16 { (self.0 & 0x3ff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct DTR_A5(pub u64);

impl DTR_A5 {

	/// Gets CAN ID of DTR_A5
	pub const fn get_canid() -> u16 { DTR_A5_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets DTR storage object 4. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ4_ABLAGE(&mut self, value: u16){ self.0 = (self.0 & 0xff007fffffffffff) | ((value as u64) & 0x1ff) << 47; }

    /// Gets DTR storage object 4. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ4_ABLAGE(&self) -> u16 { (self.0 >> 47 & 0x1ff) as u16 }
        
    /// Sets DTR distance object 4. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ4_ABSTAND(&mut self, value: u16){ self.0 = (self.0 & 0xffff800fffffffff) | ((value as u64) & 0x7ff) << 36; }

    /// Gets DTR distance object 4. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ4_ABSTAND(&self) -> u16 { (self.0 >> 36 & 0x7ff) as u16 }
        
    /// Sets DTR relative speed object 4. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ4_V_REL(&mut self, value: u16){ self.0 = (self.0 & 0xfffffff000ffffff) | ((value as u64) & 0xfff) << 24; }

    /// Gets DTR relative speed object 4. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ4_V_REL(&self) -> u16 { (self.0 >> 24 & 0xfff) as u16 }
        
    /// Sets DTR acceleration object 4. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ4_A_OBJ(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets DTR acceleration object 4. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ4_A_OBJ(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets DTR status object data (object moving to standing) object 4

    pub fn set_OBJ4_FAHRT_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets DTR status object data (object moving to standing) object 4
    pub fn get_OBJ4_FAHRT_STEHT(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets DTR status object data object 4

    pub fn set_OBJ4_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets DTR status object data object 4
    pub fn get_OBJ4_STEHT(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets DTR status object data object 4

    pub fn set_OBJ4_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets DTR status object data object 4
    pub fn get_OBJ4_NEU(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Target loss reason numeric object 4

    pub fn set_OBJ4_ZIELVLST(&mut self, value: DTR_A5_OBJ4_ZIELVLST){ self.0 = (self.0 & 0xfffffffffffff3ff) | ((value as u64) & 0x3) << 10; }

    /// Gets Target loss reason numeric object 4
    pub fn get_OBJ4_ZIELVLST(&self) -> Option<DTR_A5_OBJ4_ZIELVLST> {  DTR_A5_OBJ4_ZIELVLST::try_from((self.0 >> 10 & 0x3) as u8).ok() }
        
    /// Sets DTR ABL GRAD object 4. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_OBJ4_ABL_GRAD(&mut self, value: u16){ self.0 = (self.0 & 0xfffffffffffffc00) | ((value as u64) & 0x3ff); }

    /// Gets DTR ABL GRAD object 4. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_OBJ4_ABL_GRAD(&self) -> u16 { (self.0 & 0x3ff) as u16 }
        
}