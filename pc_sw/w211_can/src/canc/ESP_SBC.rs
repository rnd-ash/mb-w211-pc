
#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ESP_SBC'
*/
    
pub const RDU_A1_CAN_ID: u16 = 0x0220;
pub const RDU_A2_CAN_ID: u16 = 0x0224;
pub const RDU_A3_CAN_ID: u16 = 0x0228;
pub const BS_200_CAN_ID: u16 = 0x0200;
pub const BS_208_CAN_ID: u16 = 0x0208;
pub const ART_258_CAN_ID: u16 = 0x0258;
pub const BS_270_CAN_ID: u16 = 0x0270;
pub const BS_300_CAN_ID: u16 = 0x0300;
pub const BS_328_CAN_ID: u16 = 0x0328;

/// Linear controller diagnosis mode
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A1_DIAGMODE {
	NO_DIAG = 0, // No diagnostic mode
	BAND_DIAG = 1, // LRG host in end-of-band diag mode
	HOST_DIAG = 2, // LRG host in diagnostic mode
	FERN_DIAG = 3, // LRG host in remote diagnosis mode
}

impl TryFrom<u8> for RDU_A1_DIAGMODE {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_DIAG),
			1 => Ok(Self::BAND_DIAG),
			2 => Ok(Self::HOST_DIAG),
			3 => Ok(Self::FERN_DIAG),
			_ => Err(())
		}
	}
}
/// lane configuration
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A1_SPUHR_KONF {
	NO_EXT = 0, // No external track (3 IDs)
	ADD_EXT = 1, // Use external track additionally (3+2IDs)
	ONLY_EXT = 2, // Use external track only (1+2IDs)
	NICHT_DEFINIERT = 3, // Unknown
}

impl TryFrom<u8> for RDU_A1_SPUHR_KONF {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NO_EXT),
			1 => Ok(Self::ADD_EXT),
			2 => Ok(Self::ONLY_EXT),
			3 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Steering wheel angle sensor status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A2_LRWS_ST {
	OK = 0, // Steering wheel angle sensor OK
	INI = 1, // Steering wheel angle sensor not initialized
	ERR = 2, // Steering wheel angle sensor faulty
	ERR_INI = 3, // Steering wheel angle sensor faulty and not initialized
}

impl TryFrom<u8> for RDU_A2_LRWS_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::INI),
			2 => Ok(Self::ERR),
			3 => Ok(Self::ERR_INI),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front left
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A3_DRTGVL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not present
}

impl TryFrom<u8> for RDU_A3_DRTGVL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A3_DRTGVR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for RDU_A3_DRTGVR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear left wheel
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A3_DRTGHL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not present
}

impl TryFrom<u8> for RDU_A3_DRTGHL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear wheel to the right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum RDU_A3_DRTGHR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for RDU_A3_DRTGHR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// brake light switch
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_200h_BLS {
	BREMSE_NBET = 0, // Brake not applied
	BREMSE_BET = 1, // Brake applied
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_200h_BLS {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::BREMSE_NBET),
			1 => Ok(Self::BREMSE_BET),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front left
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_200h_DRTGVL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_200h_DRTGVL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of wheel, front right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_200h_DRTGVR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_200h_DRTGVR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Left wheel rotation for cruise control
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_200h_DRTGTM {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_200h_DRTGTM {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// target gear, upper limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_GMAX_ESP {
	PASSIV = 0, // passive value
	G1 = 1, // Target gear, upper limit = 1
	G2 = 2, // target gear, upper limit = 2
	G3 = 3, // target gear, upper limit = 3
	G4 = 4, // Target gear, upper limit = 4
	G5 = 5, // target gear, upper limit = 5
	G6 = 6, // target gear, upper limit = 6
	G7 = 7, // target gear, upper limit = 7
}

impl TryFrom<u8> for BS_208h_GMAX_ESP {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// target gear, lower limit
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_GMIN_ESP {
	PASSIV = 0, // passive value
	G1 = 1, // target gear, lower limit = 1
	G2 = 2, // target gear, lower limit = 2
	G3 = 3, // target gear, lower limit = 3
	G4 = 4, // Desired gear, lower limit = 4
	G5 = 5, // Desired gear, lower limit = 5
	G6 = 6, // Desired gear, lower limit = 6
	G7 = 7, // target gear, lower limit = 7
}

impl TryFrom<u8> for BS_208h_GMIN_ESP {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::G1),
			2 => Ok(Self::G2),
			3 => Ok(Self::G3),
			4 => Ok(Self::G4),
			5 => Ok(Self::G5),
			6 => Ok(Self::G6),
			7 => Ok(Self::G7),
			_ => Err(())
		}
	}
}
/// system state
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_SZS {
	ERR_DIAG = 0, // System error or diagnosis
	NORM = 1, // Normal operation
	NICHT_DEFINIERT = 2, // Unknown
	ABGAS = 3, // Emissions test
}

impl TryFrom<u8> for BS_208h_SZS {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::ERR_DIAG),
			1 => Ok(Self::NORM),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::ABGAS),
			_ => Err(())
		}
	}
}
/// ESP switching line shift
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_SLV_ESP {
	SKL0 = 0, // Switching characteristic "0"
	SKL1 = 1, // Switching characteristic "1"
	SKL2 = 2, // Switching characteristic "2"
	SKL3 = 3, // Switching characteristic "3"
	SKL4 = 4, // Switching characteristic "4"
	SKL5 = 5, // Switching characteristic "5"
	SKL6 = 6, // Switching characteristic "6"
	SKL7 = 7, // Switching characteristic "7"
	SKL8 = 8, // Switching characteristic "8"
	SKL9 = 9, // Switching characteristic "9"
	SKL10 = 10, // Switching characteristic "10"
}

impl TryFrom<u8> for BS_208h_SLV_ESP {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::SKL0),
			1 => Ok(Self::SKL1),
			2 => Ok(Self::SKL2),
			3 => Ok(Self::SKL3),
			4 => Ok(Self::SKL4),
			5 => Ok(Self::SKL5),
			6 => Ok(Self::SKL6),
			7 => Ok(Self::SKL7),
			8 => Ok(Self::SKL8),
			9 => Ok(Self::SKL9),
			10 => Ok(Self::SKL10),
			_ => Err(())
		}
	}
}
/// ESP request: insert "N".
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_ANFN {
	NICHT_DEFINIERT = 0, // Unknown
	ANF_N = 1, // Neutral request
	IDLE = 2, // No requirement
	SNV = 3, // Signal not present
}

impl TryFrom<u8> for BS_208h_ANFN {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NICHT_DEFINIERT),
			1 => Ok(Self::ANF_N),
			2 => Ok(Self::IDLE),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear wheel to the right
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_DRTGHR {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not present
}

impl TryFrom<u8> for BS_208h_DRTGHR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Direction of rotation of rear left wheel
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_208h_DRTGHL {
	PASSIV = 0, // No detection of direction of rotation
	VOR = 1, // Direction of rotation forward
	RUECK = 2, // reverse direction of rotation
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_208h_DRTGHL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::PASSIV),
			1 => Ok(Self::VOR),
			2 => Ok(Self::RUECK),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// ART error code
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ART_258h_ART_ERR {
	OK = 0, // No error present
	SCHMUTZ = 1, // ART disorder; Sensor dirty
	ART_DEF = 2, // ART defective
	ART_LIM_DEF = 3, // ART/LIM defective
	EXT = 4, // ART; external disturbance
	DBC_DEF = 5, // DBC defective
	SCHMUTZ_DBC_DEF = 6, // ART disorder; Sensor dirty and DBC defective
	ART_DBC_DEF = 7, // ART and DBC defective
	ART_LIM_DBC_DEF = 8, // ART/LIM and DBC defective
	EXT_DBC = 9, // ART external fault and DBC defective
	NICHT_DEFINIERT = 15, // Unknown
}

impl TryFrom<u8> for ART_258h_ART_ERR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::SCHMUTZ),
			2 => Ok(Self::ART_DEF),
			3 => Ok(Self::ART_LIM_DEF),
			4 => Ok(Self::EXT),
			5 => Ok(Self::DBC_DEF),
			6 => Ok(Self::SCHMUTZ_DBC_DEF),
			7 => Ok(Self::ART_DBC_DEF),
			8 => Ok(Self::ART_LIM_DBC_DEF),
			9 => Ok(Self::EXT_DBC),
			15 => Ok(Self::NICHT_DEFINIERT),
			_ => Err(())
		}
	}
}
/// Active function
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ART_258h_ASSIST_FKT_AKT {
	AUS = 0, // Out
	AAS = 1, // distance assistant
	ADTR = 2, // Advanced Distronic
	DBC = 3, // Downhill Brake Control
}

impl TryFrom<u8> for ART_258h_ASSIST_FKT_AKT {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::AUS),
			1 => Ok(Self::AAS),
			2 => Ok(Self::ADTR),
			3 => Ok(Self::DBC),
			_ => Err(())
		}
	}
}
/// CAS display request
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ART_258h_CAS_ERR_ANZ_V2 {
	IDLE = 0, // no error
	CAS_SFV_REINIGEN = 1, // CAS display "clean front bumper"
	CAS_SFV_SFH_REINIGEN = 2, // CAS display "Clean front and rear bumper"
	CAS_ERR_W = 3, // CAS display "Visit workshop"
}

impl TryFrom<u8> for ART_258h_CAS_ERR_ANZ_V2 {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::IDLE),
			1 => Ok(Self::CAS_SFV_REINIGEN),
			2 => Ok(Self::CAS_SFV_SFH_REINIGEN),
			3 => Ok(Self::CAS_ERR_W),
			_ => Err(())
		}
	}
}
/// Assistance system display request
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum ART_258h_ASSIST_ANZ_V2 {
	IDLE = 0, // Basic picture according to active bit
	DBC_LIM = 1, // Message "Switch on DBC / DBC xx km/h"
	DBC_AUS = 2, // Message "Turn off DBC"
	DBC_AUS_TON = 3, // Message "Turn off DBC" with sound
	DBC_NV_AKT = 4, // Message "DBC incorrect operation / DBC cannot be activated"
	DBC_NV_LIM = 5, // Message "DBC incorrect operation / DBC xx km/h"
	AAS_EIN = 6, // Message "Turn on AAS"
	AAS_AUS = 7, // Message "Turn off AAS"
	AAS_AUS_TON = 8, // Message "Turn off AAS" with sound
	AAS_NV_LIM = 9, // Message "AAS cannot be activated / switch on LIM"
	AAS_NV_OBJ = 10, // Message "AAS cannot be activated / no target"
	AAS_NV_FBED = 11, // Message "AAS incorrect operation / not available"
	AAS_FOLGEN = 12, // Message "AAS target is moving / can follow"
	AAS_OBJ_VERLUST = 13, // message "AAS object loss"
	AAS_OBJ_WECHSEL = 14, // Message "AAS new object / object change"
	PAS_EIN = 15, // Message "Switch on PAS / PAS active"
	PAS_AUS = 16, // Message "Turn off PAS / PAS off"
	PAS_NV = 17, // Message "PAS cannot be activated"
}

impl TryFrom<u8> for ART_258h_ASSIST_ANZ_V2 {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::IDLE),
			1 => Ok(Self::DBC_LIM),
			2 => Ok(Self::DBC_AUS),
			3 => Ok(Self::DBC_AUS_TON),
			4 => Ok(Self::DBC_NV_AKT),
			5 => Ok(Self::DBC_NV_LIM),
			6 => Ok(Self::AAS_EIN),
			7 => Ok(Self::AAS_AUS),
			8 => Ok(Self::AAS_AUS_TON),
			9 => Ok(Self::AAS_NV_LIM),
			10 => Ok(Self::AAS_NV_OBJ),
			11 => Ok(Self::AAS_NV_FBED),
			12 => Ok(Self::AAS_FOLGEN),
			13 => Ok(Self::AAS_OBJ_VERLUST),
			14 => Ok(Self::AAS_OBJ_WECHSEL),
			15 => Ok(Self::PAS_EIN),
			16 => Ok(Self::PAS_AUS),
			17 => Ok(Self::PAS_NV),
			_ => Err(())
		}
	}
}
/// Flat roll warning alerts
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_270h_PRW_WARN {
	OK = 0, // no warning
	WARN_OHNE = 1, // Tire pressure warning without position information
	PRW_NV = 2, // PRW not available
	PRW_START = 3, // Restart PRW
	WARN_VL = 4, // Front left tire pressure warning
	WARN_VR = 5, // Front right tire pressure warning
	WARN_HL = 6, // Rear left tire pressure warning
	WARN_HR = 7, // Rear right tire pressure warning
	NICHT_DEFINIERT8 = 8, // Unknown
	NICHT_DEFINIERT14 = 14, // Unknown
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for BS_270h_PRW_WARN {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::WARN_OHNE),
			2 => Ok(Self::PRW_NV),
			3 => Ok(Self::PRW_START),
			4 => Ok(Self::WARN_VL),
			5 => Ok(Self::WARN_VR),
			6 => Ok(Self::WARN_HL),
			7 => Ok(Self::WARN_HR),
			8 => Ok(Self::NICHT_DEFINIERT8),
			14 => Ok(Self::NICHT_DEFINIERT14),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Flat roll warning status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_270h_PRW_ST {
	EIN = 0, // PRW active, no warning
	WARN = 1, // PRW active, warning is present
	AUS = 2, // PRW inactive or not available
	INIT = 3, // PRW is being initialized
	NICHT_DEFINIERT4 = 4, // Unknown
	NICHT_DEFINIERT5 = 5, // Unknown
	PRW_NV = 6, // PRW absent
	SNV = 7, // Signal not available
}

impl TryFrom<u8> for BS_270h_PRW_ST {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::EIN),
			1 => Ok(Self::WARN),
			2 => Ok(Self::AUS),
			3 => Ok(Self::INIT),
			4 => Ok(Self::NICHT_DEFINIERT4),
			5 => Ok(Self::NICHT_DEFINIERT5),
			6 => Ok(Self::PRW_NV),
			7 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Presafe status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_270h_PRESF_STAT {
	UEBER_SCHWELLE = 0, // no PRE_SAFE situation detected. Vehicle acceleration above threshold
	UNTER_SCHWELLE = 1, // no PRE_SAFE situation detected. Vehicle acceleration below threshold
	LAENGS = 2, // PRE_SAFE Longitudinal dynamics hazard detected
	QUER = 4, // PRE_SAFE lateral dynamics hazard detected
	LAENGS_QUER = 6, // PRE_SAFE Longitudinal and lateral dynamics hazard detected
	SNV = 15, // Signal not available
}

impl TryFrom<u8> for BS_270h_PRESF_STAT {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::UEBER_SCHWELLE),
			1 => Ok(Self::UNTER_SCHWELLE),
			2 => Ok(Self::LAENGS),
			4 => Ok(Self::QUER),
			6 => Ok(Self::LAENGS_QUER),
			15 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Send cycle time
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_300h_T_Z {
	NICHT_DEFINIERT = 0, // Unknown
	T20_0 = 1, // Send cycle time 20 ms
	T23_1 = 2, // Send cycle time 23.1 ms
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_300h_T_Z {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::NICHT_DEFINIERT),
			1 => Ok(Self::T20_0),
			2 => Ok(Self::T23_1),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// Driver brakes
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_300h_SFB {
	BREMSE_NEIN = 0, // Driver does not brake
	BREMSE_JA = 1, // Driver brakes
	NICHT_DEFINIERT = 2, // Unknown
	SNV = 3, // Signal not available
}

impl TryFrom<u8> for BS_300h_SFB {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::BREMSE_NEIN),
			1 => Ok(Self::BREMSE_JA),
			2 => Ok(Self::NICHT_DEFINIERT),
			3 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}
/// EMS error info
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_328h_EHB_ERR {
	OK = 0, // No error
	BRE_DEF = 1, // Red "Brake defective!, STOP, stop!"
	RBLSTG_M = 2, // Red "Reduced braking power, start engine!"
	BREUEHITZ = 3, // Red "Brake overheated, drive carefully!"
	RBLSTG_W2 = 4, // Red "Reduced braking performance, visit workshop!" (only 240)
	RBLSTG_W = 5, // Red "Reduced braking performance, visit workshop!"
	SB_W_GELB = 6, // Yellow "Service brakes, visit workshop"
	BRE_DEF_DIAGNOSE = 7, // Red "Brake defective,! STOP, diagnosis
}

impl TryFrom<u8> for BS_328h_EHB_ERR {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::BRE_DEF),
			2 => Ok(Self::RBLSTG_M),
			3 => Ok(Self::BREUEHITZ),
			4 => Ok(Self::RBLSTG_W2),
			5 => Ok(Self::RBLSTG_W),
			6 => Ok(Self::SB_W_GELB),
			7 => Ok(Self::BRE_DEF_DIAGNOSE),
			_ => Err(())
		}
	}
}
/// EHB vehicle electrical system status
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_328h_EHB_BN {
	U_GRUEN = 0, // U_EHB > 10.5 V for t > 500 ms
	U_GELB = 1, // 9.5 V < U_EHB <= 10.5 V for t > 500 ms
	U_ROT = 2, // 8.5 V < U_EHB <= 9.5 V for t > 500 ms
	U_MIN = 3, // U_EHB <= 8.5 V (Bosch only: or signal not available)
}

impl TryFrom<u8> for BS_328h_EHB_BN {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::U_GRUEN),
			1 => Ok(Self::U_GELB),
			2 => Ok(Self::U_ROT),
			3 => Ok(Self::U_MIN),
			_ => Err(())
		}
	}
}
/// ESP display messages
#[derive(Debug, Copy, Clone, PartialEq, Eq, Ord, PartialOrd)]
#[repr(C)]
pub enum BS_328h_ESP_DSPL {
	OK = 0, // No error
	ESP_DEF = 1, // ESP defective
	ESP_OFF = 2, // ESP not available
	ESP_OFF_DS = 3, // ESP not available, differential voltage. active (only 463/461)
	BAS_DEF = 4, // BAS defective
	ABS_DEF = 5, // ABS defect (only 463/461)
	ABS_OFF = 6, // ABS not available (463/461 only)
	BKV_DEF_GBV = 7, // BKV defective (only 463/461)
	ALL_OFF_DS = 8, // ABS, BAS and ESP not available (only 463/461)
	SBCSAR_DEF = 9, // Stop&Roll defective
	SBCSAR_ON = 10, // Stop&Roll on
	SBCH_N_AKT = 11, // SBC Hold cannot be activated
	ESP_BAS_DEF = 13, // BAS and ESP defective
	SBCH_OFF = 14, // SBC hold off
	SBCH = 15, // SBC Hold
	ALL_DEF = 16, // ABS, BAS and ESP defective
	ALL_DEF_GBV = 17, // ABS, BAS, ESP and BKV defective
	ALL_DIAG = 19, // ABS, BAS and ESP Diag. test
	ALL_DIAG_GBV = 20, // ABS, BAS, ESP and BKV Diag. test
	ALL_OFF = 22, // ABS, BAS and ESP not available
	ALL_OFF_GBV = 23, // ABS, BAS, ESP and BKV not available
	SBCS = 24, // SBC stop
	SBCS_OFF = 25, // SBC stop off
	BRAKE = 26, // Brake immediately!
	SBCS_N_AKT = 27, // SBC stop cannot be activated
	SBCH_DEF = 28, // SBC hold defective
	SBCS_DEF = 29, // SBC stop defective
	GWH_P = 30, // selector lever to P
	SNV = 31, // Signal not available
}

impl TryFrom<u8> for BS_328h_ESP_DSPL {
	type Error = ();
	fn try_from(value: u8) -> Result<Self, Self::Error> {
		match value {
			0 => Ok(Self::OK),
			1 => Ok(Self::ESP_DEF),
			2 => Ok(Self::ESP_OFF),
			3 => Ok(Self::ESP_OFF_DS),
			4 => Ok(Self::BAS_DEF),
			5 => Ok(Self::ABS_DEF),
			6 => Ok(Self::ABS_OFF),
			7 => Ok(Self::BKV_DEF_GBV),
			8 => Ok(Self::ALL_OFF_DS),
			9 => Ok(Self::SBCSAR_DEF),
			10 => Ok(Self::SBCSAR_ON),
			11 => Ok(Self::SBCH_N_AKT),
			13 => Ok(Self::ESP_BAS_DEF),
			14 => Ok(Self::SBCH_OFF),
			15 => Ok(Self::SBCH),
			16 => Ok(Self::ALL_DEF),
			17 => Ok(Self::ALL_DEF_GBV),
			19 => Ok(Self::ALL_DIAG),
			20 => Ok(Self::ALL_DIAG_GBV),
			22 => Ok(Self::ALL_OFF),
			23 => Ok(Self::ALL_OFF_GBV),
			24 => Ok(Self::SBCS),
			25 => Ok(Self::SBCS_OFF),
			26 => Ok(Self::BRAKE),
			27 => Ok(Self::SBCS_N_AKT),
			28 => Ok(Self::SBCH_DEF),
			29 => Ok(Self::SBCS_DEF),
			30 => Ok(Self::GWH_P),
			31 => Ok(Self::SNV),
			_ => Err(())
		}
	}
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct RDU_A1(pub u64);

impl RDU_A1 {

	/// Gets CAN ID of RDU_A1
	pub const fn get_canid() -> u16 { RDU_A1_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets SUB ID identifier. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SUB_ID(&mut self, value: u8){ self.0 = (self.0 & 0x0fffffffffffffff) | ((value as u64) & 0xf) << 60; }

    /// Gets SUB ID identifier. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SUB_ID(&self) -> u8 { (self.0 >> 60 & 0xf) as u8 }
        
    /// Sets Vehicle's own speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_V_FZG(&mut self, value: u16){ self.0 = (self.0 & 0xf000ffffffffffff) | ((value as u64) & 0xfff) << 48; }

    /// Gets Vehicle's own speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_V_FZG(&self) -> u16 { (self.0 >> 48 & 0xfff) as u16 }
        
    /// Sets SubID Value 1. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SUB_ID_VAL1(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets SubID Value 1. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SUB_ID_VAL1(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets Sub ID Value 2. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SUB_ID_VAL2(&mut self, value: u8){ self.0 = (self.0 & 0xffffff00ffffffff) | ((value as u64) & 0xff) << 32; }

    /// Gets Sub ID Value 2. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SUB_ID_VAL2(&self) -> u8 { (self.0 >> 32 & 0xff) as u8 }
        
    /// Sets Mileage. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_KM16(&mut self, value: u16){ self.0 = (self.0 & 0xffffffff0000ffff) | ((value as u64) & 0xffff) << 16; }

    /// Gets Mileage. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_KM16(&self) -> u16 { (self.0 >> 16 & 0xffff) as u16 }
        
    /// Sets Vehicle direction reverse

    pub fn set_VEH_DIR_REVERSE(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Vehicle direction reverse
    pub fn get_VEH_DIR_REVERSE(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets LRG target in use

    pub fn set_LRG_TARGET_AC(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets LRG target in use
    pub fn get_LRG_TARGET_AC(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets turn off tracking by speed V>260km/h

    pub fn set_TRCK_OFF_SPD(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets turn off tracking by speed V>260km/h
    pub fn get_TRCK_OFF_SPD(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets DTR present

    pub fn set_DTR_VH(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets DTR present
    pub fn get_DTR_VH(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Vehicle standstill detected

    pub fn set_FZG_STEHT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffff7ff) | ((value as u64) & 0x1) << 11; }

    /// Gets Vehicle standstill detected
    pub fn get_FZG_STEHT(&self) -> bool { (self.0 >> 11 & 0x1) != 0 }
        
    /// Sets Sensor installation position rotated by 180°

    pub fn set_SENS_GEDR(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffbff) | ((value as u64) & 0x1) << 10; }

    /// Gets Sensor installation position rotated by 180°
    pub fn get_SENS_GEDR(&self) -> bool { (self.0 >> 10 & 0x1) != 0 }
        
    /// Sets Host not OK

    pub fn set_HOST_NOT_OK(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffdff) | ((value as u64) & 0x1) << 9; }

    /// Gets Host not OK
    pub fn get_HOST_NOT_OK(&self) -> bool { (self.0 >> 9 & 0x1) != 0 }
        
    /// Sets Engine is running

    pub fn set_MOT_LFT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffeff) | ((value as u64) & 0x1) << 8; }

    /// Gets Engine is running
    pub fn get_MOT_LFT(&self) -> bool { (self.0 >> 8 & 0x1) != 0 }
        
    /// Sets Linear controller diagnosis mode

    pub fn set_DIAGMODE(&mut self, value: RDU_A1_DIAGMODE){ self.0 = (self.0 & 0xffffffffffffff3f) | ((value as u64) & 0x3) << 6; }

    /// Gets Linear controller diagnosis mode
    pub fn get_DIAGMODE(&self) -> std::result::Result<RDU_A1_DIAGMODE, ()> { return RDU_A1_DIAGMODE::try_from((self.0 >> 6 & 0x3) as u8) }
        
    /// Sets lane configuration

    pub fn set_SPUHR_KONF(&mut self, value: RDU_A1_SPUHR_KONF){ self.0 = (self.0 & 0xffffffffffffffcf) | ((value as u64) & 0x3) << 4; }

    /// Gets lane configuration
    pub fn get_SPUHR_KONF(&self) -> std::result::Result<RDU_A1_SPUHR_KONF, ()> { return RDU_A1_SPUHR_KONF::try_from((self.0 >> 4 & 0x3) as u8) }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct RDU_A2(pub u64);

impl RDU_A2 {

	/// Gets CAN ID of RDU_A2
	pub const fn get_canid() -> u16 { RDU_A2_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_AY_S(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_AY_S(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_GIER_ROH(&mut self, value: u16){ self.0 = (self.0 & 0xff0000ffffffffff) | ((value as u64) & 0xffff) << 40; }

    /// Gets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_GIER_ROH(&self) -> u16 { (self.0 >> 40 & 0xffff) as u16 }
        
    /// Sets Steering wheel angle sensor status

    pub fn set_LRWS_ST(&mut self, value: RDU_A2_LRWS_ST){ self.0 = (self.0 & 0xffffff3fffffffff) | ((value as u64) & 0x3) << 38; }

    /// Gets Steering wheel angle sensor status
    pub fn get_LRWS_ST(&self) -> std::result::Result<RDU_A2_LRWS_ST, ()> { return RDU_A2_LRWS_ST::try_from((self.0 >> 38 & 0x3) as u8) }
        
    /// Sets steering wheel angle. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_LRW(&mut self, value: u16){ self.0 = (self.0 & 0xffffffc000ffffff) | ((value as u64) & 0x3fff) << 24; }

    /// Gets steering wheel angle. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_LRW(&self) -> u16 { (self.0 >> 24 & 0x3fff) as u16 }
        
    /// Sets Active Steering Control available

    pub fn set_ASC_AVL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets Active Steering Control available
    pub fn get_ASC_AVL(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets steering wheel angular velocity. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_VLRW(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffc000ff) | ((value as u64) & 0x3fff) << 8; }

    /// Gets steering wheel angular velocity. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_VLRW(&self) -> u16 { (self.0 >> 8 & 0x3fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct RDU_A3(pub u64);

impl RDU_A3 {

	/// Gets CAN ID of RDU_A3
	pub const fn get_canid() -> u16 { RDU_A3_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Direction of rotation of wheel, front left

    pub fn set_DRTGVL(&mut self, value: RDU_A3_DRTGVL){ self.0 = (self.0 & 0x3fffffffffffffff) | ((value as u64) & 0x3) << 62; }

    /// Gets Direction of rotation of wheel, front left
    pub fn get_DRTGVL(&self) -> std::result::Result<RDU_A3_DRTGVL, ()> { return RDU_A3_DRTGVL::try_from((self.0 >> 62 & 0x3) as u8) }
        
    /// Sets Front left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DVL(&mut self, value: u16){ self.0 = (self.0 & 0xc000ffffffffffff) | ((value as u64) & 0x3fff) << 48; }

    /// Gets Front left wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DVL(&self) -> u16 { (self.0 >> 48 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of wheel, front right

    pub fn set_DRTGVR(&mut self, value: RDU_A3_DRTGVR){ self.0 = (self.0 & 0xffff3fffffffffff) | ((value as u64) & 0x3) << 46; }

    /// Gets Direction of rotation of wheel, front right
    pub fn get_DRTGVR(&self) -> std::result::Result<RDU_A3_DRTGVR, ()> { return RDU_A3_DRTGVR::try_from((self.0 >> 46 & 0x3) as u8) }
        
    /// Sets front right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DVR(&mut self, value: u16){ self.0 = (self.0 & 0xffffc000ffffffff) | ((value as u64) & 0x3fff) << 32; }

    /// Gets front right wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DVR(&self) -> u16 { (self.0 >> 32 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of rear left wheel

    pub fn set_DRTGHL(&mut self, value: RDU_A3_DRTGHL){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Direction of rotation of rear left wheel
    pub fn get_DRTGHL(&self) -> std::result::Result<RDU_A3_DRTGHL, ()> { return RDU_A3_DRTGHL::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets Rear left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DHL(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffc000ffff) | ((value as u64) & 0x3fff) << 16; }

    /// Gets Rear left wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DHL(&self) -> u16 { (self.0 >> 16 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of rear wheel to the right

    pub fn set_DRTGHR(&mut self, value: RDU_A3_DRTGHR){ self.0 = (self.0 & 0xffffffffffff3fff) | ((value as u64) & 0x3) << 14; }

    /// Gets Direction of rotation of rear wheel to the right
    pub fn get_DRTGHR(&self) -> std::result::Result<RDU_A3_DRTGHR, ()> { return RDU_A3_DRTGHR::try_from((self.0 >> 14 & 0x3) as u8) }
        
    /// Sets Rear right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DHR(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffffc000) | ((value as u64) & 0x3fff) << 0; }

    /// Gets Rear right wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DHR(&self) -> u16 { (self.0 >> 0 & 0x3fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct BS_200(pub u64);

impl BS_200 {

	/// Gets CAN ID of BS_200
	pub const fn get_canid() -> u16 { BS_200_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Brake defective warning lamp (EBV_KL on 463/461/NCV2)

    pub fn set_BRE_KL(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Brake defective warning lamp (EBV_KL on 463/461/NCV2)
    pub fn get_BRE_KL(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets ESP info lamp flashing light

    pub fn set_ESP_INFO_BL(&mut self, value: bool){ self.0 = (self.0 & 0xdfffffffffffffff) | ((value as u64) & 0x1) << 61; }

    /// Gets ESP info lamp flashing light
    pub fn get_ESP_INFO_BL(&self) -> bool { (self.0 >> 61 & 0x1) != 0 }
        
    /// Sets ESP info lamp steady light

    pub fn set_ESP_INFO_DL(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets ESP info lamp steady light
    pub fn get_ESP_INFO_DL(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets ESP faulty indicator lamp

    pub fn set_ESP_KL(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets ESP faulty indicator lamp
    pub fn get_ESP_KL(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
    /// Sets ABS defective warning lamp

    pub fn set_ABS_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfbffffffffffffff) | ((value as u64) & 0x1) << 58; }

    /// Gets ABS defective warning lamp
    pub fn get_ABS_KL(&self) -> bool { (self.0 >> 58 & 0x1) != 0 }
        
    /// Sets Handbrake applied (indicator lamp)

    pub fn set_HAS_KL(&mut self, value: bool){ self.0 = (self.0 & 0xfdffffffffffffff) | ((value as u64) & 0x1) << 57; }

    /// Gets Handbrake applied (indicator lamp)
    pub fn get_HAS_KL(&self) -> bool { (self.0 >> 57 & 0x1) != 0 }
        
    /// Sets BLS Parity (even parity)

    pub fn set_BLS_PA(&mut self, value: bool){ self.0 = (self.0 & 0xffbfffffffffffff) | ((value as u64) & 0x1) << 54; }

    /// Gets BLS Parity (even parity)
    pub fn get_BLS_PA(&self) -> bool { (self.0 >> 54 & 0x1) != 0 }
        
    /// Sets message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_BZ200h(&mut self, value: u8){ self.0 = (self.0 & 0xffc3ffffffffffff) | ((value as u64) & 0xf) << 50; }

    /// Gets message counter. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_BZ200h(&self) -> u8 { (self.0 >> 50 & 0xf) as u8 }
        
    /// Sets brake light switch

    pub fn set_BLS(&mut self, value: BS_200h_BLS){ self.0 = (self.0 & 0xfffcffffffffffff) | ((value as u64) & 0x3) << 48; }

    /// Gets brake light switch
    pub fn get_BLS(&self) -> std::result::Result<BS_200h_BLS, ()> { return BS_200h_BLS::try_from((self.0 >> 48 & 0x3) as u8) }
        
    /// Sets Direction of rotation of wheel, front left

    pub fn set_DRTGVL(&mut self, value: BS_200h_DRTGVL){ self.0 = (self.0 & 0xffff3fffffffffff) | ((value as u64) & 0x3) << 46; }

    /// Gets Direction of rotation of wheel, front left
    pub fn get_DRTGVL(&self) -> std::result::Result<BS_200h_DRTGVL, ()> { return BS_200h_DRTGVL::try_from((self.0 >> 46 & 0x3) as u8) }
        
    /// Sets Front left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DVL(&mut self, value: u16){ self.0 = (self.0 & 0xffffc000ffffffff) | ((value as u64) & 0x3fff) << 32; }

    /// Gets Front left wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DVL(&self) -> u16 { (self.0 >> 32 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of wheel, front right

    pub fn set_DRTGVR(&mut self, value: BS_200h_DRTGVR){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Direction of rotation of wheel, front right
    pub fn get_DRTGVR(&self) -> std::result::Result<BS_200h_DRTGVR, ()> { return BS_200h_DRTGVR::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets front right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DVR(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffc000ffff) | ((value as u64) & 0x3fff) << 16; }

    /// Gets front right wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DVR(&self) -> u16 { (self.0 >> 16 & 0x3fff) as u16 }
        
    /// Sets Left wheel rotation for cruise control

    pub fn set_DRTGTM(&mut self, value: BS_200h_DRTGTM){ self.0 = (self.0 & 0xffffffffffff3fff) | ((value as u64) & 0x3) << 14; }

    /// Gets Left wheel rotation for cruise control
    pub fn get_DRTGTM(&self) -> std::result::Result<BS_200h_DRTGTM, ()> { return BS_200h_DRTGTM::try_from((self.0 >> 14 & 0x3) as u8) }
        
    /// Sets Left wheel speed for cruise control. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_TM_DL(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffffc000) | ((value as u64) & 0x3fff) << 0; }

    /// Gets Left wheel speed for cruise control. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_TM_DL(&self) -> u16 { (self.0 >> 0 & 0x3fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct BS_208(pub u64);

impl BS_208 {

	/// Gets CAN ID of BS_208
	pub const fn get_canid() -> u16 { BS_208_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets ESP/ART request: "Active downshift"

    pub fn set_AKT_R_ESP(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets ESP/ART request: "Active downshift"
    pub fn get_AKT_R_ESP(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Target gear request from ART

    pub fn set_MINMAX_ART(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Target gear request from ART
    pub fn get_MINMAX_ART(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets target gear, upper limit

    pub fn set_GMAX_ESP(&mut self, value: BS_208h_GMAX_ESP){ self.0 = (self.0 & 0xc7ffffffffffffff) | ((value as u64) & 0x7) << 59; }

    /// Gets target gear, upper limit
    pub fn get_GMAX_ESP(&self) -> std::result::Result<BS_208h_GMAX_ESP, ()> { return BS_208h_GMAX_ESP::try_from((self.0 >> 59 & 0x7) as u8) }
        
    /// Sets target gear, lower limit

    pub fn set_GMIN_ESP(&mut self, value: BS_208h_GMIN_ESP){ self.0 = (self.0 & 0xf8ffffffffffffff) | ((value as u64) & 0x7) << 56; }

    /// Gets target gear, lower limit
    pub fn get_GMIN_ESP(&self) -> std::result::Result<BS_208h_GMIN_ESP, ()> { return BS_208h_GMIN_ESP::try_from((self.0 >> 56 & 0x7) as u8) }
        
    /// Sets Suppression of dynamic full-load downshift

    pub fn set_DDYN_UNT(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets Suppression of dynamic full-load downshift
    pub fn get_DDYN_UNT(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets system state

    pub fn set_SZS(&mut self, value: BS_208h_SZS){ self.0 = (self.0 & 0xff9fffffffffffff) | ((value as u64) & 0x3) << 53; }

    /// Gets system state
    pub fn get_SZS(&self) -> std::result::Result<BS_208h_SZS, ()> { return BS_208h_SZS::try_from((self.0 >> 53 & 0x3) as u8) }
        
    /// Sets Cruise control off

    pub fn set_TM_AUS(&mut self, value: bool){ self.0 = (self.0 & 0xffefffffffffffff) | ((value as u64) & 0x1) << 52; }

    /// Gets Cruise control off
    pub fn get_TM_AUS(&self) -> bool { (self.0 >> 52 & 0x1) != 0 }
        
    /// Sets ESP switching line shift

    pub fn set_SLV_ESP(&mut self, value: BS_208h_SLV_ESP){ self.0 = (self.0 & 0xfff0ffffffffffff) | ((value as u64) & 0xf) << 48; }

    /// Gets ESP switching line shift
    pub fn get_SLV_ESP(&self) -> std::result::Result<BS_208h_SLV_ESP, ()> { return BS_208h_SLV_ESP::try_from((self.0 >> 48 & 0xf) as u8) }
        
    /// Sets ESP brake intervention active

    pub fn set_BRE_AKT_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xffff7fffffffffff) | ((value as u64) & 0x1) << 47; }

    /// Gets ESP brake intervention active
    pub fn get_BRE_AKT_ESP(&self) -> bool { (self.0 >> 47 & 0x1) != 0 }
        
    /// Sets ESP request: insert "N".

    pub fn set_ANFN(&mut self, value: BS_208h_ANFN){ self.0 = (self.0 & 0xffff9fffffffffff) | ((value as u64) & 0x3) << 45; }

    /// Gets ESP request: insert "N".
    pub fn get_ANFN(&self) -> std::result::Result<BS_208h_ANFN, ()> { return BS_208h_ANFN::try_from((self.0 >> 45 & 0x3) as u8) }
        
    /// Sets ART brake intervention active

    pub fn set_BRE_AKT_ART(&mut self, value: bool){ self.0 = (self.0 & 0xffffefffffffffff) | ((value as u64) & 0x1) << 44; }

    /// Gets ART brake intervention active
    pub fn get_BRE_AKT_ART(&self) -> bool { (self.0 >> 44 & 0x1) != 0 }
        
    /// Sets Set braking torque (BR240 factor 1.8 larger). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_MBRE_ESP(&mut self, value: u16){ self.0 = (self.0 & 0xfffff000ffffffff) | ((value as u64) & 0xfff) << 32; }

    /// Gets Set braking torque (BR240 factor 1.8 larger). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_MBRE_ESP(&self) -> u16 { (self.0 >> 32 & 0xfff) as u16 }
        
    /// Sets Direction of rotation of rear wheel to the right

    pub fn set_DRTGHR(&mut self, value: BS_208h_DRTGHR){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets Direction of rotation of rear wheel to the right
    pub fn get_DRTGHR(&self) -> std::result::Result<BS_208h_DRTGHR, ()> { return BS_208h_DRTGHR::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets Rear right wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DHR(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffc000ffff) | ((value as u64) & 0x3fff) << 16; }

    /// Gets Rear right wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DHR(&self) -> u16 { (self.0 >> 16 & 0x3fff) as u16 }
        
    /// Sets Direction of rotation of rear left wheel

    pub fn set_DRTGHL(&mut self, value: BS_208h_DRTGHL){ self.0 = (self.0 & 0xffffffffffff3fff) | ((value as u64) & 0x3) << 14; }

    /// Gets Direction of rotation of rear left wheel
    pub fn get_DRTGHL(&self) -> std::result::Result<BS_208h_DRTGHL, ()> { return BS_208h_DRTGHL::try_from((self.0 >> 14 & 0x3) as u8) }
        
    /// Sets Rear left wheel speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DHL(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffffc000) | ((value as u64) & 0x3fff) << 0; }

    /// Gets Rear left wheel speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DHL(&self) -> u16 { (self.0 >> 0 & 0x3fff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct ART_258(pub u64);

impl ART_258 {

	/// Gets CAN ID of ART_258
	pub const fn get_canid() -> u16 { ART_258_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Switch display to ART display

    pub fn set_ART_DSPL_EIN(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Switch display to ART display
    pub fn get_ART_DSPL_EIN(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Standing object detection

    pub fn set_S_OBJ(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Standing object detection
    pub fn get_S_OBJ(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets ART warning sound

    pub fn set_ART_WT(&mut self, value: bool){ self.0 = (self.0 & 0xdfffffffffffffff) | ((value as u64) & 0x1) << 61; }

    /// Gets ART warning sound
    pub fn get_ART_WT(&self) -> bool { (self.0 >> 61 & 0x1) != 0 }
        
    /// Sets ART info lamp

    pub fn set_ART_INFO(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets ART info lamp
    pub fn get_ART_INFO(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets ART error code

    pub fn set_ART_ERR(&mut self, value: ART_258h_ART_ERR){ self.0 = (self.0 & 0xf0ffffffffffffff) | ((value as u64) & 0xf) << 56; }

    /// Gets ART error code
    pub fn get_ART_ERR(&self) -> std::result::Result<ART_258h_ART_ERR, ()> { return ART_258h_ART_ERR::try_from((self.0 >> 56 & 0xf) as u8) }
        
    /// Sets set ART speed. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_V_ART(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets set ART speed. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_V_ART(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets distance relevant object. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_ABST_R_OBJ(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets distance relevant object. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_ABST_R_OBJ(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets driver's desired distance. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_SOLL_ABST(&mut self, value: u8){ self.0 = (self.0 & 0xffffff00ffffffff) | ((value as u64) & 0xff) << 32; }

    /// Gets driver's desired distance. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_SOLL_ABST(&self) -> u8 { (self.0 >> 32 & 0xff) as u8 }
        
    /// Sets "Winter tire limit reached" message on the display

    pub fn set_ART_DSPL_PGB(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets "Winter tire limit reached" message on the display
    pub fn get_ART_DSPL_PGB(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Display shows "DTR OFF [0]".

    pub fn set_ART_VFBR(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Display shows "DTR OFF [0]".
    pub fn get_ART_VFBR(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets "---" is shown on the display

    pub fn set_ART_DSPL_LIM(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets "---" is shown on the display
    pub fn get_ART_DSPL_LIM(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets Adaptive cruise control switched on

    pub fn set_ART_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffefffffff) | ((value as u64) & 0x1) << 28; }

    /// Gets Adaptive cruise control switched on
    pub fn get_ART_EIN(&self) -> bool { (self.0 >> 28 & 0x1) != 0 }
        
    /// Sets Relevant object detected

    pub fn set_OBJ_ERK(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffff7ffffff) | ((value as u64) & 0x1) << 27; }

    /// Gets Relevant object detected
    pub fn get_OBJ_ERK(&self) -> bool { (self.0 >> 27 & 0x1) != 0 }
        
    /// Sets Turn on ART segment display

    pub fn set_ART_SEG_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffbffffff) | ((value as u64) & 0x1) << 26; }

    /// Gets Turn on ART segment display
    pub fn get_ART_SEG_EIN(&self) -> bool { (self.0 >> 26 & 0x1) != 0 }
        
    /// Sets Speed ​​display flashing

    pub fn set_ART_DSPL_BL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffdffffff) | ((value as u64) & 0x1) << 25; }

    /// Gets Speed ​​display flashing
    pub fn get_ART_DSPL_BL(&self) -> bool { (self.0 >> 25 & 0x1) != 0 }
        
    /// Sets ART cruise control on

    pub fn set_TM_EIN_ART(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffeffffff) | ((value as u64) & 0x1) << 24; }

    /// Gets ART cruise control on
    pub fn get_TM_EIN_ART(&self) -> bool { (self.0 >> 24 & 0x1) != 0 }
        
    /// Sets Speed ​​of detected target vehicle. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_V_ZIEL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffff00ffff) | ((value as u64) & 0xff) << 16; }

    /// Gets Speed ​​of detected target vehicle. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_V_ZIEL(&self) -> u8 { (self.0 >> 16 & 0xff) as u8 }
        
    /// Sets Retrigger minimum display time

    pub fn set_ART_DSPL_NEU(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffff7fff) | ((value as u64) & 0x1) << 15; }

    /// Gets Retrigger minimum display time
    pub fn get_ART_DSPL_NEU(&self) -> bool { (self.0 >> 15 & 0x1) != 0 }
        
    /// Sets ART is dubbed by the driver

    pub fn set_ART_UEBERSP(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffbfff) | ((value as u64) & 0x1) << 14; }

    /// Gets ART is dubbed by the driver
    pub fn get_ART_UEBERSP(&self) -> bool { (self.0 >> 14 & 0x1) != 0 }
        
    /// Sets Display of the system availability after a system error

    pub fn set_ART_REAKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffdfff) | ((value as u64) & 0x1) << 13; }

    /// Gets Display of the system availability after a system error
    pub fn get_ART_REAKT(&self) -> bool { (self.0 >> 13 & 0x1) != 0 }
        
    /// Sets ART distance warning is on

    pub fn set_ART_ABW_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffefff) | ((value as u64) & 0x1) << 12; }

    /// Gets ART distance warning is on
    pub fn get_ART_ABW_AKT(&self) -> bool { (self.0 >> 12 & 0x1) != 0 }
        
    /// Sets Object offer distance assistant

    pub fn set_OBJ_AGB(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffff7ff) | ((value as u64) & 0x1) << 11; }

    /// Gets Object offer distance assistant
    pub fn get_OBJ_AGB(&self) -> bool { (self.0 >> 11 & 0x1) != 0 }
        
    /// Sets LED distance assistant flashing

    pub fn set_AAS_LED_BL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffbff) | ((value as u64) & 0x1) << 10; }

    /// Gets LED distance assistant flashing
    pub fn get_AAS_LED_BL(&self) -> bool { (self.0 >> 10 & 0x1) != 0 }
        
    /// Sets Active function

    pub fn set_ASSIST_FKT_AKT(&mut self, value: ART_258h_ASSIST_FKT_AKT){ self.0 = (self.0 & 0xfffffffffffffcff) | ((value as u64) & 0x3) << 8; }

    /// Gets Active function
    pub fn get_ASSIST_FKT_AKT(&self) -> std::result::Result<ART_258h_ASSIST_FKT_AKT, ()> { return ART_258h_ASSIST_FKT_AKT::try_from((self.0 >> 8 & 0x3) as u8) }
        
    /// Sets CAS display request

    pub fn set_CAS_ERR_ANZ_V2(&mut self, value: ART_258h_CAS_ERR_ANZ_V2){ self.0 = (self.0 & 0xffffffffffffff1f) | ((value as u64) & 0x7) << 5; }

    /// Gets CAS display request
    pub fn get_CAS_ERR_ANZ_V2(&self) -> std::result::Result<ART_258h_CAS_ERR_ANZ_V2, ()> { return ART_258h_CAS_ERR_ANZ_V2::try_from((self.0 >> 5 & 0x7) as u8) }
        
    /// Sets Assistance system display request

    pub fn set_ASSIST_ANZ_V2(&mut self, value: ART_258h_ASSIST_ANZ_V2){ self.0 = (self.0 & 0xffffffffffffffe0) | ((value as u64) & 0x1f) << 0; }

    /// Gets Assistance system display request
    pub fn get_ASSIST_ANZ_V2(&self) -> std::result::Result<ART_258h_ASSIST_ANZ_V2, ()> { return ART_258h_ASSIST_ANZ_V2::try_from((self.0 >> 0 & 0x1f) as u8) }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct BS_270(pub u64);

impl BS_270 {

	/// Gets CAN ID of BS_270
	pub const fn get_canid() -> u16 { BS_270_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_RIZ_HL(&mut self, value: u8){ self.0 = (self.0 & 0x00ffffffffffffff) | ((value as u64) & 0xff) << 56; }

    /// Gets Pulse ring counter, rear left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_RIZ_HL(&self) -> u8 { (self.0 >> 56 & 0xff) as u8 }
        
    /// Sets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_RIZ_HR(&mut self, value: u8){ self.0 = (self.0 & 0xff00ffffffffffff) | ((value as u64) & 0xff) << 48; }

    /// Gets Pulse ring counter, rear right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_RIZ_HR(&self) -> u8 { (self.0 >> 48 & 0xff) as u8 }
        
    /// Sets Flat roll warning alerts

    pub fn set_PRW_WARN(&mut self, value: BS_270h_PRW_WARN){ self.0 = (self.0 & 0xffff0fffffffffff) | ((value as u64) & 0xf) << 44; }

    /// Gets Flat roll warning alerts
    pub fn get_PRW_WARN(&self) -> std::result::Result<BS_270h_PRW_WARN, ()> { return BS_270h_PRW_WARN::try_from((self.0 >> 44 & 0xf) as u8) }
        
    /// Sets Flat roll warning status

    pub fn set_PRW_ST(&mut self, value: BS_270h_PRW_ST){ self.0 = (self.0 & 0xfffff8ffffffffff) | ((value as u64) & 0x7) << 40; }

    /// Gets Flat roll warning status
    pub fn get_PRW_ST(&self) -> std::result::Result<BS_270h_PRW_ST, ()> { return BS_270h_PRW_ST::try_from((self.0 >> 40 & 0x7) as u8) }
        
    /// Sets message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_BZ270h(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff0fff) | ((value as u64) & 0xf) << 12; }

    /// Gets message counter. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_BZ270h(&self) -> u8 { (self.0 >> 12 & 0xf) as u8 }
        
    /// Sets Presafe Parity (even parity)

    pub fn set_PRESF_PA(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffffff7f) | ((value as u64) & 0x1) << 7; }

    /// Gets Presafe Parity (even parity)
    pub fn get_PRESF_PA(&self) -> bool { (self.0 >> 7 & 0x1) != 0 }
        
    /// Sets Presafe status

    pub fn set_PRESF_STAT(&mut self, value: BS_270h_PRESF_STAT){ self.0 = (self.0 & 0xffffffffffffffe1) | ((value as u64) & 0xf) << 1; }

    /// Gets Presafe status
    pub fn get_PRESF_STAT(&self) -> std::result::Result<BS_270h_PRESF_STAT, ()> { return BS_270h_PRESF_STAT::try_from((self.0 >> 1 & 0xf) as u8) }
        
    /// Sets Enable Presafe

    pub fn set_PRESF_ENBL(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffffffffe) | ((value as u64) & 0x1) << 0; }

    /// Gets Enable Presafe
    pub fn get_PRESF_ENBL(&self) -> bool { (self.0 >> 0 & 0x1) != 0 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct BS_300(pub u64);

impl BS_300 {

	/// Gets CAN ID of BS_300
	pub const fn get_canid() -> u16 { BS_300_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Engine torque request parity (even parity)

    pub fn set_DMPAR_ART(&mut self, value: bool){ self.0 = (self.0 & 0x7fffffffffffffff) | ((value as u64) & 0x1) << 63; }

    /// Gets Engine torque request parity (even parity)
    pub fn get_DMPAR_ART(&self) -> bool { (self.0 >> 63 & 0x1) != 0 }
        
    /// Sets Dynamic engine torque request

    pub fn set_DMDYN_ART(&mut self, value: bool){ self.0 = (self.0 & 0xbfffffffffffffff) | ((value as u64) & 0x1) << 62; }

    /// Gets Dynamic engine torque request
    pub fn get_DMDYN_ART(&self) -> bool { (self.0 >> 62 & 0x1) != 0 }
        
    /// Sets Emergency braking (ABS controls all 4 wheels)

    pub fn set_VOLLBRE(&mut self, value: bool){ self.0 = (self.0 & 0xefffffffffffffff) | ((value as u64) & 0x1) << 60; }

    /// Gets Emergency braking (ABS controls all 4 wheels)
    pub fn get_VOLLBRE(&self) -> bool { (self.0 >> 60 & 0x1) != 0 }
        
    /// Sets Enable ART

    pub fn set_ART_E(&mut self, value: bool){ self.0 = (self.0 & 0xf7ffffffffffffff) | ((value as u64) & 0x1) << 59; }

    /// Gets Enable ART
    pub fn get_ART_E(&self) -> bool { (self.0 >> 59 & 0x1) != 0 }
        
    /// Sets Steering angle sensor initialization o.k.

    pub fn set_LWS_INI_OK(&mut self, value: bool){ self.0 = (self.0 & 0xfdffffffffffffff) | ((value as u64) & 0x1) << 57; }

    /// Gets Steering angle sensor initialization o.k.
    pub fn get_LWS_INI_OK(&self) -> bool { (self.0 >> 57 & 0x1) != 0 }
        
    /// Sets Steering angle sensor initialization possible

    pub fn set_LWS_INI_EIN(&mut self, value: bool){ self.0 = (self.0 & 0xfeffffffffffffff) | ((value as u64) & 0x1) << 56; }

    /// Gets Steering angle sensor initialization possible
    pub fn get_LWS_INI_EIN(&self) -> bool { (self.0 >> 56 & 0x1) != 0 }
        
    /// Sets Engine torque request parity (even parity)

    pub fn set_MPAR_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xff7fffffffffffff) | ((value as u64) & 0x1) << 55; }

    /// Gets Engine torque request parity (even parity)
    pub fn get_MPAR_ESP(&self) -> bool { (self.0 >> 55 & 0x1) != 0 }
        
    /// Sets Drive torque control active

    pub fn set_AMR_AKT_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xffdfffffffffffff) | ((value as u64) & 0x1) << 53; }

    /// Gets Drive torque control active
    pub fn get_AMR_AKT_ESP(&self) -> bool { (self.0 >> 53 & 0x1) != 0 }
        
    /// Sets Send cycle time

    pub fn set_T_Z(&mut self, value: BS_300h_T_Z){ self.0 = (self.0 & 0xffe7ffffffffffff) | ((value as u64) & 0x3) << 51; }

    /// Gets Send cycle time
    pub fn get_T_Z(&self) -> std::result::Result<BS_300h_T_Z, ()> { return BS_300h_T_Z::try_from((self.0 >> 51 & 0x3) as u8) }
        
    /// Sets driver brakes parity (even parity)

    pub fn set_SFB_PA(&mut self, value: bool){ self.0 = (self.0 & 0xfffbffffffffffff) | ((value as u64) & 0x1) << 50; }

    /// Gets driver brakes parity (even parity)
    pub fn get_SFB_PA(&self) -> bool { (self.0 >> 50 & 0x1) != 0 }
        
    /// Sets Driver brakes

    pub fn set_SFB(&mut self, value: BS_300h_SFB){ self.0 = (self.0 & 0xfffcffffffffffff) | ((value as u64) & 0x3) << 48; }

    /// Gets Driver brakes
    pub fn get_SFB(&self) -> std::result::Result<BS_300h_SFB, ()> { return BS_300h_SFB::try_from((self.0 >> 48 & 0x3) as u8) }
        
    /// Sets Motor torque req. Toggle 40ms +-10

    pub fn set_DMTGL_ART(&mut self, value: bool){ self.0 = (self.0 & 0xffff7fffffffffff) | ((value as u64) & 0x1) << 47; }

    /// Gets Motor torque req. Toggle 40ms +-10
    pub fn get_DMTGL_ART(&self) -> bool { (self.0 >> 47 & 0x1) != 0 }
        
    /// Sets Engine torque request Min

    pub fn set_DMMIN_ART(&mut self, value: bool){ self.0 = (self.0 & 0xffffbfffffffffff) | ((value as u64) & 0x1) << 46; }

    /// Gets Engine torque request Min
    pub fn get_DMMIN_ART(&self) -> bool { (self.0 >> 46 & 0x1) != 0 }
        
    /// Sets Engine torque request max

    pub fn set_DMMAX_ART(&mut self, value: bool){ self.0 = (self.0 & 0xffffdfffffffffff) | ((value as u64) & 0x1) << 45; }

    /// Gets Engine torque request max
    pub fn get_DMMAX_ART(&self) -> bool { (self.0 >> 45 & 0x1) != 0 }
        
    /// Sets Required. engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_DM_ART(&mut self, value: u16){ self.0 = (self.0 & 0xffffe000ffffffff) | ((value as u64) & 0x1fff) << 32; }

    /// Gets Required. engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_DM_ART(&self) -> u16 { (self.0 >> 32 & 0x1fff) as u16 }
        
    /// Sets Motor torque req. Toggle 40ms +-10

    pub fn set_MTGL_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xffffffff7fffffff) | ((value as u64) & 0x1) << 31; }

    /// Gets Motor torque req. Toggle 40ms +-10
    pub fn get_MTGL_ESP(&self) -> bool { (self.0 >> 31 & 0x1) != 0 }
        
    /// Sets Engine torque request Min

    pub fn set_MMIN_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffbfffffff) | ((value as u64) & 0x1) << 30; }

    /// Gets Engine torque request Min
    pub fn get_MMIN_ESP(&self) -> bool { (self.0 >> 30 & 0x1) != 0 }
        
    /// Sets Engine torque request max

    pub fn set_MMAX_ESP(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets Engine torque request max
    pub fn get_MMAX_ESP(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets Required. engine torque. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_M_ESP(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffe000ffff) | ((value as u64) & 0x1fff) << 16; }

    /// Gets Required. engine torque. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_M_ESP(&self) -> u16 { (self.0 >> 16 & 0x1fff) as u16 }
        
    /// Sets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_GIER_ROH(&mut self, value: u16){ self.0 = (self.0 & 0xffffffffffff0000) | ((value as u64) & 0xffff) << 0; }

    /// Gets Raw yaw rate signal without adjustment/filtering (+ = left). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_GIER_ROH(&self) -> u16 { (self.0 >> 0 & 0xffff) as u16 }
        
}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct BS_328(pub u64);

impl BS_328 {

	/// Gets CAN ID of BS_328
	pub const fn get_canid() -> u16 { BS_328_CAN_ID }
	pub fn new(data: u64) -> Self { Self(data) }
    /// Sets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_AY_S(&mut self, value: u8){ self.0 = (self.0 & 0xffff00ffffffffff) | ((value as u64) & 0xff) << 40; }

    /// Gets Vehicle lateral acceleration. in focus (+ = left). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_AY_S(&self) -> u8 { (self.0 >> 40 & 0xff) as u8 }
        
    /// Sets EHB vehicle electrical system parity (even parity)

    pub fn set_EHB_BN_PA(&mut self, value: bool){ self.0 = (self.0 & 0xffffff7fffffffff) | ((value as u64) & 0x1) << 39; }

    /// Gets EHB vehicle electrical system parity (even parity)
    pub fn get_EHB_BN_PA(&self) -> bool { (self.0 >> 39 & 0x1) != 0 }
        
    /// Sets EHB_board network toggle 40ms (every 2nd message)

    pub fn set_EHB_BN_TGL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffbfffffffff) | ((value as u64) & 0x1) << 38; }

    /// Gets EHB_board network toggle 40ms (every 2nd message)
    pub fn get_EHB_BN_TGL(&self) -> bool { (self.0 >> 38 & 0x1) != 0 }
        
    /// Sets EMS error info

    pub fn set_EHB_ERR(&mut self, value: BS_328h_EHB_ERR){ self.0 = (self.0 & 0xffffffc7ffffffff) | ((value as u64) & 0x7) << 35; }

    /// Gets EMS error info
    pub fn get_EHB_ERR(&self) -> std::result::Result<BS_328h_EHB_ERR, ()> { return BS_328h_EHB_ERR::try_from((self.0 >> 35 & 0x7) as u8) }
        
    /// Sets FSG: EHB-ASG in fallback level

    pub fn set_INF_RFE_FSG(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffbffffffff) | ((value as u64) & 0x1) << 34; }

    /// Gets FSG: EHB-ASG in fallback level
    pub fn get_INF_RFE_FSG(&self) -> bool { (self.0 >> 34 & 0x1) != 0 }
        
    /// Sets EHB pump is running

    pub fn set_EHB_PUMPE_LFT(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffdffffffff) | ((value as u64) & 0x1) << 33; }

    /// Gets EHB pump is running
    pub fn get_EHB_PUMPE_LFT(&self) -> bool { (self.0 >> 33 & 0x1) != 0 }
        
    /// Sets Line monitoring possible

    pub fn set_LTG_CHK_POS(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffeffffffff) | ((value as u64) & 0x1) << 32; }

    /// Gets Line monitoring possible
    pub fn get_LTG_CHK_POS(&self) -> bool { (self.0 >> 32 & 0x1) != 0 }
        
    /// Sets EHB vehicle electrical system status

    pub fn set_EHB_BN(&mut self, value: BS_328h_EHB_BN){ self.0 = (self.0 & 0xffffffff3fffffff) | ((value as u64) & 0x3) << 30; }

    /// Gets EHB vehicle electrical system status
    pub fn get_EHB_BN(&self) -> std::result::Result<BS_328h_EHB_BN, ()> { return BS_328h_EHB_BN::try_from((self.0 >> 30 & 0x3) as u8) }
        
    /// Sets EHB on-board power supply increase idling

    pub fn set_EHB_BN_LL(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffdfffffff) | ((value as u64) & 0x1) << 29; }

    /// Gets EHB on-board power supply increase idling
    pub fn get_EHB_BN_LL(&self) -> bool { (self.0 >> 29 & 0x1) != 0 }
        
    /// Sets ESP display messages

    pub fn set_ESP_DSPL(&mut self, value: BS_328h_ESP_DSPL){ self.0 = (self.0 & 0xffffffffe0ffffff) | ((value as u64) & 0x1f) << 24; }

    /// Gets ESP display messages
    pub fn get_ESP_DSPL(&self) -> std::result::Result<BS_328h_ESP_DSPL, ()> { return BS_328h_ESP_DSPL::try_from((self.0 >> 24 & 0x1f) as u8) }
        
    /// Sets Brake pressure control possible

    pub fn set_BRE_AKT_E(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffff7fffff) | ((value as u64) & 0x1) << 23; }

    /// Gets Brake pressure control possible
    pub fn get_BRE_AKT_E(&self) -> bool { (self.0 >> 23 & 0x1) != 0 }
        
    /// Sets emergency braking (brake light flashing)

    pub fn set_NOTBRE(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffbfffff) | ((value as u64) & 0x1) << 22; }

    /// Gets emergency braking (brake light flashing)
    pub fn get_NOTBRE(&self) -> bool { (self.0 >> 22 & 0x1) != 0 }
        
    /// Sets SBC-S/H active, ASG must not switch to "N".

    pub fn set_N_VRBT_SBCSH_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffdfffff) | ((value as u64) & 0x1) << 21; }

    /// Gets SBC-S/H active, ASG must not switch to "N".
    pub fn get_N_VRBT_SBCSH_AKT(&self) -> bool { (self.0 >> 21 & 0x1) != 0 }
        
    /// Sets traffic jam assistant/hillholder active (only 211/230)

    pub fn set_SBCSH_AKT(&mut self, value: bool){ self.0 = (self.0 & 0xffffffffffefffff) | ((value as u64) & 0x1) << 20; }

    /// Gets traffic jam assistant/hillholder active (only 211/230)
    pub fn get_SBCSH_AKT(&self) -> bool { (self.0 >> 20 & 0x1) != 0 }
        
    /// Sets open the clutch

    pub fn set_KPL_OEF(&mut self, value: bool){ self.0 = (self.0 & 0xfffffffffff7ffff) | ((value as u64) & 0x1) << 19; }

    /// Gets open the clutch
    pub fn get_KPL_OEF(&self) -> bool { (self.0 >> 19 & 0x1) != 0 }
        
    /// Sets message counter. Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_BZ328h(&mut self, value: u8){ self.0 = (self.0 & 0xfffffffffff8ffff) | ((value as u64) & 0x7) << 16; }

    /// Gets message counter. Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_BZ328h(&self) -> u8 { (self.0 >> 16 & 0x7) as u8 }
        
    /// Sets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_RIZ_VL(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffff00ff) | ((value as u64) & 0xff) << 8; }

    /// Gets Pulse ring counter, front left wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_RIZ_VL(&self) -> u8 { (self.0 >> 8 & 0xff) as u8 }
        
    /// Sets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To raw from real): y=(x-0.0)/1.00

    pub fn set_RIZ_VR(&mut self, value: u8){ self.0 = (self.0 & 0xffffffffffffff00) | ((value as u64) & 0xff) << 0; }

    /// Gets Pulse ring counter, front right wheel (48 per revolution). Conversion formula (To real from raw): y=(1.00x)+0.0
    pub fn get_RIZ_VR(&self) -> u8 { (self.0 >> 0 & 0xff) as u8 }
        
}